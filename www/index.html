<!DOCTYPE html>
<html lang="en">
<head>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    
<script src="https://sdk.crazygames.com/crazygames-sdk-v3.js"></script>

    <script src="audio.js"></script>
 
 
 <script>
    // 1. INIZIALIZZA SDK CORRETTAMENTE
    window.CrazyGames.SDK.init().then(() => {
        console.log("CrazyGames SDK initialized!");
        
        // 2. ORA puoi usare le funzioni SDK
        initGame();
    }).catch(error => {
        console.error("SDK init failed:", error);
        // Inizia comunque il gioco anche se SDK fallisce (per test locale)
        initGame();
    });

    // 3. FUNZIONE PER MOSTRARE ADS
    async function showAd() {
        try {
            await window.CrazyGames.SDK.ad.requestAd("midgame");
            console.log("Ad completed");
        } catch (error) {
            console.log("Ad error:", error);
        }
    }

    // 4. FUNZIONE PER OTTENERE USER (opzionale)
    async function getUserInfo() {
        try {
            const user = await window.CrazyGames.SDK.user.getUser();
            if (user) {
                console.log("User logged in:", user.username);
                // Salva il nickname
                localStorage.setItem('playerName', user.username);
            }
        } catch (error) {
            console.log("User not logged in");
        }
    }

    // 5. TRACKING EVENTI GAMEPLAY
    function trackGameEvent(eventName, data) {
        window.CrazyGames.SDK.game.gameplayStart();
        
        // Esempi di tracking:
        // Quando inizia un livello
        if (eventName === 'levelStart') {
            window.CrazyGames.SDK.game.gameplayStart();
        }
        // Quando finisce
        if (eventName === 'gameOver') {
            window.CrazyGames.SDK.game.gameplayStop();
        }
    }

    // 6. HAPPY TIME (quando succede qualcosa di bello)
    function triggerHappyTime() {
        window.CrazyGames.SDK.game.happytime();
    }

    // 7. IL TUO GIOCO INIZIA QUI
    function initGame() {
        // Ottieni info user se loggato
        getUserInfo();
        
        // Inizia il tuo gioco
        console.log("Starting Stellar Guardian...");
        
        // Il tuo codice esistente
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        
        // Mostra ad prima di iniziare il gioco
        showAdAndStartGame();
    }

    // 8. SOSTITUISCI LA TUA VECCHIA showAd()
    async function showAdAndStartGame() {
        try {
            // Mostra ad
            await window.CrazyGames.SDK.ad.requestAd("midgame");
        } catch (error) {
            console.log("Ad skipped or failed");
        } finally {
            // Inizia SEMPRE il gioco dopo l'ad
            startGame(true);
        }
    }


</script>
      

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">  
  
<title>üåü STELLAR GUARDIAN - COSMIC DEFENSE FORCE üåü</title>
  <style>
      
      @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');


#nicknameBox {
  background: rgba(0, 0, 0, 0.8) !important; /* Sfondo nero semi-trasparente */
  color: #ffffff !important; /* Testo bianco invece di grigio scuro */
  box-shadow: 0 0 24px #00bcd4;
  border: 2px solid #00bcd4;
  position: relative;
  z-index: 9999;
  backdrop-filter: blur(5px); /* Aggiunge effetto blur */
}

#nicknameInput, #nicknameBox label, #nicknameBox button {
  color: #ffffff !important; /* Bianco invece di #222 */
  font-size: 1.1rem !important;
  background: rgba(255, 255, 255, 0.1); /* Sfondo leggermente pi√π chiaro per input */
}

#nicknameInput {
  background: rgba(255, 255, 255, 0.9) !important; /* Input con sfondo quasi bianco */
  color: #000000 !important; /* Testo nero nell'input per contrasto */
  border: 1px solid #00bcd4;
  padding: 8px;
}

#nicknameBox button {
  background: #00bcd4 !important;
  color: #000000 !important; /* Testo nero sul pulsante azzurro */
  border: none;
  padding: 8px 15px;
  font-weight: bold;
}


.menu-content {
  background: none !important;           /* NIENTE sfondo */
  box-shadow: none !important;           /* NIENTE ombra */
  border: none !important;               /* NIENTE bordo */
  border-radius: 0 !important;           /* NIENTE angoli */
  padding: 0 !important;                 /* Meno spazio */
  max-width: 100vw !important;
  margin: 0 !important;
  text-align: center;
  font-family: 'Press Start 2P', monospace !important;
}

/* Se vuoi un effetto leggerissimo HUD, puoi aggiungere solo una riga trasparente sotto le scritte */
.menu-title, .game-title, .game-subtitle {
  background: none !important;
  box-shadow: none !important;
  border: none !important;
}

.menu-btn {
  font-family: 'Press Start 2P', monospace !important;
  background: url('pixel-btn.png') repeat, linear-gradient(90deg,#ffe700 0%,#00bcd4 100%) !important;
  border: 4px solid #222 !important;
  border-radius: 0 !important;
  box-shadow: 0 4px 0 #ffe700, 0 0 12px #00bcd4 !important;
  color: #222 !important;
  font-size: 1.1rem !important;
  text-shadow: 1px 1px 0 #fff !important;
  padding: 1.2rem 2.3rem !important;
  margin: 0.7rem 0 !important;
  image-rendering: pixelated !important;
}
.menu-btn:active, .menu-btn:hover {
  transform: scale(0.97);
  box-shadow: 0 2px 0 #ffe700, 0 0 16px #ffd700 !important;
  background: url('pixel-btn.png') repeat, linear-gradient(90deg,#00bcd4 0%,#ffe700 100%) !important;
  color: #fff !important;
}

/* Se vuoi pulsanti pi√π piccoli/fluttuanti */
.menu-buttons {
  display: flex !important;
  flex-wrap: wrap !important;
  justify-content: center !important;
  gap: 18px !important;
  background: none !important;
  margin: 18px 0 !important;
}

/* Sottotitoli e nickname floating */
.game-subtitle, #nicknameBox {
  background: none !important;
  box-shadow: none !important;
  border: none !important;
  margin: 18px 0 !important;
}





      /* Sfondo pixel art per i menu */
.galaxy-bg {
  background: url('pixel-art-galaxy.png') repeat !important;
  background-size: 900px 600px !important;
  image-rendering: pixelated !important;
  filter: saturate(1.15) brightness(0.96);
}



/* Titolo pixel art */
.game-title {
  font-family: 'Press Start 2P', monospace !important;
  font-size: 3rem !important;
  color: #ffe700 !important;
  letter-spacing: 0.07em !important;
  text-shadow: 0 0 2px #222, 0 0 8px #ffe700 !important;
  border-bottom: 4px dashed #ffe700 !important;
  padding-bottom: 0.7rem !important;
}


/* Statistiche pixel art */
.stat-item {
  background: url('pixel-dither.png') repeat, #222 !important;
  border: 4px solid #ffe700 !important;
  box-shadow: 0 0 16px #ffd70044 !important;
  font-family: 'Press Start 2P', monospace !important;
  color: #ffe700 !important;
  image-rendering: pixelated !important;
}

.stat-value {
  font-size: 2.0rem !important;
  color: #00bcd4 !important;
  text-shadow: 0 0 2px #222, 0 0 6px #00bcd4 !important;
}
      
      
      /* Galaxy animated background for menu */
.galaxy-bg {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  z-index: 0;
  pointer-events: none;
  background: radial-gradient(ellipse at 60% 30%, #2c3e50 0%, #0a0a2e 65%);
  animation: menuGalaxyMove 18s linear infinite;
}
@keyframes menuGalaxyMove {
  0% { background-position: 0% 0%; }
  100% { background-position: 100% 100%; }
}

/* Glow and shadow for title */
.game-title {
  text-shadow: 0 0 40px #00bcd4, 0 0 80px #ffd700;
  filter: drop-shadow(0 0 12px #ffd700);
  letter-spacing: 0.12em;
}

/* Animated ship icon */
.menu-ship-anim {
  position: absolute;
  bottom: 50px;
  right: 40px;
  animation: floatShipMenu 3s ease-in-out infinite;
  z-index: 2;
}
.menu-ship-anim img {
  width: 110px;
  filter: drop-shadow(0 0 32px #ffd700);
}
@keyframes floatShipMenu {
  0%,100% { transform: translateY(0);}
  50% { transform: translateY(-18px);}
}

.menu-btn {
  font-family: 'Press Start 2P', monospace !important;
  background: url('pixel-btn.png') repeat, linear-gradient(90deg,#ffe700 0%,#00bcd4 100%) !important;
  border: 4px solid #222 !important;
  border-radius: 0 !important;
  box-shadow: 0 4px 0 #ffe700, 0 0 12px #00bcd4 !important;
  color: #222 !important;
  font-size: 1.1rem !important;
  text-shadow: 1px 1px 0 #fff !important;
  padding: 1.2rem 2.3rem !important;
  margin: 0.7rem 0 !important;
  image-rendering: pixelated !important;
}
.menu-btn:active, .menu-btn:hover {
  transform: scale(0.97);
  box-shadow: 0 2px 0 #ffe700, 0 0 16px #ffd700 !important;
  background: url('pixel-btn.png') repeat, linear-gradient(90deg,#00bcd4 0%,#ffe700 100%) !important;
  color: #fff !important;
}

/* Animated menu entrance */
.screen.active#mainMenu {
  animation: menuFadeIn 1.1s cubic-bezier(.5,2,.3,1);
}
@keyframes menuFadeIn {
  0% { opacity:0; transform: scale(0.9);}
  100% { opacity:1; transform: scale(1);}
}

/* Statistic cards visual boost */
.stat-value {
  color: #ffd700;
  font-size: 2.1rem;
  text-shadow: 0 0 12px #ffd700;
}
.stat-item {
  background: linear-gradient(135deg,#0a0a2e 80%,#00bcd4 100%);
  border: 2px solid #ffd700;
  box-shadow: 0 0 18px #ffd70066;
}

/* Coin counter glowing */
#coinCount {
  color: #ffd700;
  font-size: 2.2rem;
  text-shadow: 0 0 16px #ffd700;
  animation: coinPulse 1.3s infinite;
}
@keyframes coinPulse {
  0%,100% { filter:brightness(1);}
  50% { filter:brightness(1.4);}
}

/* Footer beautification */
.menu-content > div:last-child {
  margin-top: 2.5rem;
  color: #00bcd4;
  font-size: 1.1rem;
  opacity: 0.7;
  text-shadow: 0 0 10px #00bcd4;
}

/* Parallax for stat items (desktop only) */
@media (min-width: 700px) {
  .stat-item {
    transition: transform 0.18s;
  }
}
      
      
      
      
      
      .loading-screen {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: url('image1.png') center center no-repeat, #0a0a2e;
  background-size: contain;
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 1;
  pointer-events: auto;
  transition: opacity 0.6s;
}
.loading-screen.hide {
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.6s;
}
.loading-content {
  text-align: center;
}
.spaceship-loader {
  position: relative;
  width: 90px; height: 90px;
  margin: 0 auto 16px;
  animation: loader-float 2.5s ease-in-out infinite;
}
@keyframes loader-float {
  0%, 100% { transform: translateY(0);}
  50% { transform: translateY(-15px);}
}
.spaceship-loader img {
  width: 90px; height: 90px;
  filter: drop-shadow(0 0 25px #00bcd4cc);
}
.flames {
  position: absolute;
  left: 50%; bottom: 0;
  transform: translateX(-50%);
  width: 30px; height: 40px;
  pointer-events: none;
  background: radial-gradient(circle, #ffd70066 60%, transparent 100%);
  z-index: -1;
  animation: flame-flicker 0.18s infinite alternate;
}
@keyframes flame-flicker {
  0% { filter: blur(1px) brightness(1);}
  100% { filter: blur(4px) brightness(1.9);}
}
.loading-bar {
  width: 220px;
  height: 14px;
  background: #222b;
  border-radius: 8px;
  overflow: hidden;
  margin: 24px auto 0;
  border: 2px solid #00bcd4;
  box-shadow: 0 0 12px #00bcd444;
}
.loading-bar-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #ffd700, #00bcd4, #2196f3, #fff);
  border-radius: 8px;
  transition: width 0.5s;
}
.loading-text {
  margin-top: 12px;
  font-size: 1.5rem;
  color: #fff;
  letter-spacing: 2px;
  font-family: 'Orbitron', monospace;
  font-weight: bold;
  text-shadow: 0 0 12px #00bcd4;
}
body.loading {
  overflow: hidden !important;
}
      
      .ship-image {
  width: 100%;
  max-width: 120px;
  animation: float 3s ease-in-out infinite;
  transition: transform 0.3s ease;
}

.ship-image:hover {
  transform: scale(1.1) rotate(2deg);
}

@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

      
      * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
          -webkit-tap-highlight-color: transparent;
          -webkit-touch-callout: none;
          -webkit-user-select: none;
          user-select: none;
      }

      body {
          font-family: 'Orbitron', monospace;
          background: linear-gradient(45deg, #0a0a2e, #16213e, #1a237e, #3f51b5, #0a0a2e);
          background-size: 500% 500%;
          animation: cosmicGradient 15s ease infinite;
          color: #ffffff;
          touch-action: manipulation;
      }

      @keyframes cosmicGradient {
          0%, 100% { background-position: 0% 50%; }
          25% { background-position: 100% 0%; }
          50% { background-position: 100% 100%; }
          75% { background-position: 0% 100%; }
      }

     #gameContainer {
  position: relative;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}

      /* Enhanced Mobile Controls */
      .mobile-controls {
          position: fixed;
          bottom: 0;
          left: 0;
          right: 0;
          height: clamp(180px, 28vh, 220px);
          background: linear-gradient(180deg, transparent, rgba(0, 0, 0, 0.9));
          display: none;
          z-index: 1000;
          pointer-events: none;
          padding: clamp(15px, 3vw, 25px);
      }

      .mobile-controls.active {
          display: block;
      }

      .mobile-joystick {
          position: absolute;
          bottom: clamp(20px, 4vw, 30px);
          left: clamp(20px, 4vw, 30px);
          width: clamp(100px, 18vw, 140px);
          height: clamp(100px, 18vw, 140px);
          background: rgba(0, 188, 212, 0.15);
          border: 3px solid rgba(0, 188, 212, 0.6);
          border-radius: 50%;
          pointer-events: all;
          touch-action: none;
          display: flex;
          align-items: center;
          justify-content: center;
      }

      .mobile-joystick-knob {
          width: clamp(35px, 7vw, 50px);
          height: clamp(35px, 7vw, 50px);
          background: rgba(0, 188, 212, 0.9);
          border: 2px solid #fff;
          border-radius: 50%;
          transition: all 0.1s ease;
          pointer-events: none;
          box-shadow: 0 0 15px rgba(0, 188, 212, 0.5);
      }

      .mobile-action-buttons {
          position: absolute;
          bottom: clamp(20px, 4vw, 30px);
          right: clamp(20px, 4vw, 30px);
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          row-gap: clamp(16px, 4vw, 24px);
          column-gap: clamp(16px, 4vw, 24px);
          pointer-events: all;
      }

      .mobile-action-btn {
          width: clamp(60px, 12vw, 80px);
          height: clamp(60px, 12vw, 80px);
          background: rgba(0, 188, 212, 0.9);
          border: 3px solid #fff;
          border-radius: 50%;
          color: white;
          font-size: clamp(1.2rem, 3vw, 1.6rem);
          font-weight: bold;
          display: flex;
          align-items: center;
          justify-content: center;
          touch-action: manipulation;
          user-select: none;
          transition: all 0.2s ease;
          box-shadow: 0 4px 15px rgba(0, 188, 212, 0.4);
      }

      .mobile-action-btn:active {
          background: rgba(0, 188, 212, 1);
          transform: scale(0.9);
          box-shadow: 0 0 20px rgba(0, 188, 212, 0.8);
      }

      .mobile-action-btn.special {
          background: rgba(255, 215, 0, 0.9);
          border-color: #ffd700;
          box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
      }

      .mobile-action-btn.special:active {
          background: rgba(255, 215, 0, 1);
          box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
      }

      /* Orientation Selector - Enhanced */
      .orientation-selector {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(0, 0, 0, 0.95);
          border-radius: 25px;
          border: 3px solid #00bcd4;
          padding: clamp(2rem, 6vw, 3rem);
          text-align: center;
          z-index: 5000;
          display: none; /* Hidden by default */
          max-width: 90vw;
          backdrop-filter: blur(15px);
      }

      .orientation-selector.active {
          display: block;
      }

      .orientation-buttons {
          display: flex;
          gap: clamp(1rem, 3vw, 1.5rem);
          margin-top: clamp(1.5rem, 4vw, 2rem);
          flex-wrap: wrap;
          justify-content: center;
      }

      .orientation-btn {
          padding: clamp(1rem, 3vw, 1.5rem) clamp(1.5rem, 4vw, 2rem);
          background: linear-gradient(45deg, #00bcd4, #2196f3);
          border: none;
          border-radius: 15px;
          color: white;
          font-family: 'Orbitron', monospace;
          font-weight: 700;
          cursor: pointer;
          transition: all 0.3s ease;
          min-width: clamp(140px, 25vw, 180px);
          font-size: clamp(0.9rem, 2.5vw, 1.1rem);
      }

      .orientation-btn:hover,
      .orientation-btn:active {
          transform: scale(1.05);
          box-shadow: 0 0 20px rgba(0, 188, 212, 0.6);
      }

      /* Enhanced Responsive Styles */
      .portrait-mode .mobile-controls {
          height: clamp(200px, 30vh, 250px);
      }

      .landscape-mode .mobile-controls {
          height: clamp(140px, 22vh, 180px);
      }

      .landscape-mode .mobile-joystick {
          width: clamp(90px, 15vw, 120px);
          height: clamp(90px, 15vw, 120px);
      }

      .landscape-mode .mobile-action-buttons {
          grid-template-columns: repeat(4, 1fr);
          gap: clamp(8px, 2vw, 12px);
      }

      .landscape-mode .mobile-action-btn {
          width: clamp(50px, 10vw, 65px);
          height: clamp(50px, 10vw, 65px);
          font-size: clamp(1rem, 2.5vw, 1.3rem);
      }

   .screen {
  display: none;
  opacity: 0;
  pointer-events: none;
  width: 100%;
  min-height: 100vh;
  height: auto;
  overflow-y: auto;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  padding: clamp(1rem, 3vw, 2rem);
  transition: opacity .7s cubic-bezier(.5,2,.3,1);
}

.screen.active {
  display: flex;
  opacity: 1;
  pointer-events: auto;
}

.menu-content {
  background: none !important;
  box-shadow: none !important;
  border: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
  margin: 0 auto !important;
  max-width: 100vw !important;
  text-align: center !important;
  font-family: 'Press Start 2P', monospace !important;
}

      .game-title {
          font-size: clamp(2.5rem, 10vw, 5rem);
          font-weight: 900;
          background: linear-gradient(45deg, #00bcd4, #2196f3, #3f51b5, #9c27b0, #e91e63, #ff9800);
          background-size: 400% 400%;
          background-clip: text;
          -webkit-background-clip: text;
          -webkit-text-fill-color: transparent;
          animation: stellarText 4s ease infinite;
          margin-bottom: clamp(1rem, 3vw, 1.5rem);
          text-shadow: 0 0 40px rgba(0, 188, 212, 0.6);
          letter-spacing: clamp(1px, 0.5vw, 3px);
      }

      .game-subtitle {
          font-size: clamp(1.2rem, 4vw, 2rem);
          color: #00bcd4;
          margin-bottom: clamp(2rem, 5vw, 3rem);
          text-shadow: 0 0 25px #00bcd4;
          animation: stellarPulse 3s ease infinite;
          font-family: 'Rajdhani', sans-serif;
      }

      @keyframes stellarText {
          0%, 100% { background-position: 0% 50%; }
          50% { background-position: 100% 50%; }
      }

      @keyframes stellarPulse {
          0%, 100% { opacity: 1; transform: scale(1); text-shadow: 0 0 25px #00bcd4; }
          50% { opacity: 0.8; transform: scale(1.05); text-shadow: 0 0 40px #00bcd4, 0 0 60px #2196f3; }
      }

      .menu-buttons {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(min(300px, 85vw), 1fr));
          gap: clamp(1.5rem, 4vw, 2rem);
          margin-bottom: clamp(2rem, 5vw, 3rem);
      }

      .menu-btn {
          padding: clamp(1.2rem, 4vw, 2rem) clamp(2rem, 5vw, 3rem);
          font-size: clamp(1rem, 3.5vw, 1.4rem);
          font-family: 'Orbitron', monospace;
          font-weight: 700;
          border: none;
          border-radius: 20px;
          cursor: pointer;
          transition: all 0.4s ease;
          background: linear-gradient(45deg, rgba(0, 188, 212, 0.2), rgba(33, 150, 243, 0.2));
          color: white;
          border: 3px solid transparent;
          position: relative;
          overflow: hidden;
          text-transform: uppercase;
          touch-action: manipulation;
          min-height: clamp(60px, 12vw, 80px);
      }

      .menu-btn::before {
          content: '';
          position: absolute;
          top: 0;
          left: -100%;
          width: 100%;
          height: 100%;
          background: linear-gradient(90deg, transparent, rgba(0, 188, 212, 0.4), transparent);
          transition: left 0.6s ease;
      }

      .menu-btn:hover::before,
      .menu-btn:active::before {
          left: 100%;
      }

      .menu-btn:hover,
      .menu-btn:active {
          transform: translateY(-4px) scale(1.02);
          box-shadow: 0 8px 25px rgba(0, 188, 212, 0.4);
          border-color: #00bcd4;
      }

      .menu-btn.primary {
          background: linear-gradient(45deg, #00bcd4, #2196f3, #3f51b5, #9c27b0);
          background-size: 300% 300%;
          animation: stellarGradient 3s ease infinite;
          font-size: clamp(1.2rem, 4vw, 1.8rem);
          padding: clamp(1.5rem, 5vw, 2.5rem) clamp(2.5rem, 6vw, 3.5rem);
      }

      .menu-btn.home-btn {
          position: absolute;
          top: clamp(20px, 4vw, 30px);
          left: clamp(20px, 4vw, 30px);
          padding: clamp(1rem, 3vw, 1.5rem) clamp(1.5rem, 4vw, 2.5rem);
          font-size: clamp(0.9rem, 3vw, 1.2rem);
          background: linear-gradient(45deg, #00bcd4, #2196f3);
          border: 2px solid #00bcd4;
          border-radius: 15px;
          z-index: 1000;
      }

      @keyframes stellarGradient {
          0%, 100% { background-position: 0% 50%; }
          50% { background-position: 100% 50%; }
      }

      /* HUD Enhancements */
      .hud {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          height: clamp(120px, 20vh, 160px);
          background: linear-gradient(180deg, rgba(0, 0, 0, 0.95), transparent);
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 0 clamp(1rem, 4vw, 2rem);
          z-index: 10;
          flex-wrap: wrap;
          gap: clamp(0.5rem, 2vw, 1rem);
      }

      .hud-section {
          display: flex;
          gap: clamp(0.8rem, 3vw, 1.5rem);
          align-items: center;
          flex-wrap: wrap;
      }

      .stat-box {
          background: rgba(0, 0, 0, 0.9);
          padding: clamp(0.6rem, 2vw, 1rem);
          border-radius: 15px;
          border: 2px solid;
          text-align: center;
          min-width: clamp(80px, 15vw, 120px);
          backdrop-filter: blur(5px);
      }

      .stat-box.level { border-color: #ffd700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.4); }
      .stat-box.lives { border-color: #00bcd4; box-shadow: 0 0 15px rgba(0, 188, 212, 0.6); }
      .stat-box.energy { border-color: #4caf50; box-shadow: 0 0 15px rgba(76, 175, 80, 0.4); }
      .stat-box.score { border-color: #9c27b0; box-shadow: 0 0 15px rgba(156, 39, 176, 0.4); }

      .stat-label {
          font-size: clamp(0.7rem, 2vw, 0.9rem);
          opacity: 0.9;
          margin-bottom: 0.2rem;
          font-family: 'Rajdhani', sans-serif;
          font-weight: 600;
      }

      .stat-value {
          font-size: clamp(1rem, 3vw, 1.4rem);
          font-weight: 900;
      }

      .health-container {
          display: flex;
          gap: clamp(1rem, 3vw, 1.5rem);
          align-items: center;
          flex-wrap: wrap;
          justify-content: center;
      }

      .health-bar-wrapper {
          text-align: center;
      }

      .health-bar {
          width: clamp(140px, 30vw, 200px);
          height: clamp(16px, 3vh, 20px);
          background: #333;
          border-radius: 10px;
          border: 2px solid;
          overflow: hidden;
      }

      .health-fill {
          height: 100%;
          transition: width 0.3s ease;
      }

      .health-text {
          font-size: clamp(0.7rem, 2vw, 0.9rem);
          margin-top: 0.3rem;
          font-weight: 600;
      }

      #gameCanvas {
  display: block;
  background: radial-gradient(circle at center, #1a237e, #0a0a2e);
  border: 3px solid;
  border-image: linear-gradient(45deg, #00bcd4, #2196f3, #3f51b5, #9c27b0) 1;
  width: 1280px;
  height: 720px;
  margin: 0 auto;
  image-rendering: pixelated; /* per evitare blur se viene ingrandito */
}

      /* Enhanced Stats Display */
      .stats-display {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(clamp(160px, 35vw, 200px), 1fr));
          gap: clamp(1.5rem, 4vw, 2rem);
          padding: clamp(1.5rem, 4vw, 2.5rem);
          background: rgba(0, 188, 212, 0.1);
          border-radius: 20px;
          border: 3px solid #00bcd4;
          box-shadow: 0 0 30px rgba(0, 188, 212, 0.4);
          margin: clamp(1rem, 3vw, 2rem) 0;
      }

      .stat-item {
          text-align: center;
          padding: clamp(1rem, 3vw, 1.5rem);
          background: rgba(0, 0, 0, 0.5);
          border-radius: 15px;
          border: 2px solid rgba(0, 188, 212, 0.3);
          transition: all 0.3s ease;
      }

      .stat-item:hover {
          transform: translateY(-2px);
          box-shadow: 0 5px 20px rgba(0, 188, 212, 0.3);
      }

      .stat-item .stat-value {
          font-size: clamp(1.5rem, 4vw, 2rem);
          font-weight: 900;
          color: #ffd700;
          text-shadow: 0 0 15px #ffd700;
          margin-bottom: 0.5rem;
      }

      /* Level Grid Enhancements */
      .level-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(clamp(200px, 40vw, 250px), 1fr));
          gap: clamp(1.5rem, 4vw, 2rem);
          margin: clamp(2rem, 5vw, 3rem) 0;
          max-height: 65vh;
          overflow-y: auto;
          padding: clamp(1rem, 3vw, 1.5rem);
      }

      .level-card {
          padding: clamp(1.5rem, 4vw, 2rem);
          background: rgba(0, 0, 0, 0.8);
          border-radius: 20px;
          border: 3px solid #00bcd4;
          cursor: pointer;
          transition: all 0.4s ease;
          text-align: center;
          position: relative;
          min-height: clamp(160px, 25vh, 200px);
      }

      .level-card:hover,
      .level-card:active {
          transform: translateY(-5px) scale(1.02);
          box-shadow: 0 10px 30px rgba(0, 188, 212, 0.6);
      }

      .level-card.locked {
          opacity: 0.5;
          cursor: not-allowed;
          border-color: #666;
      }

      .level-number {
          font-size: clamp(2rem, 6vw, 2.5rem);
          font-weight: 900;
          color: #ffd700;
          margin-bottom: clamp(0.5rem, 2vw, 1rem);
          text-shadow: 0 0 20px #ffd700;
      }

      .level-boss {
          font-size: clamp(1.1rem, 3vw, 1.4rem);
          font-weight: 700;
          color: #00bcd4;
          margin-bottom: clamp(0.5rem, 2vw, 1rem);
      }

      .level-difficulty {
          font-size: clamp(1rem, 2.5vw, 1.2rem);
          margin-bottom: clamp(0.5rem, 2vw, 1rem);
          font-weight: 600;
      }

      .level-phases, .level-warning {
          font-size: clamp(0.9rem, 2vw, 1rem);
          opacity: 0.8;
          margin-bottom: 0.4rem;
      }

      /* Mobile-specific optimizations */
      @media (max-width: 768px) {
          .hud {
              height: clamp(100px, 18vh, 130px);
              padding: 0 clamp(0.5rem, 2vw, 1rem);
          }
          
          .hud-section {
              gap: clamp(0.5rem, 2vw, 1rem);
          }
          
          .stat-box {
              min-width: clamp(70px, 12vw, 90px);
              padding: clamp(0.5rem, 2vw, 0.8rem);
          }

          .menu-content {
              padding: clamp(1.5rem, 5vw, 2rem);
              margin: clamp(0.5rem, 2vw, 1rem);
          }

          .health-container {
              gap: clamp(0.5rem, 2vw, 1rem);
          }

          .health-bar {
              width: clamp(120px, 25vw, 160px);
              height: clamp(14px, 2.5vh, 18px);
          }
      }

      @media (max-width: 480px) {
          .game-title {
              font-size: clamp(2rem, 8vw, 3rem);
              letter-spacing: 1px;
          }
          
          .game-subtitle {
              font-size: clamp(1rem, 3vw, 1.3rem);
          }
          
          .menu-btn {
              padding: clamp(1rem, 3vw, 1.5rem) clamp(1.5rem, 4vw, 2rem);
              font-size: clamp(0.9rem, 3vw, 1.1rem);
          }

          .stats-display {
              grid-template-columns: repeat(2, 1fr);
              gap: clamp(1rem, 3vw, 1.5rem);
              padding: clamp(1rem, 3vw, 1.5rem);
          }

          .mobile-joystick {
              width: clamp(90px, 16vw, 110px);
              height: clamp(90px, 16vw, 110px);
          }

          .mobile-action-btn {
              width: clamp(55px, 11vw, 70px);
              height: clamp(55px, 11vw, 70px);
              font-size: clamp(1.1rem, 2.8vw, 1.4rem);
          }
      }

      /* Landscape orientation optimizations */
      @media (orientation: landscape) and (max-height: 500px) {
          .hud {
              height: clamp(80px, 16vh, 100px);
              padding: 0 clamp(0.5rem, 2vw, 1rem);
          }

          .menu-content {
              padding: clamp(1rem, 3vw, 1.5rem);
              max-height: 85vh;
              overflow-y: auto;
          }

          .game-title {
              font-size: clamp(2rem, 6vh, 3rem);
          }

          .game-subtitle {
              font-size: clamp(1rem, 3vh, 1.5rem);
              margin-bottom: clamp(1rem, 3vh, 1.5rem);
          }

          .mobile-controls {
              height: clamp(130px, 25vh, 160px);
          }

          .mobile-joystick {
              width: clamp(80px, 14vw, 100px);
              height: clamp(80px, 14vw, 100px);
              bottom: clamp(15px, 3vh, 25px);
              left: clamp(15px, 3vh, 25px);
          }

          .mobile-action-buttons {
              bottom: clamp(15px, 3vh, 25px);
              right: clamp(15px, 3vh, 25px);
              grid-template-columns: repeat(4, 1fr);
              gap: clamp(8px, 2vw, 12px);
          }

          .mobile-action-btn {
              width: clamp(45px, 9vw, 60px);
              height: clamp(45px, 9vw, 60px);
              font-size: clamp(0.9rem, 2.2vw, 1.2rem);
          }
      }

      /* Touch-specific improvements */
      @media (hover: none) and (pointer: coarse) {
          .menu-btn:hover {
              transform: none;
              box-shadow: none;
              border-color: transparent;
          }
          
          .menu-btn:active {
              transform: scale(0.98);
              box-shadow: 0 4px 15px rgba(0, 188, 212, 0.4);
          }

          .level-card:hover {
              transform: none;
              box-shadow: none;
          }

          .level-card:active {
              transform: scale(0.98);
              box-shadow: 0 4px 15px rgba(0, 188, 212, 0.4);
          }

          .stat-item:hover {
              transform: none;
              box-shadow: none;
          }
      }

      /* Notification System */
      .notification {
          position: fixed;
          top: clamp(20px, 4vw, 30px);
          right: clamp(20px, 4vw, 30px);
          background: linear-gradient(45deg, #00bcd4, #2196f3);
          color: white;
          padding: clamp(1rem, 3vw, 1.5rem) clamp(1.5rem, 4vw, 2rem);
          border-radius: 15px;
          border: 2px solid #00bcd4;
          box-shadow: 0 0 20px rgba(0, 188, 212, 0.6);
          z-index: 3000;
          animation: slideInRight 0.5s ease, fadeOut 0.5s ease 4.5s forwards;
          font-size: clamp(0.9rem, 2.5vw, 1.1rem);
          max-width: 80vw;
          font-weight: 600;
      }

      @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
      }

      @keyframes fadeOut {
          to { opacity: 0; transform: translateX(100%); }
      }

      /* Particle System */
      .particles {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          overflow: hidden;
      }

      .particle {
          position: absolute;
          width: 4px;
          height: 4px;
          background: #00bcd4;
          border-radius: 50%;
          opacity: 0.8;
          animation: stellarParticleFloat 4s linear infinite;
      }

      @keyframes stellarParticleFloat {
          0% {
              transform: translateY(100vh) rotate(0deg);
              opacity: 0;
          }
          10% {
              opacity: 0.8;
          }
          90% {
              opacity: 0.8;
          }
          100% {
              transform: translateY(-10px) rotate(360deg);
              opacity: 0;
          }
      }

      /* Additional Effects */
      .transformation-overlay {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: radial-gradient(circle, transparent 30%, rgba(0, 188, 212, 0.3) 70%);
          opacity: 0;
          transition: opacity 0.5s ease;
          pointer-events: none;
          z-index: 100;
      }

      .transformation-overlay.active {
          opacity: 1;
          animation: transformationPulse 2s ease infinite;
      }

      @keyframes transformationPulse {
          0%, 100% { background: radial-gradient(circle, transparent 30%, rgba(0, 188, 212, 0.3) 70%); }
          50% { background: radial-gradient(circle, transparent 20%, rgba(0, 188, 212, 0.6) 80%); }
      }

      .difficulty-warning {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(0, 188, 212, 0.95);
          color: white;
          padding: clamp(1.5rem, 5vw, 2.5rem) clamp(2rem, 6vw, 3rem);
          border-radius: 20px;
          font-size: clamp(1.5rem, 5vw, 2.5rem);
          font-weight: 900;
          text-align: center;
          opacity: 0;
          animation: warningFlash 0.3s ease infinite alternate;
          z-index: 2000;
          max-width: 90vw;
      }

      @keyframes warningFlash {
          0% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
          100% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
      }

      /* HUD Elements */
      .endless-hud, .speedrun-timer, .phase-indicator {
          font-size: clamp(0.9rem, 2.5vw, 1.2rem);
          padding: clamp(0.8rem, 3vw, 1.2rem);
          background: rgba(0, 0, 0, 0.8);
          border-radius: 12px;
          border: 2px solid #00bcd4;
          position: absolute;
          top: clamp(20px, 4vw, 30px);
          right: clamp(20px, 4vw, 30px);
          z-index: 100;
          font-weight: 600;
      }

      .energy-meter {
          position: absolute;
          bottom: clamp(20px, 4vw, 30px);
          left: 50%;
          transform: translateX(-50%);
          width: clamp(180px, 45vw, 320px);
          height: clamp(14px, 3vh, 18px);
          background: rgba(0, 0, 0, 0.8);
          border: 2px solid #00bcd4;
          border-radius: 10px;
          overflow: hidden;
      }

      .energy-fill {
          height: 100%;
          background: linear-gradient(90deg, #4caf50, #8bc34a, #cddc39, #ffeb3b);
          transition: width 0.3s ease;
      }
      body.portrait-mode #gameCanvas {
          width: 100vw;
          height: 80vh;
      }

      body.landscape-mode #gameCanvas {
          width: 100vw;
          height: 100vh;
      }

      /* Control Adjustment Overlay */
      .control-adjustment-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.95);
          z-index: 7000;
          display: none;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          padding: clamp(1rem, 4vw, 2rem);
          backdrop-filter: blur(15px);
      }

      .control-adjustment-overlay.active {
          display: flex;
      }

      .adjustment-area {
          position: relative;
          width: 90vw;
          height: 80vh;
          max-width: 800px;
          max-height: 600px;
          border: 3px dashed #00bcd4;
          background: rgba(0, 188, 212, 0.05);
          border-radius: 20px;
          overflow: hidden;
      }

      .draggable-control {
          position: absolute;
          cursor: grab;
          touch-action: none; /* Prevent default touch actions */
          z-index: 10;
      }

      .draggable-control.dragging {
          cursor: grabbing;
          box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
          border-color: #ffd700 !important;
      }

      .adjustment-buttons {
          margin-top: 2rem;
          display: flex;
          gap: 1rem;
          flex-wrap: wrap;
          justify-content: center;
          z-index: 20; /* Assicurati che sia sopra i controlli drag */
          position: relative; /* oppure absolute se preferisci */
        }
   
   /* PATCH: Migliora spazio di gioco e controlli su mobile */
@media (pointer: coarse), (max-width: 700px) {
  /* Pulsanti pi√π piccoli */
  .mobile-controls {
    height: clamp(84px, 15vh, 110px) !important;
    padding: clamp(5px, 2vw, 12px) !important;
    background: linear-gradient(180deg, transparent, rgba(0,0,0,0.6)) !important;
  }
  .mobile-joystick {
    width: clamp(44px, 10vw, 60px) !important;
    height: clamp(44px, 10vw, 60px) !important;
    left: clamp(7px, 2vw, 14px) !important;
    bottom: clamp(8px, 2vw, 12px) !important;
    border-width: 2px !important;
  }
  .mobile-joystick-knob {
    width: clamp(17px, 3.5vw, 23px) !important;
    height: clamp(17px, 3.5vw, 23px) !important;
    border-width: 1.5px !important;
  }
  .mobile-action-buttons {
    bottom: clamp(8px, 2vw, 12px) !important;
    right: clamp(7px, 2vw, 14px) !important;
    row-gap: clamp(6px, 2vw, 10px) !important;
    column-gap: clamp(6px, 2vw, 10px) !important;
  }
  .mobile-action-btn {
    width: clamp(28px, 7vw, 36px) !important;
    height: clamp(28px, 7vw, 36px) !important;
    font-size: clamp(0.9rem, 2vw, 1.1rem) !important;
    border-width: 2px !important;
    box-shadow: 0 2px 8px #00bcd444;
  }
  .mobile-action-btn.special {
    font-size: clamp(0.9rem, 2vw, 1.1rem) !important;
  }

  /* HUD e barra superiore pi√π compatte */
  .hud {
    height: clamp(50px, 9vh, 65px) !important;
    padding: 0 clamp(0.2rem, 1vw, 0.5rem) !important;
    gap: 0.3rem !important;
  }
  .stat-box {
    min-width: 38px !important;
    padding: 0.25rem 0.1rem !important;
    font-size: 0.65rem !important;
  }
  .stat-value {
    font-size: 0.92rem !important;
  }
  .health-bar {
    height: 9px !important;
    width: 45px !important;
  }
  .menu-btn.home-btn {
    font-size: 0.75rem !important;
    padding: 0.4rem 0.5rem !important;
    min-width: 20px !important;
  }

  /* Game canvas pi√π ampio e spazioso */
  body.portrait-mode #gameCanvas {
    width: 100vw !important;
    height: 92vh !important;
    max-height: 92vh !important;
    margin-top: 0 !important;
  }
  body.landscape-mode #gameCanvas {
    width: 100vw !important;
    height: 100vh !important;
    max-height: 100vh !important;
    margin-top: 0 !important;
  }

  /* Le barre e pulsanti fuori dal canvas coprono meno spazio */
  .energy-meter {
    height: 8px !important;
    width: clamp(90px, 30vw, 140px) !important;
    bottom: clamp(3px, 1vw, 6px) !important;
  }
}
   
    /* PATCH: landscape ottimizzato per mobile */
  @media (pointer: coarse), (max-width: 900px) {
    body.landscape-mode #gameCanvas {
      width: 100vw !important;
      height: 100vh !important;
      max-height: 100vh !important;
      margin: 0 !important;
    }
    .hud {
      height: 44px !important;
      padding: 0 8px !important;
      font-size: 0.95em !important;
      gap: 0.3em !important;
    }
    .mobile-controls {
      height: 60px !important;
      padding: 6px !important;
      bottom: 0 !important;
      background: linear-gradient(180deg, transparent, rgba(0,0,0,0.45)) !important;
    }
    .mobile-joystick {
      width: 44px !important;
      height: 44px !important;
      left: 8px !important;
      bottom: 8px !important;
    }
    .mobile-action-buttons {
      right: 8px !important;
      bottom: 8px !important;
    }
    .mobile-action-btn {
      width: 32px !important;
      height: 32px !important;
      font-size: 1rem !important;
    }
    /* Nascondi info secondarie per pi√π spazio */
    .stat-box.level,
    .stat-box.energy,
    .stat-box.lives,
    .stat-box.score {
      font-size: 0.88em !important;
    }
    .game-subtitle, .game-title {
      font-size: 1.1em !important;
    }
  }
   
   
  /* PATCH: Joystick mobile pi√π grande ma non esagerato */
@media (pointer: coarse), (max-width: 900px) {
  .mobile-joystick {
    width: clamp(84px, 16vw, 108px) !important;
    height: clamp(84px, 16vw, 108px) !important;
    left: clamp(14px, 4vw, 22px) !important;
    bottom: clamp(14px, 4vw, 22px) !important;
    border-width: 3px !important;
    box-shadow: 0 0 13px #00bcd4cc;
  }
  .mobile-joystick-knob {
    width: clamp(34px, 7vw, 46px) !important;
    height: clamp(34px, 7vw, 46px) !important;
    border-width: 2px !important;
  }
}

@media (max-width: 600px) {
  /* Solo un po' pi√π grande su telefoni piccoli */
  .mobile-joystick {
    width: clamp(90px, 22vw, 120px) !important;
    height: clamp(90px, 22vw, 120px) !important;
    left: clamp(10px, 4vw, 18px) !important;
    bottom: clamp(10px, 4vw, 18px) !important;
  }
  .mobile-joystick-knob {
    width: clamp(38px, 8vw, 54px) !important;
    height: clamp(38px, 8vw, 54px) !important;
  }
}
   
   
   .duel-lobby {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
  background: linear-gradient(135deg, #141e30 80%, #243b55 100%);
  border-radius: 24px; box-shadow: 0 0 80px #00bcd466;
  padding: 2.5rem 2.5rem 2.2rem 2.5rem; text-align: center;
  z-index: 9000; min-width: 380px; max-width: 95vw; min-height: 290px;
  animation: popin 0.7s cubic-bezier(.5,2,.3,1);
}
@keyframes popin { 0%{transform:scale(0.7) translate(-50%,-50%);} 100%{transform:scale(1) translate(-50%,-50%);} }
.duel-header { font-size: 2.1rem; color: #ffd700; font-weight: bold; margin-bottom: 1.3rem; }
.duel-players { display: flex; align-items: center; justify-content: center; gap: 2.7rem; }
.duel-player { display: flex; flex-direction: column; align-items: center; }
.duel-ship { width: 98px; height: 98px; animation: float 2.2s infinite; border-radius: 16px; background: #222; }
@keyframes float { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-12px);} }
.duel-nick { margin-top:0.8rem; color: #00bcd4; font-weight: bold; font-size:1.15rem; }
.duel-vs { font-size: 2.7rem; color: #fff; font-weight: bold; text-shadow: 0 0 25px #ffd700; animation: pulse 1.3s infinite; }
@keyframes pulse { 0%,100%{transform:scale(1);} 50%{transform:scale(1.14);} }
.duel-status { margin-top: 1.5rem; color: #fff; font-size: 1.2rem; min-height: 34px; }
.menu-btn { margin-top: 1.6rem; }
.hidden { display: none !important; }

.duel-countdown {
  position: fixed; top: 40%; left: 50%; transform: translate(-50%,-50%);
  font-size: 5rem; color: #ffd700; text-shadow: 0 0 45px #00bcd4;
  font-family: 'Orbitron', monospace; z-index: 9100;
  background: rgba(0,0,0,0.7); border-radius: 20px; padding: 1.5rem 3rem;
  animation: popin 0.55s cubic-bezier(.5,2,.3,1);
}

.duel-end {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  background: linear-gradient(135deg, #2b2e4a 70%, #ffd700 100%);
  border-radius: 26px; box-shadow: 0 0 60px #ffd70088;
  padding: 2.5rem 3.5rem; text-align: center; z-index: 9200; min-width: 380px;
  animation: popin 0.7s cubic-bezier(.5,2,.3,1);
}
#duelEndTitle { font-size:2.7rem; font-weight:900; margin-bottom:1.2rem;}
#duelEndStats { font-size:1.2rem; margin-bottom:1.7rem; }
@media (max-width: 600px) {
  .duel-lobby, .duel-end { min-width: 94vw; padding: 1.2rem; }
  .duel-ship { width: 64px; height:64px; }
  .duel-header { font-size:1.3rem; }
}
   
   
 @keyframes slideInLeft {0%{transform:translateX(-200px);opacity:0;}100%{transform:translateX(0);opacity:1;}}
@keyframes slideInRight {0%{transform:translateX(200px);opacity:0;}100%{transform:translateX(0);opacity:1;}}
@keyframes pulseVS {0%,100%{transform:scale(1);}50%{transform:scale(1.15);}}
   
   
/* Barra emoji compatta per mobile e tablet - per tutte le modalit√† */
@media (pointer: coarse), (max-width: 700px) {
  #duelEmojiBar {
    bottom: 8px !important;
    padding: 0.15em 0.4em !important; /* Ancora pi√π compatta */
    gap: 6px !important; /* Spazio ridotto tra elementi */
    border-radius: 9px !important; /* Bordi leggermente pi√π piccoli */
    font-size: 0.9rem !important; /* Font pi√π piccolo */
    min-width: unset !important;
    min-height: 32px !important; /* Altezza fissa ridotta */
  }
  
  #duelEmojiBar .menu-btn {
    font-size: 0.85rem !important; /* Bottoni pi√π piccoli */
    padding: 0.25em 0.4em !important; /* Padding ridotto */
    min-width: 26px !important; /* Larghezza minima ridotta */
    border-radius: 6px !important;
  }
  
  /* Emoji pi√π piccole */
  #duelEmojiBar .emoji {
    font-size: 16px !important;
    padding: 0.2em 0.3em !important;
    min-width: 24px !important;
    border-radius: 5px !important;
  }
  
  #duelOpponentHealthBar {
    top: 8px !important;
    left: 8px !important;
    padding: 0.3em 0.6em !important; /* Leggermente pi√π compatta */
    min-width: 100px !important; /* Ridotta */
    font-size: 0.85em !important; /* Font pi√π piccolo */
    border-radius: 7px !important;
  }
  
  /* Nascondi la barra round su mobile per tutte le modalit√† tranne duello */
  #scoreRound {
    display: none !important;
  }
  
  /* Mostra la barra round solo in modalit√† duello (se il body ha classe duel) */
  body.duel-mode #scoreRound,
  body.duel1v1-mode #scoreRound,
  body[data-mode="duel1v1"] #scoreRound {
    display: block !important;
    font-size: 0.85em !important;
    padding: 0.1em 0.25em !important;
  }
  
  #scorePlayer1, #scorePlayer2 {
    font-size: 0.85em !important; /* Font ridotto */
    padding: 0.1em 0.25em !important; /* Padding ridotto */
  }
}

/* Per schermi molto piccoli (smartphone in portrait) */
@media (max-width: 480px) {
  #duelEmojiBar {
    padding: 0.1em 0.3em !important;
    gap: 4px !important;
    font-size: 0.8rem !important;
    min-height: 28px !important;
  }
  
  #duelEmojiBar .menu-btn {
    font-size: 0.75rem !important;
    padding: 0.2em 0.3em !important;
    min-width: 22px !important;
  }
  
  #duelEmojiBar .emoji {
    font-size: 14px !important;
    padding: 0.15em 0.25em !important;
    min-width: 20px !important;
  }
}
   
   /* === RESET BASE === */
*,
*::before,
*::after {
    box-sizing: border-box;
}
body {
    margin: 0;
    padding: 0;
    font-family: 'Press Start 2P', 'Orbitron', monospace, Arial, sans-serif;
    background: linear-gradient(135deg, #0a0a2e, #1a237e 50%, #00bcd4 100%);
    background-size: 400% 400%;
    animation: cosmicGradient 13s ease-in-out infinite;
    color: #fff;
}

/* --- Animazione sfondo --- */
@keyframes cosmicGradient {
    0%,100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}

/* === CANVAS === */
#gameCanvas {
  display: block;
  margin: 0 auto;
  border: 3px solid #00bcd4;
  border-radius: 16px;
  background: radial-gradient(circle at center, #1a237e, #0a0a2e 80%);
  width: 100%;
  height: 100%;
  max-width: 100vw;
  max-height: 100vh;
  image-rendering: pixelated;
  box-shadow: 0 0 32px #00bcd4cc;
}

/* === HUD === */
.hud {
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 84px;
    background: linear-gradient(180deg, rgba(0,0,0,0.92), transparent);
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 10;
    padding: 0 18px;
    gap: 10px;
    flex-wrap: wrap;
}
.stat-box {
    background: rgba(0,0,0,0.90);
    border: 2px solid #00bcd4;
    border-radius: 12px;
    padding: 0.6em 1em;
    min-width: 80px;
    text-align: center;
    box-shadow: 0 0 8px #00bcd455;
}
.stat-box.level { border-color: #ffd700; }
.stat-box.lives { border-color: #00bcd4; }
.stat-box.energy { border-color: #4caf50; }
.stat-box.score { border-color: #9c27b0; }
.stat-label { font-size: 0.9em; color: #00bcd4; font-weight: 700; }
.stat-value { font-size: 1.2em; color: #ffd700; font-weight: bold; text-shadow: 0 0 8px #00bcd4; }

/* === HEALTH BAR === */
.health-bar-wrapper {
    text-align: center;
}
.health-bar {
    width: 160px;
    height: 16px;
    background: #222;
    border-radius: 10px;
    border: 2px solid #00bcd4;
    overflow: hidden;
}
.health-fill {
    height: 100%;
    background: linear-gradient(90deg, #4caf50, #ffd700, #f44336);
    transition: width 0.3s;
}
.health-text {
    font-size: 0.93em;
    font-weight: bold;
    color: #00bcd4;
}

/* === ENERGY BAR === */
.energy-meter {
    position: absolute;
    bottom: 22px;
    left: 50%;
    transform: translateX(-50%);
    width: 240px;
    height: 12px;
    background: rgba(0,0,0,0.82);
    border: 2px solid #00bcd4;
    border-radius: 8px;
    overflow: hidden;
}
.energy-fill {
    height: 100%;
    background: linear-gradient(90deg, #4caf50, #ffd700, #2196f3, #fff);
    transition: width 0.3s;
}

/* === BUTTONS GENERIC === */
.menu-btn, .mobile-action-btn, .orientation-btn {
    font-family: 'Press Start 2P', 'Orbitron', monospace;
    border: 3px solid #00bcd4;
    border-radius: 12px;
    background: linear-gradient(90deg, #00bcd4 0%, #ffe700 100%);
    color: #222;
    padding: 1em 2.2em;
    font-size: 1.08em;
    font-weight: bold;
    box-shadow: 0 4px 0 #ffe700, 0 0 12px #00bcd4;
    margin: 0.5em 0;
    text-shadow: 1px 1px 0 #fff;
    transition: all 0.18s;
    cursor: pointer;
    image-rendering: pixelated;
}
.menu-btn:active, .menu-btn:hover,
.orientation-btn:active, .orientation-btn:hover,
.mobile-action-btn:active, .mobile-action-btn:hover {
    background: linear-gradient(90deg,#00bcd4 0%,#ffd700 100%);
    color: #fff;
    box-shadow: 0 2px 0 #ffe700, 0 0 16px #ffd700;
    transform: scale(0.96);
}

/* === MENU === */
.menu-content {
    background: none !important;
    box-shadow: none !important;
    border: none !important;
    border-radius: 0 !important;
    padding: 0 !important;
    margin: 0 auto;
    max-width: 100vw;
    text-align: center;
    font-family: 'Press Start 2P', monospace !important;
}

/* === GALAXY BACKGROUND === */
.galaxy-bg {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 0;
    pointer-events: none;
    background: url('pixel-art-galaxy.png') repeat !important;
    background-size: 900px 600px !important;
    image-rendering: pixelated !important;
    filter: saturate(1.15) brightness(0.97);
    animation: menuGalaxyMove 16s linear infinite;
}
@keyframes menuGalaxyMove {
    0% { background-position: 0% 0%; }
    100% { background-position: 100% 100%; }
}

/* === TITLE === */
.game-title {
    font-family: 'Press Start 2P', monospace;
    font-size: 3.1em;
    color: #ffe700;
    text-shadow: 0 0 24px #00bcd4, 0 0 60px #ffd700;
    letter-spacing: 0.08em;
    border-bottom: 4px dashed #ffe700;
    padding-bottom: 0.7rem;
    filter: drop-shadow(0 0 12px #ffd700);
}
.game-subtitle {
    font-size: 1.2em;
    color: #00bcd4;
    margin-bottom: 1.5em;
    text-shadow: 0 0 18px #00bcd4, 0 0 16px #fff;
    animation: stellarPulse 2.8s infinite;
    font-family: 'Orbitron', sans-serif;
}
@keyframes stellarPulse {
    0%,100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.85; transform: scale(1.05);}
}

/* === STATISTICS === */
.stats-display {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 1.2em;
    padding: 1em 0;
}
.stat-item {
    background: url('pixel-dither.png') repeat, #222;
    border: 2px solid #ffd700;
    box-shadow: 0 0 16px #ffd70044;
    font-family: 'Press Start 2P', monospace;
    color: #ffe700;
    image-rendering: pixelated;
    border-radius: 12px;
    padding: 1em;
}

/* === MOBILE CONTROLS === */
.mobile-controls {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    height: 85px;
    background: linear-gradient(180deg, transparent, rgba(0,0,0,0.9));
    display: none;
    z-index: 1000;
    pointer-events: none;
    padding: 8px;
}
.mobile-controls.active { display: block; }
.mobile-joystick {
    position: absolute;
    bottom: 16px;
    left: 16px;
    width: 70px;
    height: 70px;
    background: rgba(0, 188, 212, 0.15);
    border: 2px solid #00bcd4;
    border-radius: 50%;
    pointer-events: all;
    display: flex;
    align-items: center;
    justify-content: center;
}
.mobile-joystick-knob {
    width: 26px; height: 26px;
    background: rgba(0,188,212,0.93);
    border: 2px solid #fff;
    border-radius: 50%;
    pointer-events: none;
    box-shadow: 0 0 13px #00bcd4cc;
}
.mobile-action-buttons {
    position: absolute;
    bottom: 15px;
    right: 16px;
    display: flex;
    gap: 10px;
    pointer-events: all;
}
.mobile-action-btn {
    width: 36px; height: 36px;
    background: #00bcd4;
    border: 2px solid #fff;
    border-radius: 50%;
    color: white;
    font-size: 1.1em;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.18s;
    box-shadow: 0 2px 8px #00bcd444;
}
.mobile-action-btn.special {
    background: #ffd700;
    border-color: #ffd700;
    color: #222;
    box-shadow: 0 2px 8px #ffd70044;
}
.mobile-action-btn:active {
    transform: scale(0.93);
    box-shadow: 0 0 14px #ffd70088;
}

/* === PORTRAIT/LANDSCAPE === */
body.portrait-mode #gameCanvas {
    width: 100vw !important;
    height: 82vh !important;
}
body.landscape-mode #gameCanvas {
    width: 100vw !important;
    height: 100vh !important;
}

/* === RESPONSIVE === */
@media (max-width: 900px) {
    .hud { height: 50px; padding: 0 8px; font-size: 0.95em; gap: 0.3em; }
    .stat-box { min-width: 38px; padding: 0.25em 0.1em; font-size: 0.72em; }
    .stat-value { font-size: 1em; }
    .health-bar { height: 9px; width: 45px; }
    .menu-btn.home-btn { font-size: 0.75em; padding: 0.4em 0.5em; }
}
@media (max-width: 600px) {
    .game-title { font-size: 2.1em; }
    .game-subtitle { font-size: 1em; }
    .menu-btn { font-size: 0.97em; padding: 0.8em 1.4em; }
    .health-bar { width: 90px; }
    .stats-display { grid-template-columns: repeat(2,1fr); gap: 0.7em;}
    .mobile-joystick { width: 90px; height: 90px; left: 10px; }
    .mobile-joystick-knob { width: 36px; height: 36px;}
    .mobile-action-btn { width: 32px; height: 32px;}
}

/* === ORIENTATION SELECTOR === */
.orientation-selector {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%,-50%);
    background: rgba(0,0,0,0.97);
    border-radius: 22px;
    border: 3px solid #00bcd4;
    padding: 2em 3em;
    text-align: center;
    z-index: 5000;
    max-width: 90vw;
    backdrop-filter: blur(13px);
}
.orientation-selector.active { display: block; }
.orientation-buttons {
    display: flex;
    gap: 1.3em;
    margin-top: 1.5em;
    flex-wrap: wrap;
    justify-content: center;
}
.orientation-btn {
    padding: 1em 2em;
    background: linear-gradient(45deg, #00bcd4, #2196f3);
    border: none;
    border-radius: 15px;
    color: white;
    font-family: 'Orbitron', monospace;
    font-weight: 700;
    cursor: pointer;
    min-width: 140px;
    font-size: 0.97em;
    box-shadow: 0 0 18px #00bcd4cc;
    transition: all 0.18s;
}

/* === NOTIFICATIONS === */
.notification {
    position: fixed;
    top: 22px;
    right: 22px;
    background: linear-gradient(45deg, #00bcd4, #2196f3);
    color: white;
    padding: 1em 1.5em;
    border-radius: 13px;
    border: 2px solid #00bcd4;
    box-shadow: 0 0 20px #00bcd4;
    z-index: 3000;
    animation: slideInRight 0.5s, fadeOut 0.5s 4.7s forwards;
    font-size: 1em;
    max-width: 80vw;
    font-weight: bold;
}
@keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0;}
    to { transform: translateX(0); opacity: 1;}
}
@keyframes fadeOut {
    to { opacity: 0; transform: translateX(100%);}
}

/* === PARTICLES === */
.particles {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; overflow: hidden;
}
.particle {
    position: absolute;
    width: 4px; height: 4px;
    background: #00bcd4;
    border-radius: 50%;
    opacity: 0.8;
    animation: stellarParticleFloat 4s linear infinite;
}
@keyframes stellarParticleFloat {
    0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
    10%, 90% { opacity: 0.8;}
    100% { transform: translateY(-10px) rotate(360deg); opacity: 0; }
}

/* === BUTTONS: MORE MOBILE/TABLET FINE-TUNING === */
@media (pointer: coarse), (max-width: 800px) {
    .mobile-controls { height: 54px; padding: 5px; }
    .mobile-joystick { width: 54px; height: 54px; left: 8px;}
    .mobile-joystick-knob { width: 18px; height: 18px; }
    .mobile-action-btn { width: 27px; height: 27px; font-size: 0.98em;}
    .menu-btn { min-width: 60px; font-size: 0.95em;}
}

/* === PIXEL ART SHIP === */
.ship-image {
    width: 100%;
    max-width: 120px;
    animation: floatShipMenu 3s ease-in-out infinite;
    transition: transform 0.3s;
}
.ship-image:hover {
    transform: scale(1.08) rotate(2deg);
}
@keyframes floatShipMenu {
    0%,100% { transform: translateY(0);}
    50% { transform: translateY(-13px);}
}

.menu-ship-anim img {
    width: 110px;
    filter: drop-shadow(0 0 32px #ffd700);
}

/* === END === */
   
   
 /* === MIGLIORAMENTI UI DUEL 1V1 === */

/* Lobby pi√π bella */
.duel-lobby {
  background: linear-gradient(135deg, #0a0a2e 0%, #1a237e 40%, #00bcd4 100%) !important;
  border: 3px solid transparent !important;
  border-image: linear-gradient(45deg, #ffd700, #00bcd4, #ff00ff) 1 !important;
  box-shadow: 0 0 100px #00bcd4aa, inset 0 0 50px #00bcd411 !important;
  animation: duelLobbyPulse 3s ease-in-out infinite !important;
}

@keyframes duelLobbyPulse {
  0%, 100% { transform: translate(-50%,-50%) scale(1); }
  50% { transform: translate(-50%,-50%) scale(1.02); }
}

/* Navi animate nella lobby */
.duel-ship {
  filter: drop-shadow(0 0 20px #ffd700) !important;
  animation: shipFloat 2s ease-in-out infinite !important;
}
.duel-ship:nth-child(1) { animation-delay: 0s; }
.duel-ship:nth-child(2) { animation-delay: 1s; }

@keyframes shipFloat {
  0%, 100% { transform: translateY(0) rotate(-2deg); }
  50% { transform: translateY(-15px) rotate(2deg); }
}

/* VS pi√π spettacolare */
.duel-vs {
  background: linear-gradient(45deg, #ffd700, #ff00ff, #00bcd4);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  filter: drop-shadow(0 0 30px #ffd700);
  animation: vsGlow 1s ease-in-out infinite alternate !important;
}

@keyframes vsGlow {
  from { filter: drop-shadow(0 0 30px #ffd700); transform: scale(1); }
  to { filter: drop-shadow(0 0 50px #ff00ff); transform: scale(1.1); }
}

/* Barra vita avversario migliorata */
#duelOpponentHealthBar {
  background: linear-gradient(135deg, rgba(20,20,40,0.95), rgba(40,0,60,0.95)) !important;
  border: 2px solid #ffd700 !important;
  box-shadow: 0 0 40px #ffd70088, inset 0 0 20px #ff00ff22 !important;
  backdrop-filter: blur(10px) !important;
}

#duelOpponentHealthBarFill {
  background: linear-gradient(90deg, #ff0000, #ff6600, #ffaa00, #ffff00, #66ff00, #00ff00) !important;
  box-shadow: 0 0 20px currentColor !important;
  animation: healthShine 2s linear infinite !important;
}

@keyframes healthShine {
  0% { filter: brightness(1); }
  50% { filter: brightness(1.3); }
  100% { filter: brightness(1); }
}

/* Score bar pi√π stilosa */
#duelScoreBar {
  background: linear-gradient(135deg, rgba(30,30,50,0.95), rgba(50,20,80,0.95)) !important;
  border: 2px solid transparent !important;
  border-image: linear-gradient(90deg, #00bcd4, #ffd700, #ff00ff) 1 !important;
  box-shadow: 0 0 50px #00bcd488, inset 0 0 30px #ffd70022 !important;
  font-family: 'Orbitron', monospace !important;
  animation: scoreBarGlow 3s ease-in-out infinite !important;
}

@keyframes scoreBarGlow {
  0%, 100% { box-shadow: 0 0 50px #00bcd488; }
  50% { box-shadow: 0 0 80px #ffd700aa; }
}

/* Emoji bar pi√π moderna */
#duelEmojiBar {
  background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(40,0,60,0.8)) !important;
  border: 2px solid #00bcd4 !important;
  box-shadow: 0 0 30px #00bcd466 !important;
  backdrop-filter: blur(15px) !important;
}

#duelEmojiBar .menu-btn {
  background: linear-gradient(45deg, #00bcd4, #2196f3) !important;
  border: 2px solid #fff !important;
  transition: all 0.3s !important;
}

#duelEmojiBar .menu-btn:hover {
  transform: scale(1.2) rotate(5deg) !important;
  box-shadow: 0 0 25px #ffd700 !important;
}

/* Countdown pi√π epico */
.duel-countdown {
  background: radial-gradient(circle, rgba(255,215,0,0.2), transparent 70%) !important;
  text-shadow: 0 0 80px #ffd700, 0 0 120px #ff00ff !important;
  animation: countdownPulse 1s ease-in-out infinite !important;
}

@keyframes countdownPulse {
  0%, 100% { transform: translate(-50%,-50%) scale(1); }
  50% { transform: translate(-50%,-50%) scale(1.2); }
}

/* Loading screen animata */
#duelLoadingScreen {
  background: radial-gradient(ellipse at center, #1a237e 0%, #0a0a2e 50%, #000 100%) !important;
  animation: loadingBgRotate 10s linear infinite !important;
}

@keyframes loadingBgRotate {
  from { background-position: 0% 0%; }
  to { background-position: 100% 100%; }
}

/* Overlay round migliorato */
#duelRoundOverlay {
  background: radial-gradient(circle, rgba(0,0,0,0.95), rgba(40,0,80,0.95)) !important;
  backdrop-filter: blur(20px) !important;
  border: 3px solid #ffd700 !important;
  box-shadow: 0 0 100px #ffd70088 !important;
}
   
   
   body.in-game #gameContainer {
  height: 100vh;
  overflow: hidden;
}
body:not(.in-game) #gameContainer {
  height: auto !important;
  min-height: 100vh !important;
  overflow: visible !important;
}
   
   
   @media (pointer: coarse), (max-width: 700px) {
  html, body {
    font-size: 18px !important;
    zoom: 1 !important;
    touch-action: manipulation !important;
    overscroll-behavior: none !important;
    -webkit-text-size-adjust: 100% !important;
    background: #000 !important;
  }
  #gameCanvas {
    width: 100vw !important;
    height: 85vh !important;
    max-width: 100vw !important;
    max-height: 85vh !important;
    margin: 0 !important;
    display: block !important;
    border-radius: 0 !important;
    box-shadow: none !important;
  }
  .hud {
    height: 42px !important;
    padding: 0 4px !important;
    font-size: 1em !important;
    gap: 0.2em !important;
    background: linear-gradient(180deg, rgba(0,0,0,0.89), transparent) !important;
  }
  .stat-box {
    min-width: 30px !important;
    padding: 2px 5px !important;
    font-size: 0.75em !important;
  }
  .stat-value {
    font-size: 1em !important;
  }
  .menu-btn, .mobile-action-btn, .orientation-btn, #duelEmojiBar .menu-btn {
    font-size: 1em !important;
    min-width: 24px !important;
    padding: 0.2em 0.4em !important;
    border-radius: 6px !important;
  }
  #duelEmojiBar {
    min-height: 34px !important;
    padding: 0.2em 0.7em !important;
    font-size: 1em !important;
    gap: 7px !important;
  }
}
   
  
.voice-indicator {
  position: absolute;
  top: -40px;
  left: 50%;
  transform: translateX(-50%);
  background: #4caf50;
  color: white;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 12px;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 1; }
}
   

/* ========== PATCH CSS 2v2 ULTRA GRAPHICS ========== */

/* LOBBY 2v2 ANIMATA */
.duel-lobby#duel2v2Lobby {
  background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab) !important;
  background-size: 400% 400% !important;
  animation: gradient2v2 10s ease infinite !important;
  border: 3px solid transparent !important;
  border-image: linear-gradient(45deg, #ffd700, #ff00ff, #00ffff, #ffd700) 1 !important;
  box-shadow: 
    0 0 100px rgba(255, 215, 0, 0.5),
    inset 0 0 50px rgba(255, 0, 255, 0.2),
    0 10px 40px rgba(0, 255, 255, 0.3) !important;
}

@keyframes gradient2v2 {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

/* SHIPS NELLA LOBBY CON GLOW TEAM */
#duel2v2Lobby .duel-ship {
  filter: drop-shadow(0 0 30px #ffd700) brightness(1.2) !important;
  animation: shipFloat2v2 2s ease-in-out infinite !important;
  border: 2px solid rgba(255, 215, 0, 0.5) !important;
  border-radius: 50% !important;
  padding: 5px !important;
  background: radial-gradient(circle, rgba(255,215,0,0.1), transparent) !important;
}

@keyframes shipFloat2v2 {
  0%, 100% { transform: translateY(0) rotate(-5deg) scale(1); }
  50% { transform: translateY(-20px) rotate(5deg) scale(1.1); }
}

/* TEAM 1 BLU NEON */
#duel2v2Lobby div:has(#team1Nick1) {
  background: linear-gradient(135deg, rgba(0,188,212,0.2), rgba(33,150,243,0.2)) !important;
  border-radius: 20px !important;
  padding: 15px !important;
  border: 2px solid #00bcd4 !important;
  box-shadow: 
    0 0 40px rgba(0,188,212,0.5),
    inset 0 0 20px rgba(0,188,212,0.1) !important;
  animation: pulseTeam1 2s infinite !important;
}

@keyframes pulseTeam1 {
  0%, 100% { box-shadow: 0 0 40px rgba(0,188,212,0.5); }
  50% { box-shadow: 0 0 60px rgba(0,188,212,0.8), 0 0 100px rgba(0,188,212,0.3); }
}

/* TEAM 2 ROSSO FUOCO */
#duel2v2Lobby div:has(#team2Nick1) {
  background: linear-gradient(135deg, rgba(244,67,54,0.2), rgba(255,152,0,0.2)) !important;
  border-radius: 20px !important;
  padding: 15px !important;
  border: 2px solid #ff5722 !important;
  box-shadow: 
    0 0 40px rgba(244,67,54,0.5),
    inset 0 0 20px rgba(244,67,54,0.1) !important;
  animation: pulseTeam2 2s infinite !important;
}

@keyframes pulseTeam2 {
  0%, 100% { box-shadow: 0 0 40px rgba(244,67,54,0.5); }
  50% { box-shadow: 0 0 60px rgba(244,67,54,0.8), 0 0 100px rgba(255,152,0,0.3); }
}

/* VS CENTRALE EPICO */
#duel2v2Lobby .duel-vs {
  font-size: 4rem !important;
  background: linear-gradient(45deg, #ffd700, #ff00ff, #00ffff, #ffd700) !important;
  -webkit-background-clip: text !important;
  -webkit-text-fill-color: transparent !important;
  background-clip: text !important;
  animation: vsRotate 3s linear infinite !important;
  filter: drop-shadow(0 0 40px #ffd700) drop-shadow(0 0 60px #ff00ff) !important;
  position: relative !important;
}

@keyframes vsRotate {
  0% { transform: scale(1) rotate(0deg); filter: hue-rotate(0deg); }
  50% { transform: scale(1.2) rotate(180deg); filter: hue-rotate(180deg); }
  100% { transform: scale(1) rotate(360deg); filter: hue-rotate(360deg); }
}

/* NICKNAMES CON EFFETTO NEON */
.duel-nick {
  font-size: 1.3rem !important;
  font-weight: bold !important;
  text-transform: uppercase !important;
  letter-spacing: 2px !important;
  animation: textGlow 2s ease-in-out infinite alternate !important;
}

#team1Nick1, #team1Nick2 {
  color: #00ffff !important;
  text-shadow: 
    0 0 10px #00bcd4,
    0 0 20px #00bcd4,
    0 0 30px #00bcd4,
    0 0 40px #00bcd4 !important;
}

#team2Nick1, #team2Nick2 {
  color: #ff5722 !important;
  text-shadow: 
    0 0 10px #f44336,
    0 0 20px #f44336,
    0 0 30px #f44336,
    0 0 40px #ff5722 !important;
}

@keyframes textGlow {
  from { filter: brightness(1); }
  to { filter: brightness(1.3); }
}

/* STATUS BAR ANIMATA */
#duel2v2Status {
  background: linear-gradient(90deg, #00bcd4, #ffd700, #ff00ff, #00bcd4) !important;
  background-size: 400% 100% !important;
  animation: statusSlide 3s linear infinite !important;
  padding: 15px 30px !important;
  border-radius: 30px !important;
  font-size: 1.2rem !important;
  font-weight: bold !important;
  color: #000 !important;
  text-shadow: 0 0 5px rgba(255,255,255,0.5) !important;
  margin-top: 20px !important;
  box-shadow: 
    0 5px 20px rgba(0,0,0,0.3),
    inset 0 0 20px rgba(255,255,255,0.2) !important;
}

@keyframes statusSlide {
  0% { background-position: 0% 50%; }
  100% { background-position: 100% 50%; }
}

/* BOTTONE CANCEL CON HOVER EFFECT */
#duel2v2CancelBtn {
  background: linear-gradient(45deg, #f44336, #e91e63) !important;
  border: 2px solid #fff !important;
  transition: all 0.3s !important;
  position: relative !important;
  overflow: hidden !important;
}

#duel2v2CancelBtn:before {
  content: '' !important;
  position: absolute !important;
  top: 0 !important;
  left: -100% !important;
  width: 100% !important;
  height: 100% !important;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent) !important;
  transition: left 0.5s !important;
}

#duel2v2CancelBtn:hover:before {
  left: 100% !important;
}

#duel2v2CancelBtn:hover {
  transform: scale(1.1) !important;
  box-shadow: 0 0 30px rgba(244,67,54,0.8) !important;
}

/* ULTIMATE BUTTON STYLE */
#team2v2UltimateBtn {
  background: linear-gradient(45deg, #ffd700, #ff6b6b, #4ecdc4, #45b7d1) !important;
  background-size: 400% 400% !important;
  animation: ultimateGradient 3s ease infinite !important;
  border: 3px solid #fff !important;
  box-shadow: 
    0 0 20px rgba(255,215,0,0.5),
    0 0 40px rgba(255,107,107,0.3),
    0 0 60px rgba(78,205,196,0.2) !important;
  font-size: 1.1rem !important;
  text-transform: uppercase !important;
  letter-spacing: 1px !important;
  transition: all 0.3s !important;
}

@keyframes ultimateGradient {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

#team2v2UltimateBtn:hover {
  transform: scale(1.15) rotate(2deg) !important;
  box-shadow: 
    0 0 40px rgba(255,215,0,0.8),
    0 0 80px rgba(255,107,107,0.5),
    0 0 120px rgba(78,205,196,0.3) !important;
}

/* IN-GAME 2v2 HUD STYLE */
body[data-mode="duel2v2"] .hud,
.screen.active#gameScreen[data-mode="duel2v2"] .hud {
  background: linear-gradient(180deg, 
    rgba(0,0,0,0.9), 
    rgba(75,0,130,0.3), 
    transparent) !important;
  border-bottom: 2px solid rgba(255,215,0,0.5) !important;
  box-shadow: 0 10px 40px rgba(138,43,226,0.3) !important;
}

/* HEALTH BARS TEAM COLORED */
body[data-mode="duel2v2"] .health-bar {
  border-width: 3px !important;
  box-shadow: 0 0 20px currentColor !important;
  position: relative !important;
  overflow: visible !important;
}

body[data-mode="duel2v2"] .health-bar:before {
  content: '' !important;
  position: absolute !important;
  top: -5px !important;
  left: -5px !important;
  right: -5px !important;
  bottom: -5px !important;
  background: linear-gradient(45deg, #00bcd4, #ffd700, #ff00ff, #00bcd4) !important;
  border-radius: 12px !important;
  opacity: 0.5 !important;
  animation: healthGlow 2s linear infinite !important;
  z-index: -1 !important;
}

@keyframes healthGlow {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* PARTICELLE BACKGROUND ANIMATE */
body[data-mode="duel2v2"]:before {
  content: '' !important;
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  width: 100% !important;
  height: 100% !important;
  background-image: 
    radial-gradient(circle at 20% 50%, rgba(0,188,212,0.3) 0%, transparent 50%),
    radial-gradient(circle at 80% 50%, rgba(244,67,54,0.3) 0%, transparent 50%),
    radial-gradient(circle at 50% 20%, rgba(255,215,0,0.2) 0%, transparent 40%) !important;
  animation: particleFloat 20s ease-in-out infinite !important;
  pointer-events: none !important;
  z-index: 0 !important;
}

@keyframes particleFloat {
  0%, 100% { transform: translate(0, 0) scale(1); }
  33% { transform: translate(30px, -30px) scale(1.1); }
  66% { transform: translate(-30px, 30px) scale(0.9); }
}

/* COMBO COUNTER STYLE */
.combo-display {
  position: fixed !important;
  top: 100px !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  font-size: 3rem !important;
  font-weight: bold !important;
  color: #ffd700 !important;
  text-shadow: 
    0 0 20px #ffd700,
    0 0 40px #ff6b6b,
    0 0 60px #4ecdc4 !important;
  animation: comboShake 0.5s infinite !important;
  z-index: 10000 !important;
  pointer-events: none !important;
  font-family: 'Orbitron', monospace !important;
}

@keyframes comboShake {
  0%, 100% { transform: translateX(-50%) scale(1) rotate(0deg); }
  25% { transform: translateX(-48%) scale(1.1) rotate(-2deg); }
  75% { transform: translateX(-52%) scale(1.1) rotate(2deg); }
}

/* VICTORY SCREEN 2v2 */
.duel-end[data-mode="2v2"] {
  background: conic-gradient(from 0deg at 50% 50%, 
    #ffd700, #ff6b6b, #4ecdc4, #45b7d1, #ffd700) !important;
  animation: victoryRotate 10s linear infinite !important;
  border: 5px solid #fff !important;
  box-shadow: 
    0 0 100px rgba(255,215,0,0.8),
    inset 0 0 50px rgba(255,255,255,0.3) !important;
}

@keyframes victoryRotate {
  0% { transform: translate(-50%, -50%) rotate(0deg); }
  100% { transform: translate(-50%, -50%) rotate(360deg); }
}

/* FLOATING MEDALS */
.team-medal {
  position: fixed !important;
  font-size: 5rem !important;
  animation: floatMedal 3s ease-in-out infinite !important;
  z-index: 9999 !important;
  pointer-events: none !important;
}

@keyframes floatMedal {
  0%, 100% { transform: translateY(0) rotate(-5deg); }
  50% { transform: translateY(-30px) rotate(5deg); }
}

/* ========== FINE PATCH CSS 2v2 ========== */

/* ========== PATCH ULTRA 2D PIXEL ART STYLE (MODIFICATA) ========== */

/* RIMUOVI TUTTI GLI EFFETTI 3D E BLUR */
* {
  text-shadow: none !important;
  filter: none !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
}

/* CANVAS FULL PIXEL */
#gameCanvas {
  image-rendering: pixelated !important;
  image-rendering: -moz-crisp-edges !important;
  image-rendering: crisp-edges !important;
  border: 4px solid #00bcd4 !important;
  border-radius: 0 !important;
  box-shadow:
    4px 4px 0 #000,
    8px 8px 0 #00bcd4 !important;
  background: #000 !important;
}

/* FONT SOLO PIXEL */
body, .menu-btn, .stat-box, .game-title, .game-subtitle,
.duel-nick, .stat-label, .stat-value, .health-text {
  font-family: 'Press Start 2P', monospace !important;
  text-rendering: optimizeSpeed !important;
  -webkit-font-smoothing: none !important;
  -moz-osx-font-smoothing: unset !important;
}

/* HUD FLAT PIXEL */
.hud {
  background: #000 !important;
  border-bottom: 4px solid #00bcd4 !important;
  box-shadow: none !important;
}

.stat-box {
  background: #111 !important;
  border: 2px solid !important;
  border-radius: 0 !important;
  box-shadow:
    2px 2px 0 #000 !important;
  text-shadow: none !important;
}

/* HEALTH BAR PIXEL STYLE */
.health-bar, .energy-meter {
  border-radius: 0 !important;
  border: 2px solid #fff !important;
  background: #000 !important;
  box-shadow:
    2px 2px 0 #000 !important;
}

.health-fill, .energy-fill {
  background: repeating-linear-gradient(
    90deg,
    #0f0 0px,
    #0f0 4px,
    #0a0 4px,
    #0a0 8px
  ) !important;
  image-rendering: pixelated !important;
}

/* BOTTONI PIXEL FLAT */
.menu-btn, .mobile-action-btn, .orientation-btn {
  background: #00bcd4 !important;
  border: 2px solid #000 !important;
  border-radius: 0 !important;
  box-shadow:
    2px 2px 0 #000,
    4px 4px 0 #005060 !important;
  text-shadow: none !important;
  text-transform: uppercase !important;
  letter-spacing: 1px !important;
  transition: none !important;
  image-rendering: pixelated !important;
  color: #111 !important;
}

.menu-btn:hover, .menu-btn:active {
  transform: translate(2px, 2px) !important;
  box-shadow:
    0 0 0 #000,
    2px 2px 0 #005060 !important;
  background: #00ffff !important;
  color: #000 !important;
}

/* TITOLO PIXEL - PIU' VISIBILE */
.game-title {
  color: #ffe700 !important;
  font-size: 2.8em !important;
  text-shadow:
    0 0 8px #000,
    2px 2px 0 #000,
    4px 4px 0 #aa9500 !important;
  letter-spacing: 2px !important;
  border-bottom: 4px dashed #ffe700 !important;
  animation: none !important;
  filter: none !important;
  background: none !important;
  -webkit-text-fill-color: #ffe700 !important;
  text-align: center !important;
  margin-top: 32px !important;
}

.game-subtitle {
  color: #00bcd4 !important;
  text-shadow:
    1px 1px 0 #000 !important;
  animation: pixelBlink 1s steps(2) infinite !important;
  text-align: center !important;
  font-size: 1.3em !important;
}

@keyframes pixelBlink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.8; }
}

/* MENU ULTRA FLAT */
.menu-content {
  background: #000 !important;
  border: 4px solid #00bcd4 !important;
  box-shadow:
    4px 4px 0 #000,
    8px 8px 0 #005060 !important;
  padding: 20px !important;
  border-radius: 0 !important;
}

/* STAT ITEMS PIXEL */
.stat-item {
  background: #111 !important;
  border: 2px solid #ffd700 !important;
  border-radius: 0 !important;
  box-shadow:
    2px 2px 0 #000 !important;
  transition: none !important;
}

.stat-item:hover {
  transform: translate(-2px, -2px) !important;
  box-shadow:
    4px 4px 0 #000 !important;
}

/* MOBILE CONTROLS PIXEL */
.mobile-joystick {
  background: #000 !important;
  border: 3px solid #00bcd4 !important;
  border-radius: 0 !important;
  box-shadow:
    3px 3px 0 #000 !important;
}

.mobile-joystick-knob {
  background: #00bcd4 !important;
  border: 2px solid #000 !important;
  border-radius: 0 !important;
  box-shadow: none !important;
}

.mobile-action-btn {
  border-radius: 0 !important;
  background: #00bcd4 !important;
  border: 2px solid #000 !important;
  box-shadow:
    2px 2px 0 #000 !important;
}

.mobile-action-btn:active {
  transform: translate(1px, 1px) !important;
  box-shadow:
    1px 1px 0 #000 !important;
}

/* LOBBY DUEL PIXEL */
.duel-lobby {
  background: #000 !important;
  border: 4px solid #ffd700 !important;
  border-radius: 0 !important;
  box-shadow:
    4px 4px 0 #000,
    8px 8px 0 #aa9500 !important;
  animation: none !important;
}

.duel-ship {
  border: 2px solid #00bcd4 !important;
  border-radius: 0 !important;
  background: #111 !important;
  box-shadow:
    2px 2px 0 #000 !important;
  animation: pixelFloat 2s steps(4) infinite !important;
  filter: none !important;
  image-rendering: pixelated !important;
}

@keyframes pixelFloat {
  0%, 100% { transform: translateY(0); }
  25% { transform: translateY(-4px); }
  50% { transform: translateY(-8px); }
  75% { transform: translateY(-4px); }
}

.duel-vs {
  color: #fff !important;
  text-shadow:
    2px 2px 0 #000,
    4px 4px 0 #ff0000 !important;
  animation: pixelPulse 0.5s steps(2) infinite !important;
  background: none !important;
  -webkit-text-fill-color: #fff !important;
  filter: none !important;
}

@keyframes pixelPulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

/* NOTIFICATION PIXEL */
.notification {
  background: #00bcd4 !important;
  border: 2px solid #000 !important;
  border-radius: 0 !important;
  box-shadow:
    3px 3px 0 #000 !important;
  animation: pixelSlideIn 0.3s steps(8) !important;
  color: #111 !important;
}

@keyframes pixelSlideIn {
  from { transform: translateX(100%); }
  to { transform: translateX(0); }
}

/* ORIENTATION SELECTOR PIXEL */
.orientation-selector {
  background: #000 !important;
  border: 4px solid #00bcd4 !important;
  border-radius: 0 !important;
  box-shadow:
    4px 4px 0 #000,
    8px 8px 0 #005060 !important;
  backdrop-filter: none !important;
}

/* LOADING SCREEN PIXEL - PIU' VISIBILE */
.loading-screen {
  background: #111 !important;
  color: #ffe700 !important;
  z-index: 99999 !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
}

.loading-content {
  color: #ffe700 !important;
  text-align: center !important;
  z-index: 100000 !important;
}

.loading-text {
  color: #ffe700 !important;
  text-shadow: 2px 2px 0 #000 !important;
  font-size: 1.3em !important;
  margin-top: 16px !important;
}

.loading-bar {
  border-radius: 0 !important;
  border: 2px solid #00bcd4 !important;
  background: #222 !important;
}

.loading-bar-fill {
  background: repeating-linear-gradient(
    90deg,
    #00bcd4 0px,
    #00bcd4 8px,
    #ffd700 8px,
    #ffd700 16px
  ) !important;
  animation: pixelLoad 1s steps(8) infinite !important;
  height: 100% !important;
}

@keyframes pixelLoad {
  to { background-position: 16px 0; }
}

/* LEVEL CARDS PIXEL */
.level-card {
  background: #111 !important;
  border: 3px solid #00bcd4 !important;
  border-radius: 0 !important;
  box-shadow:
    3px 3px 0 #000 !important;
  transition: none !important;
}

.level-card:hover {
  transform: translate(-3px, -3px) !important;
  box-shadow:
    6px 6px 0 #000 !important;
  background: #222 !important;
}

.level-card.locked {
  background: #000 !important;
  border-color: #444 !important;
  opacity: 1 !important;
}

/* EMOJI BAR PIXEL */
#duelEmojiBar {
  background: #000 !important;
  border: 2px solid #00bcd4 !important;
  border-radius: 0 !important;
  box-shadow:
    2px 2px 0 #000 !important;
  backdrop-filter: none !important;
}

/* SCORE BAR PIXEL */
#duelScoreBar, #duelOpponentHealthBar {
  background: #000 !important;
  border: 2px solid #ffd700 !important;
  border-radius: 0 !important;
  box-shadow:
    2px 2px 0 #000 !important;
  animation: none !important;
  color: #ffd700 !important;
}

/* COUNTDOWN PIXEL */
.duel-countdown {
  background: #000 !important;
  border: 4px solid #ffd700 !important;
  border-radius: 0 !important;
  color: #ffd700 !important;
  text-shadow:
    3px 3px 0 #000 !important;
  animation: none !important;
}

/* DUEL END SCREEN PIXEL */
.duel-end {
  background: #000 !important;
  border: 4px solid #ffd700 !important;
  border-radius: 0 !important;
  box-shadow:
    4px 4px 0 #000,
    8px 8px 0 #aa9500 !important;
  animation: none !important;
}

/* REMOVE ALL GRADIENTS */
.menu-btn, .stat-box, .health-fill, .energy-fill,
.duel-lobby, #duelScoreBar, #duelEmojiBar,
body, .hud, .menu-content {
  background-image: none !important;
}

/* PIXELATED BACKGROUNDS */
body {
  background: #000 !important;
  background-image:
    repeating-linear-gradient(
      0deg,
      #000 0px,
      #000 2px,
      #111 2px,
      #111 4px
    ),
    repeating-linear-gradient(
      90deg,
      #000 0px,
      #000 2px,
      #111 2px,
      #111 4px
    ) !important;
  color: #ffe700 !important;
}

/* NO ANIMATIONS SMOSSE */
* {
  transition-timing-function: steps(4) !important;
  animation-timing-function: steps(4) !important;
}

/* DISABLE TUTTI I BORDER RADIUS */
*, *::before, *::after {
  border-radius: 0 !important;
}

/* PIXELATED IMAGES */
img, .ship-image, .duel-ship img {
  image-rendering: pixelated !important;
  image-rendering: -moz-crisp-edges !important;
  image-rendering: crisp-edges !important;
  filter: none !important;
}

/* Migliora overlay loading (testo centrato e visibile su ogni device) */
.loading-screen,
.loading-content,
.loading-bar,
.loading-bar-fill,
.loading-text {
  z-index: 99999 !important;
}

/* ========== FINE PATCH ULTRA 2D PIXEL ART (MODIFICATA) ========== */


.game-title {
  color: #ffe700 !important;
  font-size: 2.8em !important;
  text-shadow:
    0 0 8px #000,
    2px 2px 0 #000,
    4px 4px 0 #aa9500 !important;
  letter-spacing: 2px !important;
  border-bottom: 4px dashed #ffe700 !important;
  animation: none !important;
  filter: none !important;
  background: none !important;
  -webkit-text-fill-color: #ffe700 !important;
  text-align: center !important;
  margin-top: 32px !important;
  z-index: 1001 !important;
  position: relative !important;
  display: block !important;
  opacity: 1 !important;
  pointer-events: auto !important;
}


.loading-screen {
  background: rgba(17,17,17,0.85) !important;
  color: #ffe700 !important;
  z-index: 99999 !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
}


/* CERCA #fullscreenAdvicePopup (circa riga 300) e SOSTITUISCI CON: */
#fullscreenAdvicePopup {
  display: none;
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(45deg, #00bcd4, #2196f3);
  color: #fff;
  padding: 1.5rem 2rem;
  border-radius: 20px;
  box-shadow: 0 0 40px #00bcd488;
  z-index: 100000;
  font-size: 1.1rem;
  text-align: center;
  animation: bounceIn 0.5s;
}

@keyframes bounceIn {
  0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
  50% { transform: translateX(-50%) scale(1.05); }
  100% { transform: translateX(-50%) scale(1); opacity: 1; }
}


@media (max-width: 900px), (pointer: coarse) {
  .menu-btn, .menu-btn.home-btn, .menu-btn.primary {
    font-size: 0.85em !important;
    padding: 0.45em 1em !important;
    min-width: 44px !important;
    height: 32px !important;
    border-radius: 7px !important;
    margin: 0.3em 0.1em !important;
  }
  .menu-btn.home-btn {
    position: fixed !important;
    top: 16px !important;
    left: 12px !important;
    font-size: 0.82em !important;
    padding: 0.3em 0.7em !important;
    min-width: 32px !important;
    height: 28px !important;
  }
}


@media (max-width: 900px), (pointer: coarse) {
  .menu-btn.home-btn[style*="RETREAT"], .menu-btn[style*="RETREAT"] {
    position: fixed !important;
    bottom: 18px !important;
    right: 18px !important;
    font-size: 1em !important;
    padding: 0.6em 1.1em !important;
    min-width: 38px !important;
    height: 34px !important;
    z-index: 1200 !important;
  }
}


@media (max-width: 900px) {
    .menu-btn, .menu-btn.primary, .menu-btn.home-btn, .mobile-action-btn {
        font-size: 0.85em !important;
        padding: 0.35em 0.7em !important;
        min-width: 38px !important;
        height: 32px !important;
        border-radius: 7px !important;
        margin: 0.2em 0.1em !important;
    }
    .menu-btn.home-btn {
        position: fixed !important;
        top: 12px !important;
        left: 12px !important;
        font-size: 0.82em !important;
        padding: 0.3em 0.7em !important;
        min-width: 32px !important;
        height: 28px !important;
        z-index: 1200 !important;
    }
    /* Puoi aggiungere anche per il pulsante RETREAT se vuoi in basso a destra */
    .menu-btn[style*="RETREAT"] {
        position: fixed !important;
        bottom: 16px !important;
        right: 16px !important;
        font-size: 0.9em !important;
        padding: 0.6em 1.1em !important;
        min-width: 38px !important;
        height: 34px !important;
        z-index: 1200 !important;
    }
}
@media (max-width: 600px) {
    .menu-btn, .menu-btn.primary, .menu-btn.home-btn, .mobile-action-btn {
        font-size: 0.75em !important;
        padding: 0.28em 0.5em !important;
        min-width: 28px !important;
        height: 24px !important;
        border-radius: 5px !important;
    }
    .menu-btn.home-btn {
        top: 8px !important;
        left: 8px !important;
        font-size: 0.7em !important;
        padding: 0.18em 0.3em !important;
        min-width: 20px !important;
        height: 18px !important;
    }
    .menu-btn[style*="RETREAT"] {
        bottom: 10px !important;
        right: 10px !important;
        font-size: 0.8em !important;
        padding: 0.4em 0.9em !important;
        min-width: 24px !important;
        height: 24px !important;
    }
}



/* PATCH RETREAT MINI E IN BASSO A DESTRA - SOLO ICONA, TESTO NASCOSTO */
@media (max-width: 900px), (pointer: coarse) {
  .menu-btn.home-btn[style*="RETREAT"],
  .menu-btn[style*="RETREAT"],
  .menu-btn.home-btn.retreat-btn,
  .menu-btn.retreat-btn {
    position: fixed !important;
    bottom: 18px !important;
    right: 18px !important;
    font-size: 0.67em !important;
    padding: 0.22em 0.55em !important;
    min-width: 18px !important;
    height: 19px !important;
    border-radius: 5px !important;
    z-index: 1300 !important;
    opacity: 0.97 !important;
    box-shadow: 0 0 12px #00bcd499 !important;
    background: #ffd700 !important;
    color: transparent !important; /* Nasconde il testo */
    border: 2px solid #222 !important;
    line-height: 1 !important;
    margin: 0 !important;
    text-indent: -9999px !important; /* Nasconde testo anche se rimane renderizzato */
    overflow: hidden !important;
  }
  /* Mostra solo icona üè† sul pulsante RETREAT */
  .menu-btn[style*="RETREAT"]::after,
  .menu-btn.home-btn[style*="RETREAT"]::after,
  .menu-btn.home-btn.retreat-btn::after,
  .menu-btn.retreat-btn::after {
    content: "üè†";
    font-size: 1.1em;
    margin-left: 0;
    vertical-align: middle;
    display: inline-block;
    color: #222;
    text-indent: 0;
    position: static;
  }
}
/* Ancora pi√π piccolo su telefoni piccoli */
@media (max-width: 600px) {
  .menu-btn.home-btn[style*="RETREAT"],
  .menu-btn[style*="RETREAT"],
  .menu-btn.home-btn.retreat-btn,
  .menu-btn.retreat-btn {
    bottom: 8px !important;
    right: 8px !important;
    font-size: 0.6em !important;
    padding: 0.14em 0.38em !important;
    min-width: 13px !important;
    height: 15px !important;
    border-radius: 3px !important;
  }
}


#mobileHome {
  background: #ffd700 !important;
  color: #222 !important;
  border: 2px solid #222 !important;
  font-size: 1.1em !important;
  box-shadow: 0 0 10px #ffd70099 !important;
}
@media (min-width: 900px) {
  #mobileHome { display: none !important; }
}

</style>
</head>
<body>
  
  <div id="loadingScreen" class="loading-screen active">
  <div class="loading-content">
    <div class="spaceship-loader">
      <img src="navicella1.png" id="loaderShip" />
      <div class="flames"></div>
    </div>
    <div class="loading-text" id="loadingText">LOADING GALAXY...</div>
    <div class="loading-bar">
      <div class="loading-bar-fill" id="loadingBarFill"></div>
    </div>
  </div>
</div>
  
    <div class="particles" id="particles"></div>
  
  <div id="notificationContainer"></div>
  
  <!-- Orientation Selector -->
  <div class="orientation-selector" id="orientationSelector">
      <h2 style="color: #00bcd4; margin-bottom: 1rem; font-size: clamp(1.5rem, 5vw, 2rem);">Choose Your Battle Orientation</h2>
      <p style="margin-bottom: 1rem; font-size: clamp(1rem, 3vw, 1.2rem);">Select how you want to play:</p>
      <div class="orientation-buttons">
          <button class="orientation-btn" onclick="setOrientation('portrait')">
              üì± Portrait<br><small>Vertical Gameplay</small>
          </button>
          <button class="orientation-btn" onclick="setOrientation('landscape')">
              üì∫ Landscape<br><small>Horizontal Gameplay</small>
          </button>
          <button class="orientation-btn" onclick="setOrientation('auto')">
              üîÑ Auto<br><small>Device Rotation</small>
          </button>
      </div>
  </div>
  
  
          <!-- Control Adjustment Overlay -->
  <div class="control-adjustment-overlay" id="controlAdjustmentOverlay">
      <h2 style="color: #ffd700; margin-bottom: 1rem; font-size: clamp(1.8rem, 6vw, 2.5rem);">Adjust Controls</h2>
      <p style="margin-bottom: 1.5rem; font-size: clamp(1rem, 3vw, 1.2rem);">Drag and drop the controls to your preferred positions.</p>
      <div class="adjustment-area" id="adjustmentArea">
          <!-- Draggable controls will be appended here by JS -->
      </div>
      <div class="adjustment-buttons">
          <button class="menu-btn primary" onclick="saveControlLayout()">‚úÖ SAVE LAYOUT</button>
          <button class="menu-btn" onclick="cancelControlAdjustment()">‚ùå CANCEL</button>
      </div>
  </div>
  

 <!-- üëá QUI puoi incollare il GO overlay, PRIMA del gameContainer -->
  <div id="duelGoOverlay" style="
    display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
    font-size:5rem;color:#ffd700;font-family:'Orbitron',sans-serif;
    text-shadow:0 0 40px #00bcd4,0 0 80px #ffd700;z-index:9500;">
    GO!
  </div>


  <!-- Overlay animato round duello 1v1 -->
<div id="duelRoundOverlay" style="
  display:none;
  position:fixed;
  top:50%; left:50%;
  transform:translate(-50%,-50%);
  background:rgba(0,0,0,0.90);
  border-radius:24px;
  box-shadow:0 0 80px #ffd700aa;
  padding:2.2rem 3.2rem;
  text-align:center;
  z-index:9500;
  min-width:260px;
  font-family:'Orbitron',monospace;
  font-size:2.1rem;
">
  <div id="duelRoundOverlayMsg"></div>
  <div id="duelNextRoundCountdown" style="margin-top:12px;font-size:1.2rem;color:#ffd700;"></div>
</div>
  
  
  
  <div id="gameContainer">
  <!-- Main Menu Screen -->
  <div class="screen active" id="mainMenu">
    <!-- Galaxy background -->
    <div class="galaxy-bg"></div>
    <!-- Animated spaceship -->
    <div class="menu-ship-anim">
      <img src="navicella1.png" alt="Spaceship" />
    </div>
    <div class="menu-content">
      <h1 class="game-title">STELLAR GUARDIAN</h1>
      <p class="game-subtitle">COSMIC DEFENSE FORCE - Protect the Galaxy</p>
      <p style="color:#ffd700; font-size:1.1rem; margin-bottom:1.5rem; text-shadow: 0 0 8px #00bcd4;">
        üîî  For a better experience activate the <strong>fullscreen</strong>. Without it, it could lag!
      </p>
    <div id="nicknameBox" style="margin:1.2rem 0; padding:0.8rem 1rem; background:rgba(0,188,212,0.07); border-radius:12px; box-shadow:0 0 18px #00bcd455;">
  <label for="nicknameInput" style="color:#00bcd4;font-weight:bold;">Nickname:</label>
  <input id="nicknameInput" type="text" maxlength="15" style="padding:0.5rem;border-radius:8px;margin-left:0.5rem;">
  <button class="menu-btn primary" onclick="savePlayerName()">Save</button>
  <!-- ELO Display DENTRO nicknameBox -->
  <div id="eloDisplay" style="
    color:#ffd700;
    font-size:1.15rem;
    font-weight:bold;
    margin-top:10px;
    border:2px solid #ffd700;
    background:rgba(0,0,0,0.41);
    border-radius:11px;
    box-shadow:0 0 12px #ffd70055;
    padding:0.4em 1.1em;
    display:inline-block;
  ">
    <span style="margin-right:6px;">üèÖ</span>
    ELO: <span id="eloPoints">1000</span>
  </div>
</div>


<!-- COPYRIGHT FOOTER -->
<div style="color:#9c27b0; font-size:0.95rem; margin:12px 0 0 0; text-align:center;">
  ¬© 2024-2025 Luka. All rights reserved.
</div>


<div class="stat-item">
    <div class="stat-value" id="coinCount">0</div>
    <div>Coins</div>
</div>
              
 <!-- Mobile Speed Control -->
                <div id="mobileSpeedControl" style="margin:2rem 0; display:none;">
                    <h3 style="color:#00bcd4; margin-bottom:0.8rem;">Mobile Ship Speed</h3>
                    <input type="range" id="mobileSpeedSlider" min="0.4" max="1.2" step="0.02" value="0.7" style="width: 220px;">
                    <span id="mobileSpeedValue" style="color:#ffd700;font-weight:bold;margin-left:10px;">0.70x</span>
                    <div style="font-size:0.95rem; margin-top:0.7em; color:#bbb;">
                        Adjust for your comfort. Default: 0.7x (slower = easier to control)
                    </div>
                </div>

<!-- PULSANTE GIOCA ORA: mettilo all'inizio di .menu-buttons -->
<button id="playNowBtn" class="menu-btn primary"
  style="font-size:1.4rem; padding:1.4rem 2.5rem;"
  onclick="window.startGameAudio(); startFirstMission();">
  üöÄ GIOCA ORA
</button>

<audio id="musicaGioco" src="musica.mp3" loop></audio>        
                  <div class="menu-buttons">
                  <button class="menu-btn" onclick="showScreen('shop')">üõí SHOP</button>
                  <button class="menu-btn" onclick="showScreen('levelSelect')">üìã SELECT MISSION</button>
                  <button class="menu-btn" onclick="startChaosMode()">üí• TOTAL CHAOS</button>
                  <button class="menu-btn primary" id="pulsanteMusica">üéµ Music ON</button>                  <button class="menu-btn" onclick="changePlayerName()">üë§ Change nickname</button>
                  <button class="menu-btn" onclick="showScreen('inventoryScreen')">üõ∏ SPACESHIP INVENTORY</button>
                  <button class="menu-btn" onclick="showGlobalLeaderboard()">üåç GLOBAL LEADERBOARD</button>
                  <button class="menu-btn primary" onclick="showCoopLobby()">üåê Raid Co-op Online</button>
                  <button class="menu-btn" onclick="window.open('https://site-stellarguardian999.onrender.com','_blank')">üåê Sito Ufficiale</button>
                  <button class="menu-btn" onclick="showDailyChallengeMenu()">üåü DAILY CHALLENGE</button>
                  <button class="menu-btn" onclick="showLocalLeaderboard()">üåü LOCAL LEADERBOARD</button>
                  <button class="menu-btn" onclick="showScreen('skillTree')">‚≠ê UPGRADES</button>
                  <button class="menu-btn" onclick="showScreen('achievements')">üèÜ ACHIEVEMENTS</button>
                  <button class="menu-btn" onclick="showScreen('stats')">üìä STATISTICS</button>
                  <button class="menu-btn" onclick="showScreen('controls')">üéÆ CONTROLS</button>
                  <button class="menu-btn" onclick="showOrientationSelector()">üì± ORIENTATION</button>
                  <button class="menu-btn primary" onclick="startDuelQueue()">‚öîÔ∏è 1v1 DUELS</button>
                  <!-- Apri il Mobile Customization menu -->
                  <button class="menu-btn" onclick="showScreen('mobileCustomizationMenu')">üì± MOBILE SETTINGS</button>
                  <button class="menu-btn primary" onclick="startDuel2v2Queue()">‚öîÔ∏è 2v2 TEAM DUELS</button>
                  <button class="menu-btn" onclick="showTeam2v2Leaderboard()">üèÜ 2v2 TEAM LEADERBOARD</button>
                  <button class="menu-btn primary" onclick="showClickReactionMenu()">‚ö° CLICK REACTION (ONLINE DESKTOP ONLY)</button>
                  
                  
                  
                  <div style="margin-bottom:1.2em;">
  <label for="duelBotDifficultySelect" style="color:#00bcd4;font-weight:bold;margin-right:7px;">Bot Difficulty:</label>
  <select id="duelBotDifficultySelect" class="menu-btn" style="padding:0.4em 1.3em; font-size:1.1em; width:auto;">
    <option value="easy">Easy üòÉ</option>
    <option value="normal" selected>Normal üòà</option>
    <option value="hard">Hard üëæ</option>
    <option value="insane">Insane üíÄ</option>
  </select>
</div>
                                      <button class="menu-btn" onclick="startDuelAIBoss()">ü§ñ 1v1 DUEL vs BOT(beta)</button>
</div>
              
              <div class="stats-display">
                  <div class="stat-item">
                      <div class="stat-value" id="totalEnemiesDefeated">0</div>
                      <div>Enemies Defeated</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="highestLevel">1</div>
                      <div>Highest Level</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="totalScore">0</div>
                      <div>Best Score</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="skillPoints">0</div>
                      <div>Upgrade Points</div>
                
                    </div>
              </div>
          </div>
      </div>

      <!-- Skill Tree Screen -->
      <div class="screen" id="skillTree">
          <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
          <div class="menu-content">
              <h2 class="game-subtitle">Ship Upgrades</h2>
              <p style="margin-bottom: 2rem; color: #00bcd4; font-size: clamp(1.1rem, 3vw, 1.4rem);">Upgrade Points Available: <span id="availableSkillPoints">0</span></p>
              
              <div class="stats-display" id="skillTreeGrid">
              </div>
          </div>
      </div>

      <!-- Achievements Screen -->
      <div class="screen" id="achievements">
          <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
          <div class="menu-content">
              <h2 class="game-subtitle">Achievements</h2>
              
              <div class="stats-display" id="achievementsList">
              </div>
          </div>
      </div>

 
      <!-- SHOP SCREEN -->
<div class="screen" id="shop">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">Galactic Shop</h2>
    <div class="stats-display">
      <div class="stat-item">
        <div class="stat-value">+1 Ship</div>
        <div>Cost: <span style="color:#ffd700;">20</span> Coins</div>
        <button class="menu-btn" onclick="buyShip()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Energy Refill</div>
        <div>Cost: <span style="color:#00bcd4;">10</span> Coins</div>
        <button class="menu-btn" onclick="buyEnergyRefill()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Temporary Shield</div>
        <div>Cost: <span style="color:#2196f3;">15</span> Coins</div>
        <button class="menu-btn" onclick="buyTemporaryShield()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Bullet Upgrade</div>
        <div>Cost: <span style="color:#e91e63;">30</span> Coins</div>
        <button class="menu-btn" onclick="buyBulletUpgrade()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Auto-Fire Module</div>
        <div>Cost: <span style="color:#4caf50;">25</span> Coins</div>
        <button class="menu-btn" onclick="buyAutoFire()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Special Attack Charge</div>
        <div>Cost: <span style="color:#9c27b0;">20</span> Coins</div>
        <button class="menu-btn" onclick="buySpecialAttack()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Random Power-Up</div>
        <div>Cost: <span style="color:#ffd700;">12</span> Coins</div>
        <button class="menu-btn" onclick="buyRandomPowerUp()">Buy</button>
      </div>
      <div class="stat-item">
        <div class="stat-value">Unlock Ship Skin</div>
        <div>Cost: <span style="color:#00bcd4;">50</span> Coins</div>
        <button class="menu-btn" onclick="buyShipSkin()">Buy</button>
      </div>
      <!-- ... puoi aggiungere altri item shop qui ... -->
    </div>
  </div>
</div>
<!-- FINE SHOP -->

<!-- DAILY CHALLENGE SCREEN -->
<div class="screen" id="dailyChallengeScreen">
  <div class="menu-content">
    <h2>üåü Daily Challenge</h2>
    <div id="dailyChallengeDesc" style="margin-bottom:1.5rem;"></div>
    <button class="menu-btn primary" id="dailyChallengeStartBtn">Start</button>
    <button class="menu-btn" id="dailyChallengeBackBtn">Back</button>
    <div style="margin-top:2rem;">
      <h3>Daily Leaderboard</h3>
      <div id="dailyLeaderboardList">Loading...</div>
    </div>
  </div>
</div>
<!-- FINE DAILY CHALLENGE -->

      
  <!-- Local Leaderboard Screen (spostata!) -->
<div class="screen" id="localLeaderboardScreen">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">Local Leaderboard</h2>
    <div id="localLeaderboardList">Loading...</div>
    <button class="menu-btn" onclick="showScreen('mainMenu')">Back</button>
  </div>
</div>


<div class="screen" id="globalLeaderboardScreen">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">Global Leaderboard</h2>
    <div id="globalLeaderboardList">Loading...</div>
    <button class="menu-btn" onclick="showGlobalLeaderboard()">Update global ranking</button>
    <button class="menu-btn" onclick="showScreen('mainMenu')">Back</button>
  </div>
</div>


<!-- Ship Inventory Screen -->
<div class="screen" id="inventoryScreen">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">Select Your Spaceship</h2>
    <div class="level-grid" id="shipInventory"></div>
  </div>
</div>
   

<!-- Level Select Screen -->
      <div class="screen" id="levelSelect">
          <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
          <div class="menu-content">
              <h2 class="game-subtitle">Select Mission</h2>
              
              <div class="level-grid" id="levelGrid">
              </div>
          </div>
      </div>

      <!-- Statistics Screen -->
      <div class="screen" id="stats">
          <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
          <div class="menu-content">
              <h2 class="game-subtitle">Mission Statistics</h2>
              
              <div class="stats-display">
                  <div class="stat-item">
                      <div class="stat-value" id="statTotalEnemies">0</div>
                      <div>Total Enemies Defeated</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="statHighestLevel">1</div>
                      <div>Highest Level Reached</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="statBestScore">0</div>
                      <div>Highest Score</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="statTotalDeaths">0</div>
                      <div>Ships Lost</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="statSurvivalTime">0</div>
                      <div>Longest Survival (sec)</div>
                  </div>
                  <div class="stat-item">
                      <div class="stat-value" id="statAchievements">0</div>
                      <div>Achievements Unlocked</div>
                  </div>
              </div>
              
              <div class="menu-buttons" style="margin-top: 2rem;">
                  <button class="menu-btn" onclick="resetStats()" style="background: linear-gradient(45deg, #f44336, #e91e63);">
                      üóëÔ∏è RESET DATA
                  </button>
              </div>
          </div>
      </div>

      <!-- Controls Screen -->
      <div class="screen" id="controls">
          <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
          <div class="menu-content">
              <h2 class="game-subtitle">Controls</h2>
              
              <div style="text-align: left; max-width: 700px; margin: 0 auto;">
                  <div style="margin-bottom: 2rem; padding: 1.5rem; background: rgba(0,0,0,0.5); border-radius: 15px;">
                      <h3 style="color: #00bcd4; margin-bottom: 1rem; font-size: clamp(1.2rem, 3vw, 1.5rem);">Basic Controls</h3>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>W A S D</strong> or <strong>Arrow Keys</strong> - Move ship</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Mouse</strong> or <strong>Touch</strong> - Aim and fire</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Space</strong> or <strong>Click</strong> - Fire weapons</p>
                      <p style="font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Right Click</strong> or <strong>Hold</strong> - Charged shot</p>
                  </div>
                  
                  <div style="margin-bottom: 2rem; padding: 1.5rem; background: rgba(0,0,0,0.5); border-radius: 15px;">
                      <h3 style="color: #2196f3; margin-bottom: 1rem; font-size: clamp(1.2rem, 3vw, 1.5rem);">Special Abilities</h3>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>E</strong> or <strong>üõ°Ô∏è Button</strong> - Energy shield</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>F</strong> or <strong>‚è∞ Button</strong> - Slow time</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>C</strong> or <strong>‚ö° Button</strong> - Special attack</p>
                      <p style="font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Shift</strong> - Precision mode</p>
                  </div>
                  
                  <div style="margin-bottom: 2rem; padding: 1.5rem; background: rgba(0,0,0,0.5); border-radius: 15px;">
                      <h3 style="color: #4caf50; margin-bottom: 1rem; font-size: clamp(1.2rem, 3vw, 1.5rem);">Mobile Controls</h3>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Virtual Joystick</strong> - Move ship</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Tap Screen</strong> - Aim and fire</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Action Buttons</strong> - Special abilities</p>
                      <p style="font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Double Tap</strong> - Emergency actions</p>
                  </div>
                  
                  <div style="margin-bottom: 2rem; padding: 1.5rem; background: rgba(0,0,0,0.5); border-radius: 15px;">
                      <h3 style="color: #ff9800; margin-bottom: 1rem; font-size: clamp(1.2rem, 3vw, 1.5rem);">Orientation Modes</h3>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Portrait</strong> - Vertical gameplay, optimized for phones</p>
                      <p style="margin-bottom: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Landscape</strong> - Horizontal gameplay, optimized for tablets</p>
                      <p style="font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Auto</strong> - Adapts to device rotation</p>
                  </div>
              </div>
              <div class="menu-buttons" style="margin-top: 2rem;">
                  
              </div>
          </div>
      </div>

      <!-- Game Screen -->
      <div class="screen" id="gameScreen">
          <div class="speedrun-timer" id="speedrunTimer" style="display: none;">
              <div>TIME: <span id="speedrunTime">00:00</span></div>
          </div>
          
          <div class="endless-hud" id="endlessHud" style="display: none;">
              <div class="wave-counter">WAVE <span id="currentWave">1</span></div>
              <div class="difficulty-multiplier">x<span id="difficultyMultiplier">1.0</span></div>
          </div>
          
          <div class="hud">
              <div class="hud-section">
                  <div class="stat-box level">
                      <div class="stat-label">LEVEL</div>
                      <div class="stat-value" id="currentLevel">1</div>
                  </div>
                  <div class="stat-box lives">
                      <div class="stat-label">SHIPS</div>
                      <div class="stat-value" id="playerLives">1</div>
                  </div>
                  <div class="stat-box energy">
                      <div class="stat-label">ENERGY</div>
                      <div class="stat-value" id="playerEnergy">100</div>
                  </div>
              </div>
              
              <div class="health-container">
                  <div class="health-bar-wrapper">
                      <div style="font-size: clamp(0.8rem, 2.5vw, 1rem); margin-bottom: 0.3rem; font-weight: 600;">GUARDIAN</div>
                      <div class="health-bar" style="border-color: #00bcd4;">
                          <div id="playerHealthFill" class="health-fill" style="background: linear-gradient(90deg, #4caf50, #8bc34a, #cddc39); width: 100%;"></div>
                      </div>
                      <div id="playerHealthText" class="health-text">500 / 500</div>
                  </div>
                  
                  <div class="health-bar-wrapper">
                      <div style="font-size: clamp(0.8rem, 2.5vw, 1rem); margin-bottom: 0.3rem; font-weight: 600;">ENEMY</div>
                      <div class="health-bar" style="border-color: #f44336;">
                          <div id="enemyHealthFill" class="health-fill" style="background: linear-gradient(90deg, #f44336, #e91e63, #9c27b0); width: 100%;"></div>
                      </div>
                      <div id="enemyHealthText" class="health-text">1000 / 1000</div>
                  </div>
              </div>
              
              <div class="hud-section">
                  <div class="stat-box score">
                      <div class="stat-label">SCORE</div>
                      <div class="stat-value" id="playerScore">0</div>
                  </div>
                 
              </div>
          </div>
          
          <div class="energy-meter" id="energyMeter">
              <div class="energy-fill" id="energyFill"></div>
          </div>
          
         
          
          <div class="transformation-overlay" id="transformationOverlay"></div>
          
         <canvas id="gameCanvas" width="960" height="540" style="width:100vw;height:100vh;"></canvas>      

          
      

         
         
        


        </div>

      <!-- Game Over Screen -->
<div class="screen" id="gameOver">
    <div style="text-align: center; padding: clamp(2rem, 6vw, 3rem); background: rgba(0, 0, 0, 0.95); border-radius: 25px; border: 4px solid #f44336; box-shadow: 0 0 60px rgba(244, 67, 54, 0.8); margin: 1rem; max-width: 90vw;">
        <h2 style="font-size: clamp(2.5rem, 10vw, 4.5rem); color: #f44336; margin-bottom: 2rem; text-shadow: 0 0 30px #f44336;">MISSION FAILED</h2>
        <div style="margin: 2rem 0;">
            <div style="font-size: clamp(1.3rem, 5vw, 1.8rem); margin-bottom: 1rem;">Score: <span id="finalScore" style="color: #ffd700;">0</span></div>
            <div style="font-size: clamp(1.1rem, 4vw, 1.4rem); margin-bottom: 1rem;">Level Reached: <span id="finalLevel" style="color: #00bcd4;">1</span></div>
            <div style="font-size: clamp(1.1rem, 4vw, 1.4rem); margin-bottom: 1rem;">Survival Time: <span id="finalTime" style="color: #4caf50;">0s</span></div>
            <div style="font-size: clamp(1.1rem, 4vw, 1.4rem);">Upgrade Points Earned: <span id="earnedSkillPoints" style="color: #9c27b0;">0</span></div>
        </div>
        
        <div class="menu-buttons">
            <button class="menu-btn primary" onclick="restartGame()">üîÑ RETRY MISSION</button>
            <button class="menu-btn" onclick="showScreen('skillTree')">‚≠ê UPGRADE SHIP</button>
            <button class="menu-btn" onclick="showScreen('levelSelect')">üìã SELECT MISSION</button>
            <button class="menu-btn" onclick="showScreen('mainMenu')">üè† MAIN MENU</button>
        </div>

        <!-- Pulsanti Condividi Social -->
        <div id="shareButtonsGameOver" style="margin-top:1.5rem; display:flex; gap:12px; flex-wrap:wrap; justify-content:center;">
            <button class="menu-btn" onclick="shareScore()">üîó Share your record!</button>
            <button class="menu-btn" onclick="copyScoreLink()">üìã Copy link</button>
        </div>
    </div>
</div>

     <!-- Victory Screen -->
<div class="screen" id="victory">
    <div style="text-align: center; padding: clamp(2rem, 6vw, 3rem); background: rgba(0, 0, 0, 0.95); border-radius: 25px; border: 4px solid #ffd700; box-shadow: 0 0 60px rgba(255, 215, 0, 0.8); margin: 1rem; max-width: 90vw;">
        <h2 style="font-size: clamp(2.5rem, 10vw, 4.5rem); color: #ffd700; margin-bottom: 2rem; text-shadow: 0 0 30px #ffd700;">GALAXY SAVED!</h2>
        <div style="margin: 2rem 0;">
            <div style="font-size: clamp(1.8rem, 6vw, 2.5rem); margin-bottom: 1rem; color: #ffd700;">üëë STELLAR GUARDIAN SUPREME! üëë</div>
            <div style="font-size: clamp(1.3rem, 5vw, 1.8rem); margin-bottom: 1rem;">Final Score: <span id="victoryScore" style="color: #ffd700;">0</span></div>
            <div style="font-size: clamp(1.1rem, 4vw, 1.4rem); margin-bottom: 1rem;">All 20 Levels Completed!</div>
            <div style="font-size: clamp(1.1rem, 4vw, 1.4rem); margin-bottom: 1rem;">Total Time: <span id="victoryTime" style="color: #4caf50;">0s</span></div>
            <div style="font-size: clamp(1.1rem, 4vw, 1.4rem);">You are the ultimate space defender!</div>
        </div>
        
               <div class="menu-buttons">
            <button class="menu-btn primary" onclick="showScreen('levelSelect')">üöÄ PLAY AGAIN</button>
            <button class="menu-btn" onclick="showScreen('achievements')">üèÜ VIEW ACHIEVEMENTS</button>
            <button class="menu-btn" onclick="showScreen('stats')">üìä VIEW STATS</button>
            <button class="menu-btn" onclick="showScreen('mainMenu')">üè† MAIN MENU</button>
        </div>

        <!-- Pulsanti Condividi Social -->
        <div id="shareButtonsVictory" style="margin-top:1.5rem; display:flex; gap:12px; flex-wrap:wrap; justify-content:center;">
            <button class="menu-btn" onclick="shareScore()">üîó Share your record!</button>
            <button class="menu-btn" onclick="copyScoreLink()">üìã Copy link</button>
        </div>
    </div>
</div>

<div class="screen" id="coopLobby">
  <div class="menu-content">
    <h2 class="game-subtitle">Raid Co-op - Wait for other players...</h2>
    <div id="coopPlayersList">Loading...</div>
    
    
    
  
  
    
    
    <!-- Nuovo contenitore bottoni -->
    <div class="lobby-buttons">
      <button class="menu-btn" onclick="showCoopLeaderboard()">ü§ù CO-OP LEADERBOARD</button>
      <button class="menu-btn primary" onclick="startCoopRaid()">Start (test host)</button>
      <button class="menu-btn" onclick="showScreen('mainMenu')">Back</button>
      <!-- <button class="menu-btn" id="dailyBtn" onclick="toggleDaily()">üé§ Voice Chat (Daily.co)</button> -->

    </div>
  </div>
</div>

 
  
  
  <div class="screen" id="coopLeaderboardScreen">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">Co-op Teams Leaderboard</h2>
    <div id="coopLeaderboardList">Loading...</div>
    <button class="menu-btn" onclick="showCoopLeaderboard()">Update</button>
    <button class="menu-btn" onclick="showScreen('mainMenu')">Back</button>
  </div>
</div>
  
  
<div class="mobile-action-btn special" id="mobileSlowTime" style="display:none;">‚è∞</div>  
  
  
  <!-- Contenitore iframe Daily.co nascosto di default -->
<div id="dailyContainer" style="display:none; position:fixed; bottom:80px; right:20px; width:360px; height:300px; z-index:10000; box-shadow:0 0 16px #000; border-radius:12px; background:#000;">
  <iframe id="dailyFrame"
    src=""
    allow="camera; microphone; fullscreen; display-capture"
    style="width:100%; height:100%; border:0; border-radius:10px;"></iframe>
  <button onclick="toggleDaily()" style="position:absolute;top:4px;right:4px;z-index:10001;background:#ffd700;border:none;border-radius:8px;padding:2px 8px;cursor:pointer;">‚ùå</button>
</div>
  
  
  <!-- DUEL LOBBY MODAL -->
<div id="duelLobby" class="duel-lobby hidden">
  <div class="duel-header">‚öîÔ∏è 1v1 DUELS</div>
  <div class="duel-players">
    <div class="duel-player">
      <img id="duelShip1" class="duel-ship" src="navicella1.png"/>
      <div id="duelNick1" class="duel-nick">You</div>
    </div>
    <div class="duel-vs">VS</div>
    <div class="duel-player">
      <img id="duelShip2" class="duel-ship" src="navicella2.png"/>
      <div id="duelNick2" class="duel-nick">Searching...</div>
    </div>
  </div>
  <div id="duelStatus" class="duel-status">Looking for opponent...</div>
  
  <div id="duelSpecialAbilitySelector" style="margin-top:1.2em;">
  <label style="color:#00bcd4;font-weight:bold;">Special Ability:</label>
  <select id="duelSpecialAbilitySelect" class="menu-btn" style="margin-left:8px;">
    <option value="stun">Stun</option>
    <option value="heal">Heal</option>
    <option value="teleport">Teleport</option>
    <option value="double">Double Shot</option>
    <option value="shield">Shield</option>
  </select>
</div>
<div id="duelAbilityDesc" style="color:#ffd700; font-size:0.96em; margin-top:4px;"></div>
  
  <button class="menu-btn" id="duelCancelBtn">Cancel</button>
</div>


<!-- PATCH: LOADING SCREEN DUEL 1v1 ANIMATA -->
<div id="duelLoadingScreen" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:100000;background:radial-gradient(ellipse at center,#222 50%,#0a0a2e 100%);align-items:center;justify-content:center;flex-direction:column;">
  <div style="display:flex;gap:80px;align-items:center;">
    <div style="text-align:center;animation:slideInLeft 0.8s;">
      <img id="duelLoadShip1" src="navicella1.png" style="width:110px;filter:drop-shadow(0 0 22px #00bcd4);" />
      <div id="duelLoadNick1" style="color:#00bcd4;font-weight:bold;font-size:1.3em;">Player1</div>
      <div id="duelLoadElo1" style="color:#ffd700;font-size:1.1em;">ü•á Gold</div>
    </div>
    <div style="font-size:3.5em;color:#fff;font-weight:bold;text-shadow:0 0 20px #ffd700;animation:pulseVS 1s infinite;">VS</div>
    <div style="text-align:center;animation:slideInRight 0.8s;">
      <img id="duelLoadShip2" src="navicella2.png" style="width:110px;filter:drop-shadow(0 0 22px #ffd700);" />
      <div id="duelLoadNick2" style="color:#ffd700;font-weight:bold;font-size:1.3em;">Player2</div>
      <div id="duelLoadElo2" style="color:#00bcd4;font-size:1.1em;">üí† Platinum</div>
    </div>
  </div>
  <div id="duelLoadingCountdown" style="font-size:2.8em;color:#ffd700;margin-top:2.5rem;">3</div>
  <div id="duelLoadingPhrase" style="color:#fff;margin-top:1.3rem;">Prepare for cosmic battle!</div>
</div>


<!-- ARENA 1v1 OVERLAY -->
<div id="duelCountdown" class="duel-countdown hidden"></div>
<div id="duelEndScreen" class="duel-end hidden">
  <div id="duelEndTitle"></div>
  <div id="duelEndStats"></div>
  <button class="menu-btn" id="duelRematchBtn">Rematch</button>
  <button class="menu-btn" id="duelLobbyBtn">Back to Lobby</button>
</div>
  
  
  <div id="fullscreenAdvicePopup" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(45deg,#00bcd4,#2196f3);color:#fff;padding:2.1rem 2.8rem;border-radius:24px;box-shadow:0 0 40px #00bcd488;z-index:100000;font-size:1.25rem;text-align:center;">
  <div style="font-size:2.1rem;margin-bottom:0.4em;">üñ•Ô∏è</div>
  <b>Click to enable Fullscreen<br>for the best experience!</b>
  <div style="margin-top:1.1em;">
    <button onclick="enableFullscreenFromPopup()" style="margin-top:0.5em;padding:0.7em 1.3em;border-radius:15px;background:#ffd700;color:#222;font-weight:bold;border:none;cursor:pointer;">Go Fullscreen</button>
    <button onclick="document.getElementById('fullscreenAdvicePopup').style.display='none'" style="margin-top:0.5em;padding:0.7em 1.3em;border-radius:15px;background:#444;color:#fff;font-weight:bold;border:none;cursor:pointer;margin-left:0.7em;">Close</button>
  </div>
</div>
  
  
<!-- MOBILE CUSTOMIZATION MENU -->
<div class="screen" id="mobileCustomizationMenu">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">üì± Mobile Controls & Ship Settings</h2>

    <!-- Pulsanti selezionabili -->
    <div>
      <h3 style="color:#00bcd4;">Select Action Buttons</h3>
      <button class="menu-btn" onclick="toggleMobileButton('shoot')">üî´ Shoot</button>
      <button class="menu-btn" onclick="toggleMobileButton('special')">üí• Special</button>
      <button class="menu-btn" onclick="toggleMobileButton('shield')">üõ° Shield</button>
    </div>

    <!-- Velocit√† navicella -->
    <div style="margin-top:1.5rem;">
      <h3 style="color:#00bcd4;">Ship Speed</h3>
      <input type="range" id="shipSpeedSlider" min="0.4" max="1.2" step="0.02" value="0.7" 
             oninput="updateShipSpeedValue(this.value)">
      <span id="shipSpeedValue" style="color:#ffd700;font-weight:bold;">0.70x</span>
    </div>

    <!-- Dimensione e colore pulsanti -->
    <div style="margin-top:1.5rem;">
      <h3 style="color:#00bcd4;">Button Size</h3>
      <input type="range" id="buttonSizeSlider" min="40" max="120" value="80" oninput="updateButtonSize(this.value)">
      <span id="buttonSizeValue" style="color:#ffd700;font-weight:bold;">80px</span>

      <h3 style="color:#00bcd4; margin-top:1rem;">Button Color</h3>
      <input type="color" id="buttonColorPicker" value="#00bcd4" onchange="updateButtonColor(this.value)">
    </div>

    <!-- Nickname sopra navicella -->
    <div style="margin-top:1.5rem;">
      <h3 style="color:#00bcd4;">Nickname Display</h3>
      <input type="text" id="nicknameAboveShip" placeholder="Your nickname">
      <input type="color" id="nicknameColorPicker" value="#ffffff" onchange="updateNicknameColor(this.value)">
    </div>

    <!-- Pulsanti Salva/Reset -->
    <div style="margin-top:1.5rem; display:flex; gap:12px; justify-content:center;">
      <button class="menu-btn primary" onclick="applyMobileSettings()">üíæ APPLICA</button>
      <button class="menu-btn" onclick="resetMobileSettings()">‚ôªÔ∏è RESET</button>

    
    </div>
  </div> <!-- fine .menu-content -->
</div> <!-- fine #mobileCustomizationMenu -->

<!-- CONTROLLI MOBILE (joystick + pulsanti) -->
<div class="mobile-controls" id="mobileControls">
  <div class="mobile-joystick" id="mobileJoystick">
    <div class="mobile-joystick-knob" id="mobileJoystickKnob"></div>
  </div>
  <div class="mobile-action-buttons" id="mobileActionButtons">
    <div class="mobile-action-btn" id="mobileShoot">üî´</div>
    <div class="mobile-action-btn" id="mobileShield">üõ°Ô∏è</div>
    <div class="mobile-action-btn" id="mobileSpecial">üí•</div>
      <div class="mobile-action-btn" id="mobileHome" onclick="showScreen('mainMenu')">üè†</div>
  </div>
</div>


  <div class="screen" id="duelLeaderboardScreen">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">1v1 Duel Leaderboard</h2>
    <div id="duelLeaderboardList">Loading...</div>
    <button class="menu-btn" onclick="showDuelLeaderboard()">Update</button>
    <button class="menu-btn" onclick="showScreen('mainMenu')">Back</button>
  </div>
</div>
  
  
  <!-- Pulsante per spettatore + room input -->
<div style="text-align:center; margin-top:24px;">
  <input type="text" id="spectatorRoomInput" placeholder="Room ID" style="padding:5px 10px; border-radius:7px; border:1px solid #00bcd4; width:120px;">
  <button id="spectatorBtn" style="background:#00bcd4; color:#222; border:none; font-weight:bold; border-radius:7px; padding:7px 20px; margin-left:8px; font-size:1.1rem; cursor:pointer;">
    üëÅÔ∏è Spettatore 1v1
  </button>
</div>

<!-- Overlay spettatore (info partita live) -->
<div id="spectatorPanel"
     style="display:none; position:fixed; top:20px; right:20px; z-index:9999; background:rgba(20,30,40,0.91); color:#fff; padding:1em 1.3em; border-radius:16px; min-width:220px; box-shadow:0 0 18px #00bcd488; font-family:monospace;">
  <div style="font-weight:bold; color:#ffd700; margin-bottom:6px;">üëÅÔ∏è Modalit√† Spettatore</div>
  <div id="spectatorPlayers"></div>
  <div id="spectatorCount" style="margin-top:8px;color:#00bcd4;"></div>
  <button onclick="document.getElementById('spectatorPanel').style.display='none';" style="background:#ffd700; color:#222; border:none; border-radius:8px; padding:2px 13px; margin-top:10px; cursor:pointer;">Chiudi</button>
</div>
  
  
  <div class="screen" id="team2v2LeaderboardScreen">
  <button class="menu-btn home-btn" onclick="showScreen('mainMenu')">üè† HOME</button>
  <div class="menu-content">
    <h2 class="game-subtitle">2v2 Team Leaderboard</h2>
    <div id="team2v2LeaderboardList">Loading...</div>
    <button class="menu-btn" onclick="showTeam2v2Leaderboard()">Update</button>
    <button class="menu-btn" onclick="showScreen('mainMenu')">Back</button>
  </div>
</div>
  
  
  <div id="clickReactionLobby" class="duel-lobby hidden">
  <div class="duel-header">‚ö° Click Reaction Online</div>
  <div>
    <label>Nickname: <input id="cr_nick" type="text" maxlength="15" /></label>
  </div>
  <div style="margin:10px 0;">
    <button class="menu-btn" onclick="createClickReactionRoom()">üÜï Crea Stanza</button>
    <input id="cr_roomcode" type="text" maxlength="6" placeholder="Codice stanza" style="width:85px;" />
    <button class="menu-btn" onclick="joinClickReactionRoom()">üîë Entra</button>
  </div>
  <div id="cr_lobby_status" style="margin:10px 0;color:#00bcd4;"></div>
  <div id="cr_lobby_players"></div>
<button class="menu-btn" onclick="hideClickReactionLobby()">Chiudi</button>
<button class="menu-btn" onclick="goToHomeFromClickReaction()">üè† HOME</button>
<button>vai qui per giocare su mobile: https://minigames-ecux.onrender.com</button>

</div>
  
  
  <div id="clickReactionGame" class="duel-lobby hidden" style="background:rgba(0,0,0,0.98); text-align:center;">
  <div id="cr_game_status" style="font-size:1.4rem;color:#ffd700;margin-bottom:10px;">Preparati...</div>
  <div id="cr_reaction_target" style="position:relative;width:100%;height:260px;"></div>
  <div id="cr_scores"></div>
  <button class="menu-btn" onclick="leaveClickReactionRoom()">Esci</button>
</div>
  
  
  <script>
       
      const SERVER_URL = "https://stellarguardian114.onrender.com"; // <-- metti il TUO vero URL qui
      const SERVER_2V2_URL = "https://stellarguardian2v2.onrender.com";         // 2v2
      const SERVER_CLICK_URL = "https://minigames-ecux2.onrender.com";           // Click Reaction
      
      
      
      // === CLICK REACTION MINI GAME ===
let cr_socket = null, cr_room = null, cr_players = [], cr_state = "idle", cr_me = null, cr_targetTimeout = null;

       
       let firstGameAdShown = false;
      
     let teamComboMeter = 0;
let lastTeamShot = {};
     
     
       function showAd() {
  if (isDevEnv()) {
    console.log("DEV: showAd saltata (nessuna pubblicit√† in locale).");
    return;
  }
  
  // Prova GameDistribution
  if (typeof gdsdk !== 'undefined' && typeof gdsdk.showAd === 'function') {
    gdsdk.showAd();
    console.log('Ad GameDistribution chiamata!');
    return;
  }
  
  // Altrimenti usa GameMonetize
  if (typeof sdk !== 'undefined' && typeof sdk.showBanner === 'function') {
    sdk.showBanner();
    console.log('Banner GameMonetize chiamato!');
    return;
  }
  
  console.log('No ad function available, continuing without ad!');
}
       
       
 // Aggiungi dopo le variabili co-op esistenti
let coopRole = null; // 'tank', 'healer', 'dps', 'support'
let coopTeamBuffs = {
  tankBonus: 0,
  healBonus: 0,
  damageBonus: 0
};       



function selectCoopRole(role) {
  coopRole = role;
  socket.emit('selectRole', { role });
  
  // Applica bonus del ruolo
  switch(role) {
    case 'tank':
      gameState.player.maxHealth += 200;
      gameState.player.health += 200;
      showNotification("üõ°Ô∏è Tank: +200 HP, attiri i proiettili!", "info");
      break;
    case 'healer':
      gameState.player.healPower = true;
      showNotification("üíö Healer: Puoi curare gli alleati!", "info");
      break;
    case 'dps':
      gameState.player.damageMultiplier = 1.5;
      showNotification("‚öîÔ∏è DPS: +50% danni!", "info");
      break;
    case 'support':
      gameState.player.supportAura = true;
      showNotification("‚ú® Support: Buff di squadra attivi!", "info");
      break;
  }
}




const BOSS_IMAGES_BY_DIFFICULTY = {
  "Medium": "sabaa1.png",
  "Hard": "sabaa2.png",
  "Very Hard": "sabaa3.png",
  "Extreme": "sabaa4.png",
  "Nightmare": "sabaa5.png",
  "Impossible": "sabaa5.png",
  "LEGENDARY": "sabaa6.png" // Se vuoi riutilizzare o aggiungere un altro
};
       
       
 function getBossImageForDifficulty(difficulty) {
  if (difficulty === "Easy") {
    return "alien-enemy2.png";
  }
  return BOSS_IMAGES_BY_DIFFICULTY[difficulty] || "sabaa1.png";
}   
      


  // Event listener per i bottoni della Daily Challenge
  const dailyStartBtn = document.getElementById('dailyChallengeStartBtn');
  const dailyBackBtn = document.getElementById('dailyChallengeBackBtn');
  if (dailyStartBtn) dailyStartBtn.onclick = startDailyChallenge;
  if (dailyBackBtn) dailyBackBtn.onclick = () => showScreen('mainMenu');
;

  // Puoi chiamare showAd() dove preferisci, ad esempio:
  // function gameOver() { ... showAd(); ... }
     
      const missileSprite = new Image();
missileSprite.src = "missili.png"; // usa il nome del tuo file
      
const POWERUP_IMAGES = {
  heal: 'powerup-heal-removebg-preview.png',
  shield: 'powerup-shield-removebg-preview.png',
  damage: 'powerup-ammo-removebg-preview.png',
  special: 'powerup-energy-removebg-preview.png'
};
const POWERUP_SPRITES = {};
for (let key in POWERUP_IMAGES) {
  POWERUP_SPRITES[key] = new Image();
  POWERUP_SPRITES[key].src = POWERUP_IMAGES[key];
}



// Game State Management


           

      let gameState = {
    
    
    
    currentScreen: 'mainMenu',
    currentLevel: 1,
    gameRunning: false,
    gamePaused: false,
    gameMode: 'campaign',
    endlessWave: 1,
    speedrunStartTime: 0,
    isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
    orientation: 'auto',
    touchControls: {
        joystick: { 
            active: false, 
            startX: 0, 
            startY: 0, 
            currentX: 0, 
            currentY: 0,
            touchId: null
        },
        shooting: false,
        lastTouchTime: 0
    },
    coins: 0, // <--- AGGIUNTO QUI
    player: {
        elo: 1000, // <--- AGGIUNGI QUESTA RIGA QUI!

      x: 0,
        y: 0,
        health: 100,
        maxHealth: 100,
        lives: 1,
        score: 0,
        energy: 100,
        maxEnergy: 100,
        reviveCount: 0,
        maxRevives: 1,
        skills: {},
        emergencyShields: 1,
        slowTimeEnergy: 100,
        precisionMode: false,
        invulnerabilityFrames: 0,
        angle: 0,
        specialCooldown: 0,
        specialReady: false,
        isSpectator: false // <--- INCOLLA QUI!
},
    enemy: null,
    bullets: [],
    enemyBullets: [],
    particles: [],
    powerUpItems: [],
    currentPhase: 0,
    bulletHellIntensity: 0,
    adaptiveDifficulty: 1.0,
    keys: {},
    mouse: {x: 0, y: 0},
    levelStartTime: 0,
    totalSurvivalTime: 0,
    skillPoints: 0,
    achievements: [],
    slowTimeActive: false,
    timeScale: 1,
    screenShake: 0,
    transformationActive: false,
     controlLayout: {
        joystick: { left: '20px', bottom: '30px' },
        buttons: { right: '20px', bottom: '30px' }
    },
    globalSpeed: 0.50 // <--- QUI, dentro la graffa, senza virgola!
};
window.gameState = gameState;
      
      
      let duelBot = {
  x: 1000,
  y: 90,
  health: 500,
  maxHealth: 500,
  energy: 100,
  maxEnergy: 100,
  cooldownShoot: 0,
  cooldownDodge: 0,
  target: { x: 0, y: 0 }
};
      
let botDirection = 1; // <-- QUI!


// Level Data Configuration
      const LEVEL_DATA = [
          {level: 1, enemy: "Scout Drone", difficulty: "Easy", health: 800, phases: 1, speed: 2, attackPatterns: ['basic'], bulletSpeed: 3, bulletCount: 1},
          {level: 2, enemy: "Fighter Ship", difficulty: "Easy", health: 1200, phases: 2, speed: 2.5, attackPatterns: ['basic', 'spread'], bulletSpeed: 3.5, bulletCount: 1.2},
          {level: 3, enemy: "Assault Cruiser", difficulty: "Medium", health: 1600, phases: 2, speed: 3, attackPatterns: ['basic', 'spread', 'tracking'], bulletSpeed: 4, bulletCount: 1.4},
          {level: 4, enemy: "Battle Frigate", difficulty: "Medium", health: 2200, phases: 3, speed: 3.2, attackPatterns: ['basic', 'spread', 'tracking'], bulletSpeed: 4.2, bulletCount: 1.6},
          {level: 5, enemy: "Heavy Destroyer", difficulty: "Medium", health: 2800, phases: 3, speed: 3.5, attackPatterns: ['basic', 'spread', 'tracking', 'wave'], bulletSpeed: 4.5, bulletCount: 1.8},
          {level: 6, enemy: "Plasma Gunship", difficulty: "Hard", health: 3500, phases: 3, speed: 3.8, attackPatterns: ['basic', 'spread', 'tracking', 'wave'], bulletSpeed: 4.8, bulletCount: 2},
          {level: 7, enemy: "Ion Battleship", difficulty: "Hard", health: 4200, phases: 4, speed: 4, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser'], bulletSpeed: 5, bulletCount: 2.2},
          {level: 8, enemy: "Quantum Dreadnought", difficulty: "Hard", health: 5000, phases: 4, speed: 4.2, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser'], bulletSpeed: 5.2, bulletCount: 2.4},
          {level: 9, enemy: "Void Carrier", difficulty: "Very Hard", health: 6000, phases: 4, speed: 4.5, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm'], bulletSpeed: 5.5, bulletCount: 2.6},
          {level: 10, enemy: "Dark Matter Titan", difficulty: "Very Hard", health: 7200, phases: 5, speed: 4.8, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm'], bulletSpeed: 5.8, bulletCount: 2.8},
          {level: 11, enemy: "Cosmic Leviathan", difficulty: "Extreme", health: 8500, phases: 5, speed: 5, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral'], bulletSpeed: 6, bulletCount: 3},
          {level: 12, enemy: "Stellar Behemoth", difficulty: "Extreme", health: 10000, phases: 5, speed: 5.2, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral'], bulletSpeed: 6.2, bulletCount: 3.2},
          {level: 13, enemy: "Galactic Overlord", difficulty: "Extreme", health: 12000, phases: 6, speed: 5.5, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos'], bulletSpeed: 6.5, bulletCount: 3.4},
          {level: 14, enemy: "Dimension Ripper", difficulty: "Nightmare", health: 14000, phases: 6, speed: 5.8, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos'], bulletSpeed: 6.8, bulletCount: 3.6},
          {level: 15, enemy: "Reality Shredder", difficulty: "Nightmare", health: 16500, phases: 6, speed: 6, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos', 'ultimate'], bulletSpeed: 7, bulletCount: 3.8},
          {level: 16, enemy: "Cosmic Horror", difficulty: "Nightmare", health: 12000, phases: 6, speed: 5.0, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos', 'ultimate'], bulletSpeed: 6.0, bulletCount: 3.1},
          {level: 17, enemy: "Universal Destroyer", difficulty: "Impossible", health: 14500, phases: 6, speed: 5.3, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos', 'ultimate'], bulletSpeed: 6.2, bulletCount: 3.2},
          {level: 18, enemy: "Infinity Engine", difficulty: "Impossible", health: 17000, phases: 7, speed: 5.5, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos', 'ultimate'], bulletSpeed: 6.5, bulletCount: 3.3},
          {level: 19, enemy: "Omnipotent Core", difficulty: "Impossible", health: 20000, phases: 7, speed: 5.8, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos', 'ultimate'], bulletSpeed: 7.0, bulletCount: 3.5},
          {level: 20, enemy: "The Final Guardian", difficulty: "LEGENDARY", health: 25000, phases: 8, speed: 6.0, attackPatterns: ['basic', 'spread', 'tracking', 'wave', 'laser', 'swarm', 'spiral', 'chaos', 'ultimate'], bulletSpeed: 7.3, bulletCount: 3.8},
      ];
      
          // Upgrade Skills Configuration
      const UPGRADE_SKILLS = {
          'hull_armor': {name: 'Hull Armor', icon: 'üõ°Ô∏è', cost: 10, description: '+50 max health, +25% damage resistance', maxLevel: 3},
          'energy_core': {name: 'Energy Core', icon: '‚ö°', cost: 8, description: '+25% energy regen, +20 max energy', maxLevel: 4},
          'targeting_system': {name: 'Targeting System', icon: 'üéØ', cost: 12, description: '+50% damage, improved accuracy', maxLevel: 3},
          'time_dilation': {name: 'Time Dilation', icon: '‚è∞', cost: 15, description: '50% less slow-time drain', maxLevel: 2},
          'shield_generator': {name: 'Shield Generator', icon: 'üî∞', cost: 25, description: '+1 emergency shield per phase', maxLevel: 2},
          'quantum_link': {name: 'Quantum Link', icon: 'üåå', cost: 30, description: 'Gain energy from enemy destruction', maxLevel: 1},
          'phase_shifter': {name: 'Phase Shifter', icon: 'üëª', cost: 35, description: 'Immune to some enemy attacks', maxLevel: 1},
          'weapon_overdrive': {name: 'Weapon Overdrive', icon: '‚öîÔ∏è', cost: 40, description: '+100% damage to final phases', maxLevel: 1},
          'temporal_master': {name: 'Temporal Master', icon: 'üåÄ', cost: 50, description: 'Auto slow-time when near death', maxLevel: 1},
          'galaxy_buster': {name: 'Galaxy Buster', icon: 'üí•', cost: 100, description: 'Instant kill enemies below 10% health', maxLevel: 1},
          'mobile_optimizer': {name: 'Mobile Optimizer', icon: 'üì±', cost: 30, description: 'Enhanced mobile controls and UI', maxLevel: 1}
      };

      // Achievements Configuration
      const GAME_ACHIEVEMENTS = {
          'first_victory': {name: 'First Victory', description: 'Complete your first mission', icon: 'üéØ', unlocked: false},
          'energy_master': {name: 'Energy Master', description: 'Maintain full energy for 60 seconds', icon: '‚ö°', unlocked: false},
          'bullet_dancer': {name: 'Bullet Dancer', description: 'Survive 500 bullets in one level', icon: 'üíÉ', unlocked: false},
          'space_ace': {name: 'Space Ace', description: 'Reach Level 10', icon: 'üöÄ', unlocked: false},
          'galaxy_defender': {name: 'Galaxy Defender', description: 'Reach Level 15', icon: 'üåå', unlocked: false},
          'cosmic_guardian': {name: 'Cosmic Guardian', description: 'Reach Level 20', icon: 'üëë', unlocked: false},
          'perfect_mission': {name: 'Perfect Mission', description: 'Complete a level without taking damage', icon: '‚ú®', unlocked: false},
          'speed_runner': {name: 'Speed Runner', description: 'Complete a level in under 30 seconds', icon: '‚ö°', unlocked: false},
          'ultimate_guardian': {name: 'Ultimate Guardian', description: 'Complete all 20 levels', icon: 'üèÜ', unlocked: false},
          'endless_warrior': {name: 'Endless Warrior', description: 'Survive 50 waves in endless mode', icon: '‚ôæÔ∏è', unlocked: false},
          'time_trial_master': {name: 'Time Trial Master', description: 'Complete campaign in under 10 minutes', icon: '‚è±Ô∏è', unlocked: false},
          'mobile_pilot': {name: 'Mobile Pilot', description: 'Complete 10 levels on mobile', icon: 'üì±', unlocked: false},
          'orientation_master': {name: 'Orientation Master', description: 'Play in all orientation modes', icon: 'üîÑ', unlocked: false},
          // 'tutorial_graduate': {name: 'Tutorial Graduate', description: 'Complete the tutorial', icon: 'üéì', unlocked: false} // Removed tutorial
      };

      let canvas, ctx;
      let animationId;
      
      // --- ANIMAZIONE ENTRATA NAVICELLE DUEL 1v1 ---
let duelEntryAnimation = {
  active: false,
  progress: 0,
  duration: 50 // ~0.8 sec a 60fps
};

function lerp(a, b, t) {
  return a + (b - a) * t;
}
      
      
      

// Aggiungi dopo le variabili duel esistenti (circa riga 8900)
let duel2v2Active = false;
let duel2v2Team = null; // 'team1' o 'team2'
let duel2v2Players = {
  team1: [],
  team2: []
};
let duel2v2TeamMate = null;
let duel2v2Opponents = [];



// JS globale
let teamElo = 1000; // ELO iniziale del team
let currentSeason = "2025-S1"; // cambia ogni stagione



// -- METTI QUESTE DUE RIGHE IN ALTO, subito dopo i let/var principali --
let duelBotDifficulty = localStorage.getItem('duelBotDifficulty') || "normal";
function getDuelBotParams() {
  return {
    easy:    { speed: 2.1, fireRate: 1.8, aimError: 80, health: 300, damage: 12, bulletSpeed: 7, size: 8 },
    normal:  { speed: 2.8, fireRate: 1.2, aimError: 35, health: 500, damage: 18, bulletSpeed: 10, size: 9 },
    hard:    { speed: 4.0, fireRate: 0.8, aimError: 10, health: 750, damage: 27, bulletSpeed: 13, size: 10 },
    insane:  { speed: 5.2, fireRate: 0.5, aimError: 4, health: 1100, damage: 40, bulletSpeed: 16, size: 12 }
  }[duelBotDifficulty];
}


const playerImage = new Image(); // <- AGGIUNGI QUESTA RIGA QUI!

      
      const backgroundImage = new Image();
backgroundImage.src = 'space-background.png'; // Senza /

const enemyImage = new Image();
enemyImage.src = 'alien-enemy2.png'; // Senza /

      let backgroundY = 0; // posizione verticale dello sfondo

      let bossImage = new Image();
      
      // Game Initialization
      function initGame() {
          canvas = document.getElementById('gameCanvas');
          ctx = canvas.getContext('2d');
          
          resizeCanvas();
          window.addEventListener('resize', resizeCanvas);
          window.addEventListener('orientationchange', handleOrientationChange);
          
          loadGameData();
          applyControlLayout(); // Apply saved control layout
          updateUI();
          generateLevelGrid();
          generateSkillTree();
          generateAchievements();
          createStellarParticles();
          setupEventListeners();
          setupMobileControls();

          // Orientation selector is no longer shown automatically
          // if (gameState.isMobile) {
          //     showOrientationSelector();
          //     showNotification('Mobile optimized! Choose your orientation.', 'info');
          // }
      }

      // Orientation Management
      function showOrientationSelector() {
          document.getElementById('orientationSelector').classList.add('active');
      }

      function setOrientation(orientation) {
          gameState.orientation = orientation;
          document.getElementById('orientationSelector').classList.remove('active');
          
          document.body.classList.remove('portrait-mode', 'landscape-mode');
          
          if (orientation === 'portrait') {
              document.body.classList.add('portrait-mode');
              screen.orientation?.lock?.('portrait').catch(() => {});
          } else if (orientation === 'landscape') {
              document.body.classList.add('landscape-mode');
              screen.orientation?.lock?.('landscape').catch(() => {});
          } else {
              screen.orientation?.unlock?.().catch(() => {});
          }
          
          const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
          savedData.orientation = orientation;
          localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
          
          const orientations = savedData.orientationsUsed || [];
          if (!orientations.includes(orientation)) {
              orientations.push(orientation);
              savedData.orientationsUsed = orientations;
              localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
              
              if (orientations.length >= 3) {
                  unlockAchievement('orientation_master');
              }
          }
          
          resizeCanvas();
          showNotification(`${orientation.charAt(0).toUpperCase() + orientation.slice(1)} mode activated!`, 'info');
      }

      function handleOrientationChange() {
          setTimeout(() => {
              resizeCanvas();
              if (gameState.orientation === 'auto') {
                  const isLandscape = window.innerWidth > window.innerHeight;
                  document.body.classList.remove('portrait-mode', 'landscape-mode');
                  document.body.classList.add(isLandscape ? 'landscape-mode' : 'portrait-mode');
              }
          }, 100);
      }

    function resizeCanvas() {
  const container = document.getElementById('gameContainer');
  let maxWidth, maxHeight;

  if (isMobileDevice && isMobileDevice()) {
    maxWidth = 960;   // o 1280
    maxHeight = 540;  // o 720
  } else {
    maxWidth = 1280;
    maxHeight = 720;
  }

  const aspect = maxWidth / maxHeight;
  let width = Math.min(container.offsetWidth, maxWidth);
  let height = Math.min(container.offsetHeight, maxHeight);

  if (width / height > aspect) {
    width = Math.round(height * aspect);
  } else {
    height = Math.round(width / aspect);
  }

  canvas.width = maxWidth;
  canvas.height = maxHeight;
  canvas.style.width = width + "px";
  canvas.style.height = height + "px";
  canvas.style.display = "block";
  canvas.style.margin = "auto";
}

      // Enhanced Mobile Controls Setup
      function setupMobileControls() {
          if (!gameState.isMobile) return;

          const joystick = document.getElementById('mobileJoystick');
          const joystickKnob = document.getElementById('mobileJoystickKnob');
          const shootBtn = document.getElementById('mobileShoot');
          const slowTimeBtn = document.getElementById('mobileSlowTime');
          const shieldBtn = document.getElementById('mobileShield');
          const specialBtn = document.getElementById('mobileSpecial');

          // Enhanced joystick with better responsiveness
          joystick.addEventListener('touchstart', (e) => {
              e.preventDefault();
              const touch = e.touches[0];
              const rect = joystick.getBoundingClientRect();
              const centerX = rect.left + rect.width / 2;
              const centerY = rect.top + rect.height / 2;
              
              gameState.touchControls.joystick.active = true;
              gameState.touchControls.joystick.startX = centerX;
              gameState.touchControls.joystick.startY = centerY;
              gameState.touchControls.joystick.touchId = touch.identifier;
              
              if (navigator.vibrate) {
                  navigator.vibrate(10);
              }
          }, { passive: false });

          document.addEventListener('touchmove', (e) => {
              if (!gameState.touchControls.joystick.active) return;
              
              let relevantTouch = null;
              for (let touch of e.touches) {
                  if (touch.identifier === gameState.touchControls.joystick.touchId) {
                      relevantTouch = touch;
                      break;
                  }
              }
              
              if (!relevantTouch) return;
              
              e.preventDefault();
              
              const centerX = gameState.touchControls.joystick.startX;
              const centerY = gameState.touchControls.joystick.startY;
              
              const deltaX = relevantTouch.clientX - centerX;
              const deltaY = relevantTouch.clientY - centerY;
              const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
              const maxDistance = 50;
              
              if (distance <= maxDistance) {
                  gameState.touchControls.joystick.currentX = deltaX;
                  gameState.touchControls.joystick.currentY = deltaY;
              } else {
                  const angle = Math.atan2(deltaY, deltaX);
                  gameState.touchControls.joystick.currentX = Math.cos(angle) * maxDistance;
                  gameState.touchControls.joystick.currentY = Math.sin(angle) * maxDistance;
              }

              joystickKnob.style.transform = `translate(${gameState.touchControls.joystick.currentX}px, ${gameState.touchControls.joystick.currentY}px)`;
          }, { passive: false });

          document.addEventListener('touchend', (e) => {
              let touchEnded = true;
              for (let touch of e.touches) {
                  if (touch.identifier === gameState.touchControls.joystick.touchId) {
                      touchEnded = false;
                      break;
                  }
              }
              
              if (touchEnded && gameState.touchControls.joystick.active) {
                  gameState.touchControls.joystick.active = false;
                  gameState.touchControls.joystick.currentX = 0;
                  gameState.touchControls.joystick.currentY = 0;
                  gameState.touchControls.joystick.touchId = null;
                  joystickKnob.style.transform = 'translate(0, 0)';
              }
          }, { passive: false });

          // Enhanced action buttons
          const setupActionButton = (button, action, hapticStrength = 20) => {
              button.addEventListener('touchstart', (e) => {
                  e.preventDefault();
                  action();
                  button.style.transform = 'scale(0.9)';
                  if (navigator.vibrate) {
                      navigator.vibrate(hapticStrength);
                  }
              }, { passive: false });

              button.addEventListener('touchend', (e) => {
                  e.preventDefault();
                  button.style.transform = 'scale(1)';
              }, { passive: false });
          };

          setupActionButton(shootBtn, () => {
              gameState.keys['shoot'] = true;
              setTimeout(() => { gameState.keys['shoot'] = false; }, 100);
          }, 10);

          setupActionButton(shieldBtn, useEmergencyShield, 50);
          setupActionButton(specialBtn, specialAttack, 40);

          // Enhanced canvas touch controls
          canvas.addEventListener('touchstart', (e) => {
              e.preventDefault();
              const touch = e.touches[0];
              const rect = canvas.getBoundingClientRect();
              gameState.mouse.x = touch.clientX - rect.left;
              gameState.mouse.y = touch.clientY - rect.top;
              
              gameState.touchControls.shooting = true;
              gameState.keys['shoot'] = true;
              gameState.touchControls.lastTouchTime = Date.now();
              
              if (e.touches.length > 1) {
                  useEmergencyShield();
              }
          }, { passive: false });

          canvas.addEventListener('touchmove', (e) => {
              e.preventDefault();
              const touch = e.touches[0];
              const rect = canvas.getBoundingClientRect();
              gameState.mouse.x = touch.clientX - rect.left;
              gameState.mouse.y = touch.clientY - rect.top;
          }, { passive: false });

          canvas.addEventListener('touchend', (e) => {
              e.preventDefault();
              gameState.touchControls.shooting = false;
              gameState.keys['shoot'] = false;
              
              const now = Date.now();
              if (now - gameState.touchControls.lastTouchTime < 300) {
                  toggleSlowTime();
              }
          }, { passive: false });

          // Prevent zoom on mobile
          document.addEventListener('gesturestart', (e) => e.preventDefault());
          document.addEventListener('gesturechange', (e) => e.preventDefault());
          document.addEventListener('gestureend', (e) => e.preventDefault());
      }

      // Event Listeners Setup
      function setupEventListeners() {
          document.addEventListener('keydown', (e) => {
              gameState.keys[e.key.toLowerCase()] = true;
              gameState.keys[e.code] = true;
              
              if (gameState.currentScreen === 'gameScreen' && gameState.gameRunning) {
                  switch(e.key.toLowerCase()) {
                      case 'escape':
                          forfeitMission();
                          break;
                      case 'r':
                          restartCurrentLevel();
                          break;
                      case 'e':
                          useEmergencyShield();
                          break;
                      case 'c':
                          specialAttack();
                          break;
                      case 'shift':
                          gameState.player.precisionMode = true;
                          break;
                  
                  
                  }
              }
          });
          
          document.addEventListener('keyup', (e) => {
              gameState.keys[e.key.toLowerCase()] = false;
              gameState.keys[e.code] = false;
              
              if (e.key.toLowerCase() === 'shift') {
                  gameState.player.precisionMode = false;
              }
          });
          
          if (!gameState.isMobile) {
              canvas.addEventListener('mousemove', (e) => {
                  const rect = canvas.getBoundingClientRect();
                  gameState.mouse.x = e.clientX - rect.left;
                  gameState.mouse.y = e.clientY - rect.top;
              });
              
              canvas.addEventListener('mousedown', (e) => {
                  if (e.button === 0) {
                      gameState.keys['shoot'] = true;
                  } else if (e.button === 2) {
                      gameState.keys['charged_shot'] = true;
                  }
              });
              
              canvas.addEventListener('mouseup', (e) => {
                  if (e.button === 0) {
                      gameState.keys['shoot'] = false;
                  } else if (e.button === 2) {
                      gameState.keys['charged_shot'] = false;
                  }
              });
              
              canvas.addEventListener('contextmenu', (e) => e.preventDefault());
          }
      }

      // Level Grid Generation
      function generateLevelGrid() {
          const levelGrid = document.getElementById('levelGrid');
          levelGrid.innerHTML = '';
          
          const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
          const highestLevel = savedData.highestLevel || 1;
          
          LEVEL_DATA.forEach((levelData, index) => {
              const levelCard = document.createElement('div');
              levelCard.className = 'level-card';
              
              if (levelData.level <= highestLevel) {
                  if (savedData.completedLevels && savedData.completedLevels.includes(levelData.level)) {
                      levelCard.classList.add('completed');
                  }
                  levelCard.onclick = () => startLevel(levelData.level);
              } else {
                  levelCard.classList.add('locked');
              }
              
              const phaseText = `${levelData.phases} Phase${levelData.phases > 1 ? 's' : ''}`;
              const warningText = levelData.level >= 16 ? 'IMPOSSIBLE' : 
                                 levelData.level >= 11 ? 'EXTREME' : 
                                 levelData.level >= 6 ? 'VERY HARD' : 
                                 levelData.level >= 3 ? 'CHALLENGING' : 'MANAGEABLE';
              
              levelCard.innerHTML = `
                  <div class="level-number">${levelData.level}</div>
                  <div class="level-boss">${levelData.enemy}</div>
                  <div class="level-difficulty" style="color: ${getDifficultyColor(levelData.difficulty)}">${levelData.difficulty}</div>
                  <div class="level-phases">${phaseText}</div>
                  <div class="level-warning">${warningText}</div>
                  ${levelData.level > highestLevel ? '<div style="color: #666;">üîí LOCKED</div>' : ''}
              `;
              
              levelGrid.appendChild(levelCard);
          });
      }

      function getDifficultyColor(difficulty) {
          const colors = {
              'Easy': '#4caf50',
              'Medium': '#ff9800',
              'Hard': '#f44336',
              'Very Hard': '#e91e63',
              'Extreme': '#9c27b0',
              'Nightmare': '#673ab7',
              'Impossible': '#3f51b5',
              'LEGENDARY': '#ffd700'
          };
          return colors[difficulty] || '#00bcd4';
      }

      // Skill Tree Generation
      function generateSkillTree() {
          const skillTreeGrid = document.getElementById('skillTreeGrid');
          skillTreeGrid.innerHTML = '';
          
          const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
          const purchasedSkills = savedData.skills || {};
          
          Object.entries(UPGRADE_SKILLS).forEach(([skillId, skillData]) => {
              const skillNode = document.createElement('div');
              skillNode.className = 'stat-item';
              
              const currentLevel = purchasedSkills[skillId] || 0;
              const canPurchase = gameState.skillPoints >= skillData.cost && currentLevel < skillData.maxLevel;
              
              if (canPurchase) {
                  skillNode.style.borderColor = '#00bcd4';
                  skillNode.style.cursor = 'pointer';
                  skillNode.onclick = () => purchaseSkill(skillId);
              }
              
              if (currentLevel > 0) {
                  skillNode.style.borderColor = '#4caf50';
                  skillNode.style.background = 'linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(0, 0, 0, 0.8))';
              }
              
              skillNode.innerHTML = `
                  <div style="font-size: clamp(2rem, 5vw, 2.5rem); margin-bottom: 0.8rem;">${skillData.icon}</div>
                  <div style="font-size: clamp(1rem, 3vw, 1.3rem); font-weight: 700; color: ${currentLevel > 0 ? '#4caf50' : '#00bcd4'}; margin-bottom: 0.5rem;">${skillData.name}</div>
                  <div style="font-size: clamp(0.9rem, 2.5vw, 1rem); margin-bottom: 0.8rem; line-height: 1.4;">${skillData.description}</div>
                  <div style="font-size: clamp(0.8rem, 2vw, 0.9rem); color: #888; margin-bottom: 0.5rem;">Level: ${currentLevel}/${skillData.maxLevel}</div>
                  <div style="font-size: clamp(0.9rem, 2.5vw, 1rem); color: #ffd700; font-weight: 600;">Cost: ${skillData.cost} UP</div>
              `;
              
              skillTreeGrid.appendChild(skillNode);
          });
      }

      function purchaseSkill(skillId) {
          const skillData = UPGRADE_SKILLS[skillId];
          const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
          
          if (!savedData.skills) savedData.skills = {};
          if (!savedData.skillPoints) savedData.skillPoints = 0;
          
          const currentLevel = savedData.skills[skillId] || 0;
          
          if (savedData.skillPoints >= skillData.cost && currentLevel < skillData.maxLevel) {
              savedData.skillPoints -= skillData.cost;
              savedData.skills[skillId] = currentLevel + 1;
              
              localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
              
              gameState.skillPoints = savedData.skillPoints;
              gameState.player.skills = savedData.skills;
              
              updateUI();
              generateSkillTree();
              applySkillEffects();
              
              showNotification(`${skillData.name} upgraded!`, 'achievement');
              
              if (navigator.vibrate) {
                  navigator.vibrate([50, 50, 50]);
              }
          }
      }

      function applySkillEffects() {
          const skills = gameState.player.skills;
          
          if (skills.hull_armor) {
              gameState.player.maxHealth = 100 + (skills.hull_armor * 50);
              if (gameState.player.health > gameState.player.maxHealth) {
                  gameState.player.health = gameState.player.maxHealth;
              }
          }
          
          if (skills.energy_core) {
              gameState.player.maxEnergy = 100 + (skills.energy_core * 20);
          }
      }

      // Achievements Generation
      function generateAchievements() {
          const achievementsList = document.getElementById('achievementsList');
          achievementsList.innerHTML = '';
          
          const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
          const unlockedAchievements = savedData.achievements || [];
          
          Object.entries(GAME_ACHIEVEMENTS).forEach(([achievementId, achievementData]) => {
              const achievementItem = document.createElement('div');
              achievementItem.className = 'stat-item';
              
              const isUnlocked = unlockedAchievements.includes(achievementId);
              
              if (isUnlocked) {
                  achievementItem.style.borderColor = '#4caf50';
                  achievementItem.style.background = 'linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(0, 0, 0, 0.8))';
              } else {
                  achievementItem.style.borderColor = '#666';
                  achievementItem.style.opacity = '0.6';
              }
              
              achievementItem.innerHTML = `
                  <div style="font-size: clamp(2rem, 5vw, 2.5rem); margin-bottom: 0.8rem;">${achievementData.icon}</div>
                  <div style="font-size: clamp(1rem, 3vw, 1.3rem); font-weight: 700; color: ${isUnlocked ? '#4caf50' : '#666'}; margin-bottom: 0.5rem;">${achievementData.name}</div>
                  <div style="font-size: clamp(0.9rem, 2.5vw, 1rem); color: ${isUnlocked ? '#ffffff' : '#888'}; line-height: 1.4; margin-bottom: 0.8rem;">${achievementData.description}</div>
                  ${isUnlocked ? '<div style="font-size: clamp(0.8rem, 2vw, 0.9rem); color: #ffd700; font-weight: 600;">‚úì UNLOCKED</div>' : '<div style="font-size: clamp(0.8rem, 2vw, 0.9rem); color: #666;">üîí LOCKED</div>'}
              `;
              
              achievementsList.appendChild(achievementItem);
          });
      }

      function unlockAchievement(achievementId) {
          const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
          if (!savedData.achievements) savedData.achievements = [];
          
          if (!savedData.achievements.includes(achievementId)) {
              savedData.achievements.push(achievementId);
              localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
              
              gameState.skillPoints += 15;
              savedData.skillPoints = (savedData.skillPoints || 0) + 15;
              localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
              
              updateUI();
              generateAchievements();
              
              const achievement = GAME_ACHIEVEMENTS[achievementId];
              showNotification(`üèÜ ${achievement.name} Unlocked! +15 Upgrade Points`, 'achievement');
              
              if (navigator.vibrate) {
                  navigator.vibrate([100, 50, 100, 50, 200]);
              }
          }
      }

     let pendingLevelToStart = null;

     
   function startLevel(levelNumber) {
     console.log("üî¥ STARTLEVEL chiamato con livello:", levelNumber);
    console.trace(); // Mostra da dove viene chiamata
    
    
    pendingLevelToStart = levelNumber;
    gameState.gameMode = 'campaign';
    gameState.gameRunning = false;
    showAdAndStartGame();
}

     function startEndlessMode() {
    gameState.gameMode = 'endless';
    showScreen('gameScreen');

   let selectedShip = localStorage.getItem('selectedShip') || 'navicella1.png';
assets.player = new Image();
assets.player.src = selectedShip;

console.log("Navicella selezionata:", selectedShip);
console.log("Sprite caricato:", assets.player.src);


// üîÑ Avvia il gioco
initGame();

     }

      function startSpeedrun() {
          gameState.gameMode = 'speedrun';
          gameState.speedrunStartTime = Date.now();
          gameState.currentLevel = 1;
          showScreen('gameScreen');
      }

  function setBackgroundForLevel(level) {
    const levelData = LEVEL_DATA[level - 1] || LEVEL_DATA[0];
    if (levelData.difficulty === "LEGENDARY") {
        backgroundImage.src = "space-background-legendary.png";
    } else if (levelData.difficulty === "Impossible") {
        backgroundImage.src = "space-background-impossible.png"; // PATCH Impossible
    } else if (levelData.difficulty === "Nightmare") {
        backgroundImage.src = "space-background-nightmare.png";
    } else if (levelData.difficulty === "Extreme") {
        backgroundImage.src = "space-background-extreme.png";
    } else if (levelData.difficulty === "Very Hard") {
        backgroundImage.src = "space-background-veryhard.png";
    } else if (levelData.difficulty === "Hard") {
        backgroundImage.src = "space-background-hard.png";
    } else if (levelData.difficulty === "Medium") {
        backgroundImage.src = "space-background-medium.png";
    } else {
        backgroundImage.src = "space-background.png";
    }
}
      
   function startGame(skipAd) {
  resetBossVisualState();

  if (pendingLevelToStart !== null) {
          console.log("üîµ CAMBIO LIVELLO da", gameState.currentLevel, "a", pendingLevelToStart);

      gameState.currentLevel = pendingLevelToStart;
      pendingLevelToStart = null;
  }
  if (!skipAd) {
      showAdAndStartGame();
      return;
  }

    // PATCH: Segnala che stai avviando la partita (evita doppio showAd)
    gameState.pendingStart = true;
      gameState.gameRunning = true; // <--- AGGIUNGI QUESTO PRIMA

    showScreen('gameScreen');
    gameState.pendingStart = false;

    gameState.obstacles = [];
    gameState.gameRunning = true;
    gameState.gamePaused = false;
    setBackgroundForLevel(gameState.currentLevel);
    gameState.levelStartTime = Date.now();
    gameState.slowTimeActive = false;
    gameState.timeScale = 0.3;
    gameState.currentPhase = 0;
    gameState.bulletHellIntensity = 0;
    gameState.adaptiveDifficulty = 1.0;
    gameState.screenShake = 0;
    gameState.transformationActive = false;

    // --- NAVICELLA SELEZIONATA: sprite e statistiche ---
    const selectedShip = localStorage.getItem("selectedShip") || "ship1";
    let playerStats = {};

    if (selectedShip === "ship1") {
    playerImage.src = "navicella1.png";
    playerStats = { speed: 5, maxHealth: 100, maxEnergy: 100 };
} else if (selectedShip === "ship2") {
    playerImage.src = "navicella2.png";
    playerStats = { speed: 3, maxHealth: 180, maxEnergy: 120 };
} else if (selectedShip === "ship3") {
    playerImage.src = "navicella3.png";
    playerStats = { speed: 7, maxHealth: 80, maxEnergy: 140 };
} else if (selectedShip === "ship4") {
    playerImage.src = "navicella4.png";
    playerStats = { speed: 6, maxHealth: 110, maxEnergy: 120 };
} else if (selectedShip === "summer") {
    playerImage.src = "navicella-summer.png";
    playerStats = { speed: 6.5, maxHealth: 105, maxEnergy: 125 }; // scegli i bonus che vuoi!
} else {
    playerImage.src = "navicella1.png";
    playerStats = { speed: 5, maxHealth: 100, maxEnergy: 100 };
}

    // Applica le statistiche al player
    gameState.player.speed = playerStats.speed;
    gameState.player.maxHealth = playerStats.maxHealth;
    gameState.player.health = playerStats.maxHealth;
    gameState.player.maxEnergy = playerStats.maxEnergy;
    gameState.player.energy = playerStats.maxEnergy;

    const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
    const skills = savedData.skills || {};

    // Aggiungi bonus delle skill eventualmente gi√† sbloccate
    if (skills.hull_armor) {
        gameState.player.maxHealth += skills.hull_armor * 50;
        gameState.player.health = gameState.player.maxHealth;
    }
    if (skills.energy_core) {
        gameState.player.maxEnergy += skills.energy_core * 20;
        gameState.player.energy = gameState.player.maxEnergy;
    }
    gameState.player.emergencyShields = 1 + (skills.shield_generator || 0);
    gameState.player.slowTimeEnergy = 100;
    gameState.player.skills = skills;
    gameState.player.invulnerabilityFrames = 0;
    gameState.player.angle = 0;
    gameState.player.x = canvas.width / 2;
    gameState.player.y = canvas.height - 120;

    if (gameState.gameMode === 'endless') {
        generateEndlessEnemy();
    } else {
        initializeCampaignEnemy();
    }

    gameState.bullets = [];
    gameState.enemyBullets = [];
    gameState.particles = [];
    gameState.powerUpItems = [];

    updateUI();
    gameLoop();
}
     function initializeCampaignEnemy() {
      if (gameState.gameMode === "duel1v1") return;


      const levelData = LEVEL_DATA[gameState.currentLevel - 1];

    // Carica l'immagine del boss in base alla difficolt√† (devi avere let bossImage = new Image(); globale)
    bossImage = new Image();
    bossImage.src = getBossImageForDifficulty(levelData.difficulty);

    gameState.enemy = {
        x: canvas.width / 2,
        y: 100,
        health: levelData.health * gameState.adaptiveDifficulty,
        maxHealth: levelData.health * gameState.adaptiveDifficulty,
        speed: levelData.speed,
        attackPatterns: levelData.attackPatterns,
        phases: levelData.phases,
        currentPhase: 1,
        attackCooldown: 0,
        moveDirection: 1,
        specialCooldown: 0,
        phaseTransition: false,
        enraged: false,
        bulletCount: levelData.bulletCount || 1,
        bulletSpeed: levelData.bulletSpeed || 4,
        attackSpeed: 1,
        angle: 0
    };
}
      function generateEndlessEnemy() {
            if (gameState.gameMode === "duel1v1") return;

        const randomLevel = Math.floor(Math.random() * LEVEL_DATA.length);
          const baseEnemy = LEVEL_DATA[randomLevel];
          
          gameState.enemy = {
              x: canvas.width / 2,
              y: 100,
              health: baseEnemy.health * gameState.adaptiveDifficulty,
              maxHealth: baseEnemy.health * gameState.adaptiveDifficulty,
              speed: baseEnemy.speed * (1 + gameState.adaptiveDifficulty * 0.1),
              attackPatterns: [...baseEnemy.attackPatterns],
              phases: Math.min(baseEnemy.phases + Math.floor(gameState.endlessWave / 10), 10),
              currentPhase: 1,
              attackCooldown: 0,
              moveDirection: 1,
              specialCooldown: 0,
              phaseTransition: false,
              enraged: false,
              bulletCount: (baseEnemy.bulletCount || 1) * (1 + gameState.endlessWave * 0.1),
              bulletSpeed: (baseEnemy.bulletSpeed || 4) * (1 + gameState.endlessWave * 0.05),
              attackSpeed: 1 + (gameState.endlessWave * 0.05),
              angle: 0
          };
      }

     // Sostituisci TUTTA la funzione gameLoop con questa:
let lastUpdateTime = performance.now();

function gameLoop() {
  if (!gameState.gameRunning || gameState.gamePaused) return;
  let now = performance.now();
  let rawDelta = (now - lastUpdateTime) / 16.67; // 16.67ms = 60fps
  lastUpdateTime = now;
  // Limita deltaTime per evitare scatti (tab inattiva, lag, ecc.)
  let deltaTime = (rawDelta > 2.5 || rawDelta < 0.2) ? 1 : rawDelta;
  deltaTime = Math.max(0.7, Math.min(deltaTime, 1.5));

  update(deltaTime); // <-- Passa deltaTime!
  
  // ---- QUI METTI LA TUA RIGA! ----
  if (gameState.gameMode === "duel1v1") {
    checkPowerupPickup();
  }
  
  
  render();

  // --- Gestione fine partita e challenge giornaliera ---
  let partitaFinita = false;
  if (gameState.player.health <= 0 && gameState.player.invulnerabilityFrames <= 0) partitaFinita = true;
  if (gameState.enemy && gameState.enemy.health <= 0) partitaFinita = true;

  if (gameState.isDailyChallenge && partitaFinita) {
    endDailyChallenge(gameState.player.score);
    gameState.isDailyChallenge = false;
    showScreen('mainMenu');
    return;
  }

  animationId = requestAnimationFrame(gameLoop);
}
     // Sostituisci la funzione update con questa:
function update(deltaTime) {
  deltaTime *= gameState.timeScale;
  deltaTime *= gameState.globalSpeed;

  updatePlayer(deltaTime);

  // SOLO in duelAI aggiorna il bot, i proiettili e la UI
  if (gameState.gameMode === "duelAI") {
    updateDuelBot();
    updatePlayerTrail();
    updateBullets(deltaTime);
    updateEnemyBullets(deltaTime);
    updateParticles(deltaTime);
    
      checkDuelAICollisions(); // <--- AGGIUNGI QUESTA RIGA QUI

    
    
    if (gameState.player.specialCooldown > 0) gameState.player.specialCooldown--;
    updateUI();
    // Eventualmente aggiungi qui gestione fine partita vs bot
    if (gameState.player.health <= 0) gameOver();
    if (duelBot.health <= 0) levelComplete();
    return; // NON aggiornare nulla della campagna!
  }

  // --- Tutto il resto SOLO se NON sei in duelAI ---
  updatePlayerTrail();
  updateObstacles(deltaTime);
  updateEnemy(deltaTime);
  updateBullets(deltaTime);
  updateEnemyBullets(deltaTime);
  updateParticles(deltaTime);
  updateSlowTime();
  updateAdaptiveDifficulty();
  updateScreenShake();
  checkCollisions();

  if (gameState.player.specialCooldown > 0) gameState.player.specialCooldown--;

  if (gameState.gameMode === 'chaos') updateChaosMode(deltaTime);
  else if (gameState.gameMode === 'endless') updateEndlessMode();
  else if (gameState.gameMode === 'speedrun') updateSpeedrunTimer();

  checkEnemyPhaseTransition();

  if (gameState.enemy && gameState.enemy.health <= 0) {
    esplodiBoss(gameState.enemy);
    levelComplete();
  } else if (gameState.player.health <= 0 && gameState.player.invulnerabilityFrames <= 0) {
    gameOver();
  }
}

  function updatePlayer(deltaTime) {
        if (gameState.player.isSpectator) return; // <--- AGGIUNGI QUI

    
    const player = gameState.player;
    const skills = gameState.player.skills;
    let speed = player.precisionMode ? 2 : 4;

if (gameState.gameMode === "duelAI") {
  speed = 16;
}
    
    
    // PATCH: rallenta TUTTO su mobile
if (isMobileDevice && isMobileDevice()) {
  speed = 2.1; // NAVICELLA ULTRA LENTA!
} else {
  speed = 1.9; // anche su desktop pi√π lenta!
}


// <<< INCOLLA QUI >>>
    document.getElementById('coinCount').textContent = "Speed " + (window.gameState.mobileShipSpeed || localStorage.getItem('mobileShipSpeed'));

    if (skills.targeting_system && player.precisionMode) speed *= 0.7;

speed *= 3; // lento!

    // PATCH: velocit√† globale super bassa per tutti
speed *= 2.5; // ancora pi√π lento!

    // Il resto come prima
    speed *= deltaTime;
    speed *= gameState.globalSpeed; // puoi anche forzarlo a 1 se vuoi

// if (isMobileDevice && isMobileDevice()) {
//   let custom = (window.gameState && window.gameState.mobileShipSpeed !== undefined)
//     ? window.gameState.mobileShipSpeed
//     : Number(localStorage.getItem('mobileShipSpeed')) || 0.7;
//   speed *= custom;
// }

speed *= deltaTime;
speed *= gameState.globalSpeed;

    // Mobile joystick movement
    if (gameState.isMobile && gameState.touchControls.joystick.active) {
        const joystickStrength = 0.18;
        const moveX = gameState.touchControls.joystick.currentX * joystickStrength;
        const moveY = gameState.touchControls.joystick.currentY * joystickStrength;

        player.x += moveX;
        player.y += moveY;

        if (moveX !== 0 || moveY !== 0) {
            player.angle = Math.atan2(moveY, moveX) + Math.PI / 2;
        }
    }

    // Keyboard movement (CAOS PATCH)
    let invert = gameState.chaosInverted ? -1 : 1;
    if (gameState.keys['w'] || gameState.keys['ArrowUp']) {
        player.y -= speed * invert;
        player.angle = 0;
    }
    if (gameState.keys['s'] || gameState.keys['ArrowDown']) {
        player.y += speed * invert;
        player.angle = Math.PI;
    }
    if (gameState.keys['a'] || gameState.keys['ArrowLeft']) {
        player.x -= speed * invert;
        player.angle = -Math.PI / 2;
    }
    if (gameState.keys['d'] || gameState.keys['ArrowRight']) {
        player.x += speed * invert;
        player.angle = Math.PI / 2;
    }

    // CAOS PATCH: Gravit√† pazza!
    if (gameState.chaosGravity) player.y += 6;

    // Diagonal movement adjustment
    if ((gameState.keys['w'] || gameState.keys['ArrowUp']) && (gameState.keys['a'] || gameState.keys['ArrowLeft'])) {
        player.angle = -Math.PI / 4;
    } else if ((gameState.keys['w'] || gameState.keys['ArrowUp']) && (gameState.keys['d'] || gameState.keys['ArrowRight'])) {
        player.angle = Math.PI / 4;
    } else if ((gameState.keys['s'] || gameState.keys['ArrowDown']) && (gameState.keys['a'] || gameState.keys['ArrowLeft'])) {
        player.angle = -3 * Math.PI / 4;
    } else if ((gameState.keys['s'] || gameState.keys['ArrowDown']) && (gameState.keys['d'] || gameState.keys['ArrowRight'])) {
        player.angle = 3 * Math.PI / 4;
    }

    // Keep player in bounds
    player.x = Math.max(50, Math.min(canvas.width - 50, player.x));
    player.y = Math.max(50, Math.min(canvas.height - 50, player.y));

    // Shooting
    if ((gameState.keys['shoot'] || gameState.keys[' '] || gameState.keys['Space'] || gameState.touchControls.shooting) && player.energy > 0) {
        if (Math.random() < 0.25) {
            shoot();
            player.energy = Math.max(0, player.energy - 1);
        }
    }

    if (gameState.keys['charged_shot'] && player.energy >= 10) {
        chargedShot();
        player.energy -= 10;
        gameState.keys['charged_shot'] = false;
    }

    // Energy regeneration
    if (player.energy < player.maxEnergy) {
        const regenRate = skills.energy_core ? 1.2 : 0.8;
        player.energy = Math.min(player.maxEnergy, player.energy + regenRate);
    }

    if (player.invulnerabilityFrames > 0) {
        player.invulnerabilityFrames--;
    }

    updateUI();
}
      function updateEnemy(deltaTime) {
              if (gameState.gameMode === "duel1v1") return; // Non aggiornare boss in 1v1!

            if (gameState.gameMode === "coop") return; // In co-op, posizione boss solo da server!

const enemy = gameState.enemy;
          if (!enemy) return;
          
          const levelData = LEVEL_DATA[gameState.currentLevel - 1] || LEVEL_DATA[0];
          
          // Enemy movement
          if (enemy.currentPhase >= 3) {
              enemy.x += enemy.moveDirection * enemy.speed * deltaTime * (1 + Math.sin(Date.now() * 0.01) * 0.5);
              enemy.angle += 0.02;
              if (Math.random() < 0.02) {
                  enemy.moveDirection *= -1;
              }
          } else {
              enemy.x += enemy.moveDirection * enemy.speed * deltaTime;
              enemy.angle += 0.01;
          }
          
          if (enemy.x <= 100 || enemy.x >= canvas.width - 100) {
              enemy.moveDirection *= -1;
          }
          
          // Enemy attacks
          if (enemy.attackCooldown <= 0) {
              const pattern = enemy.attackPatterns[Math.floor(Math.random() * enemy.attackPatterns.length)];
              executeAttackPattern(pattern);
              
              let baseSpeed = 60;
              if (gameState.currentLevel <= 5) {
                  baseSpeed = 90;
              } else if (gameState.currentLevel <= 10) {
                  baseSpeed = 70;
              } else if (gameState.currentLevel <= 15) {
                  baseSpeed = 50;
              } else {
                  baseSpeed = 35;
              }
              
              enemy.attackCooldown = baseSpeed / (enemy.attackSpeed * gameState.adaptiveDifficulty);
          } else {
              enemy.attackCooldown -= deltaTime;
          }
      }
      
      // --- PATCH: funzione mancante per parametri proiettili mobile ---
function getMobileBulletParams(count, speed) {
  // Se sei su mobile, riduci il numero di proiettili e la loro velocit√† per evitare lag
  if (isMobileDevice && typeof isMobileDevice === "function" && isMobileDevice()) {
    return {
      count: Math.max(1, Math.round(count * 0.6)),
      speed: speed * 1.2
    };
  }
  // Su desktop, torna tutto normale
  return { count, speed };
}
      
      function executeAttackPattern(pattern) {
           if (pattern === 'basic') {
            playSound('bossShoot', 0.65);
          }
        const enemy = gameState.enemy;
  const levelData = LEVEL_DATA[gameState.currentLevel - 1] || LEVEL_DATA[0];
  const mobileParams = getMobileBulletParams(enemy.bulletCount, levelData.bulletSpeed || 4);

  // Limita drasticamente i proiettili nei pattern pesanti!
  const bulletCount = Math.min(mobileParams.count, 8); // MAX 8
  const bulletSpeed = mobileParams.speed;

  switch (pattern) {
    case 'basic':
      for (let i = 0; i < Math.min(3 * bulletCount, 16); i++) {
        gameState.enemyBullets.push({
          x: enemy.x + (i - 1) * 30,
          y: enemy.y + 50,
          vx: (i - 1) * 0.5,
          vy: bulletSpeed,
          color: '#f44336',
          size: 8,
          damage: 15
        });
      }
      break;

    case 'spread':
      const spreadCount = Math.min(Math.floor(5 * bulletCount), 18);
      for (let i = 0; i < spreadCount; i++) {
        const angle = (i / spreadCount) * Math.PI - Math.PI / 2;
        gameState.enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 50,
          vx: Math.cos(angle) * bulletSpeed,
          vy: Math.sin(angle) * bulletSpeed + 2,
          color: '#e91e63',
          size: 6,
          damage: 12
        });
      }
      break;

    case 'tracking': {
  const dx = gameState.player.x - enemy.x;
  const dy = gameState.player.y - enemy.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  for (let i = 0; i < 1; i++) { // SOLO 1 proiettile!
    gameState.enemyBullets.push({
      x: enemy.x,
      y: enemy.y + 50,
      vx: (dx / dist) * bulletSpeed,
      vy: (dy / dist) * bulletSpeed,
      color: '#ff9800',
      size: 10,
      damage: 18,
      tracking: true,
      trackingStrength: 0.004 // lentissimo!
    });
  }
  break;
}

    case 'laser':
      for (let i = 0; i < Math.min(15, 12); i++) {
        gameState.enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 50 + i * 12,
          vx: 0,
          vy: bulletSpeed * 1.5,
          color: '#ff9800',
          size: 12,
          damage: 20
        });
      }
      break;

    case 'wave':
      for (let i = 0; i < Math.min(8 * bulletCount, 16); i++) {
        const angle = (i / 8) * Math.PI * 2;
        gameState.enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 50,
          vx: Math.cos(angle) * 2,
          vy: Math.sin(angle) * 2 + bulletSpeed,
          color: '#673ab7',
          size: 8,
          damage: 15,
          wave: true,
          waveOffset: i * 0.5
        });
      }
      break;

    case 'swarm':
      for (let i = 0; i < Math.min(12 * bulletCount, 24); i++) {
        gameState.enemyBullets.push({
          x: enemy.x + (Math.random() - 0.5) * 100,
          y: enemy.y + 30,
          vx: (Math.random() - 0.5) * 4,
          vy: bulletSpeed * 0.8,
          color: '#3f51b5',
          size: 6,
          damage: 10
        });
      }
      break;

    case 'spiral':
      const spiralCount = Math.min(Math.floor(10 * bulletCount), 18);
      for (let i = 0; i < spiralCount; i++) {
        const angle = (i / spiralCount) * Math.PI * 4 + (Date.now() * 0.01);
        gameState.enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 50,
          vx: Math.cos(angle) * 3,
          vy: Math.sin(angle) * 3 + bulletSpeed,
          color: '#2196f3',
          size: 7,
          damage: 14
        });
      }
      break;

    case 'chaos':
      for (let i = 0; i < Math.min(15 * bulletCount, 20); i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 2;
        gameState.enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 50,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed + 1,
          color: '#00bcd4',
          size: Math.random() * 8 + 4,
          damage: 16
        });
      }
      break;

    case 'ultimate':
      for (let i = 0; i < Math.min(20 * bulletCount, 20); i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 6 + 3;
        gameState.enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 50,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          color: '#ffd700',
          size: 15,
          damage: 25,
          ultimate: true
        });
      }
      break;
  }

  gameState.bulletHellIntensity = Math.min(100, gameState.bulletHellIntensity + 2);
}


      function shoot() {
             playSound('playerShoot', 0.5);

        
        if (gameState.player.isSpectator) return;

  
            // AGGIUNGI QUESTO BLOCCO:
  if (gameState.gameMode === "duel1v1" && window.socket && duelRoomId) {
    // Calcola la direzione del colpo
    const dx = gameState.mouse.x - gameState.player.x;
    const dy = gameState.mouse.y - gameState.player.y;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
    const speed = 15;
    const vx = (dx / dist) * speed;
    const vy = (dy / dist) * speed;

    // Avvisa il server che hai sparato
    window.socket.emit("duel_update", {
      room: duelRoomId,
      player: { ...gameState.player },
      action: "shoot",
      x: gameState.player.x,
      y: gameState.player.y,
      vx,
      vy
    });
  }
        
        
        
        // COOP: invia evento al server, non aggiungere subito il proiettile locale!
  if (gameState.gameMode === "coop" && socket) {
    let player = gameState.player;
    let skills = player.skills || {};
    let damage = 25;
    if (skills.targeting_system && player.precisionMode) damage *= 1.5;

    let targetX = gameState.mouse.x;
    let targetY = gameState.mouse.y;
    if (gameState.isMobile && gameState.enemy) {
      targetX = gameState.enemy.x;
      targetY = gameState.enemy.y;
    }
    const dx = targetX - player.x;
    const dy = targetY - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const speed = 15;
    const vx = dist > 0 ? (dx / dist) * speed : 0;
    const vy = dist > 0 ? (dy / dist) * speed : -speed;

    socket.emit('shoot', {
      x: player.x,
      y: player.y - 20,
      vx, vy,
      color: '#00bcd4',
      size: gameState.chaosBullets === "big" ? 28 : 6,
      damage,
      owner: mySocketId // identifica chi ha sparato
    });

    createMuzzleFlash(player.x, player.y - 20);
    return; // NON aggiungere il proiettile localmente!
  }

  // SINGLE PLAYER: come prima
  let player = gameState.player;
  let skills = player.skills || {};
  let damage = 25;
  if (skills.targeting_system && player.precisionMode) damage *= 1.5;

  let targetX = gameState.mouse.x;
  let targetY = gameState.mouse.y;
  if (gameState.isMobile && gameState.enemy) {
    targetX = gameState.enemy.x;
    targetY = gameState.enemy.y;
  }
  const dx = targetX - player.x;
  const dy = targetY - player.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const speed = 15;
  const vx = dist > 0 ? (dx / dist) * speed : 0;
  const vy = dist > 0 ? (dy / dist) * speed : -speed;

  gameState.bullets.push({
    x: player.x,
    y: player.y - 20,
    vx, vy,
    color: '#00bcd4',
    size: gameState.chaosBullets === "big" ? 28 : 6,
    damage,
    owner: mySocketId,
    team: duel2v2Team // <--- AGGIUNGI QUESTA RIGA QUI!
  });

  createMuzzleFlash(player.x, player.y - 20);
}
      function chargedShot() {
    const player = gameState.player;
    const skills = gameState.player.skills;
    let damage = 80;

    if (skills.targeting_system) {
        damage *= 2;
    }

    // PATCH: CO-OP multiplayer: invia al server come un normale proiettile!
    if (gameState.gameMode === "coop" && socket) {
        socket.emit('shoot', {
            x: player.x,
            y: player.y - 20,
            vx: 0,
            vy: -18,
            color: '#ffd700',
            size: 15,
            damage: damage,
            charged: true,
            owner: mySocketId
        });
        createMuzzleFlash(player.x, player.y - 20, true);
        return; // NON aggiungere localmente!
    }

    // SINGLEPLAYER / OFFLINE: aggiungi localmente
    gameState.bullets.push({
        x: player.x,
        y: player.y - 20,
        vx: 0,
        vy: -18,
        color: '#ffd700',
        size: 15,
        damage: damage,
        charged: true
    });

    createMuzzleFlash(player.x, player.y - 20, true);
}
      function createMuzzleFlash(x, y, charged = false) {
          const particleCount = charged ? 15 : 8;
          const color = charged ? '#ffd700' : '#00bcd4';
          
          for (let i = 0; i < particleCount; i++) {
              gameState.particles.push({
                  x: x,
                  y: y,
                  vx: (Math.random() - 0.5) * 8,
                  vy: (Math.random() - 0.5) * 8 - 5,
                  color: color,
                  size: Math.random() * 4 + 2,
                  life: 20,
                  maxLife: 20,
                  alpha: 1
              });
          }
      }

      function toggleSlowTime() {
    // Slow time DISABLED
}
document.getElementById('mobileSlowTime').style.display = "none";

      function updateSlowTime() {
          const player = gameState.player;
          const skills = gameState.player.skills;
          
          if (gameState.slowTimeActive) {
              const drainRate = skills.time_dilation ? 1 : 1.5;
              player.slowTimeEnergy -= drainRate;
              
              if (player.slowTimeEnergy <= 0) {
                  gameState.slowTimeActive = false;
                  gameState.timeScale = 1;
                  player.slowTimeEnergy = 0;
              }
          } else if (player.slowTimeEnergy < 100) {
              player.slowTimeEnergy += 0.5;
          }
          
          if (skills.temporal_master && player.health < player.maxHealth * 0.2 && !gameState.slowTimeActive) {
              gameState.timeScale = 0.5;
          } else if (!gameState.slowTimeActive) {
              gameState.timeScale = 1;
          }
      }

      function updateAdaptiveDifficulty() {
          const survivalTime = (Date.now() - gameState.levelStartTime) / 1000;
          
          if (survivalTime > 120) {
              gameState.adaptiveDifficulty = Math.min(2.0, gameState.adaptiveDifficulty + 0.003);
              
              if (gameState.adaptiveDifficulty > 1.5) {
                  showDifficultyWarning();
              }
          }
          
          if (gameState.enemy) {
              gameState.enemy.bulletCount = 1 + (gameState.adaptiveDifficulty - 1) * 0.2;
              gameState.enemy.attackSpeed = gameState.adaptiveDifficulty;
          }
      }

      function showDifficultyWarning() {
          const warning = document.getElementById('difficultyWarning');
          warning.style.display = 'block';
          
          setTimeout(() => {
              warning.style.display = 'none';
          }, 2000);
      }

      function updateScreenShake() {
          if (gameState.screenShake > 0) {
              gameState.screenShake *= 0.9;
              if (gameState.screenShake < 0.1) {
                  gameState.screenShake = 0;
              }
          }
      }

      function checkEnemyPhaseTransition() {
          const enemy = gameState.enemy;
          if (!enemy) return;
          
          const healthPercent = enemy.health / enemy.maxHealth;
          const phaseThreshold = (enemy.phases - enemy.currentPhase) / enemy.phases;
          
          if (healthPercent <= phaseThreshold && enemy.currentPhase < enemy.phases) {
              triggerPhaseTransition(enemy.currentPhase + 1);
          }
      }

      function triggerPhaseTransition(newPhase) {
          gameState.enemy.currentPhase = newPhase;
          gameState.enemy.phaseTransition = true;
          gameState.transformationActive = true;
          
          document.getElementById('transformationOverlay').classList.add('active');
          gameState.screenShake = 6;
          
          gameState.enemy.speed *= 1.1;
          gameState.enemy.bulletCount *= 1.15;
          
          createTransformationEffect();
          
          setTimeout(() => {
              gameState.enemy.phaseTransition = false;
              gameState.transformationActive = false;
              document.getElementById('transformationOverlay').classList.remove('active');
          }, 2000);
      }

      function createTransformationEffect() {
          for (let i = 0; i < 40; i++) {
              const angle = Math.random() * Math.PI * 2;
              const speed = Math.random() * 12 + 5;
              gameState.particles.push({
                  x: gameState.enemy.x,
                  y: gameState.enemy.y,
                  vx: Math.cos(angle) * speed,
                  vy: Math.sin(angle) * speed,
                  color: '#00bcd4',
                  size: Math.random() * 10 + 6,
                  life: 80,
                  maxLife: 80,
                  alpha: 1
              });
          }
      }

      function useEmergencyShield() {
          if (gameState.player.emergencyShields > 0) {
              gameState.player.emergencyShields--;
              gameState.player.invulnerabilityFrames = 180;
              
              gameState.enemyBullets = gameState.enemyBullets.filter(bullet => {
                  const dist = Math.sqrt(
                      Math.pow(bullet.x - gameState.player.x, 2) + 
                      Math.pow(bullet.y - gameState.player.y, 2)
                  );
                  return dist > 150;
              });
              
              createShieldEffect();
              updateUI();
          }
      }

      function createShieldEffect() {
          for (let i = 0; i < 40; i++) {
              const angle = (i / 40) * Math.PI * 2;
              gameState.particles.push({
                  x: gameState.player.x,
                  y: gameState.player.y,
                  vx: Math.cos(angle) * 10,
                  vy: Math.sin(angle) * 10,
                  color: '#00bcd4',
                  size: 8,
                  life: 80,
                  maxLife: 80,
                  alpha: 1
              });
          }
      }

      function specialAttack() {
    // Se hai una carica speciale dallo shop, usala subito!
    if (gameState.player.specialReady) {
        gameState.player.specialReady = false;
        eseguiSpecial();
        return;
    }

    // Cooldown attivo? Blocca e mostra notifica
    if (gameState.player.specialCooldown > 0) {
        showNotification("‚ö° Special not ready!", "info");
        return;
    }

    // Solo se vita < 40%
    if (gameState.player.health < gameState.player.maxHealth * 0.4) {
        eseguiSpecial();
        gameState.player.specialCooldown = 600; // 10 secondi a 60fps
    } else {
        showNotification("‚ö° Special available only when low HP!", "info");
    }
}

// Funzione helper: esegue davvero l'attacco speciale
function eseguiSpecial() {
    const damage = 120;
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        gameState.bullets.push({
            x: gameState.player.x,
            y: gameState.player.y - 20,
            vx: Math.cos(angle) * 8,
            vy: Math.sin(angle) * 8 - 4,
            color: '#ffd700',
            size: 12,
            damage: damage,
            special: true
        });
    }
    gameState.player.health = Math.max(1, gameState.player.health - 15);
    showNotification("‚ö° Special attack launched!", "info");
    updateUI();
}
      function updateEndlessMode() {
          if (gameState.gameMode !== 'endless') return;
          
          document.getElementById('endlessHud').style.display = 'block';
          document.getElementById('currentWave').textContent = gameState.endlessWave;
          document.getElementById('difficultyMultiplier').textContent = gameState.adaptiveDifficulty.toFixed(1);
          
          if (gameState.enemy && gameState.enemy.health <= 0) {
              gameState.endlessWave++;
              gameState.adaptiveDifficulty += 0.1;
              
              generateEndlessEnemy();
              
              if (gameState.endlessWave >= 50) {
                  unlockAchievement('endless_warrior');
              }
          }
      }

      function updateSpeedrunTimer() {
          if (gameState.gameMode !== 'speedrun') return;
          
          document.getElementById('speedrunTimer').style.display = 'block';
          const elapsed = (Date.now() - gameState.speedrunStartTime) / 1000;
          const minutes = Math.floor(elapsed / 60);
          const seconds = Math.floor(elapsed % 60);
          document.getElementById('speedrunTime').textContent = 
              `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
          
          if (gameState.currentLevel >= 20 && elapsed < 600) {
              unlockAchievement('time_trial_master');
          }
      }

      function updateBullets(deltaTime) {
          gameState.bullets = gameState.bullets.filter(bullet => {
              bullet.x += bullet.vx * deltaTime;
              bullet.y += bullet.vy * deltaTime;
              
              return bullet.y > -50 && bullet.y < canvas.height + 50 &&
                     bullet.x > -50 && bullet.x < canvas.width + 50;
          });
      }

      function updateEnemyBullets(deltaTime) {
    const MAX_ENEMY_BULLETS = 45;
    gameState.enemyBullets = gameState.enemyBullets.filter(bullet => {
        bullet.x += bullet.vx * deltaTime;
        bullet.y += bullet.vy * deltaTime;

        // PATCH: tracking lentissimo e rarissimo!
        if (bullet.tracking && Math.random() < 0.01) {
            const dx = gameState.player.x - bullet.x;
            const dy = gameState.player.y - bullet.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const ts = bullet.trackingStrength || 0.004;
            bullet.vx += (dx / dist) * ts;
            bullet.vy += (dy / dist) * ts;
            // Clamp velocit√† massima
            const maxSpeed = 4;
            const vNorm = Math.sqrt(bullet.vx * bullet.vx + bullet.vy * bullet.vy);
            if (vNorm > maxSpeed) {
                bullet.vx = (bullet.vx / vNorm) * maxSpeed;
                bullet.vy = (bullet.vy / vNorm) * maxSpeed;
            }
        }

        if (bullet.wave) {
            bullet.x += Math.sin(Date.now() * 0.01 + bullet.waveOffset) * 1.5;
        }

        return bullet.y > -50 && bullet.y < canvas.height + 50 &&
               bullet.x > -50 && bullet.x < canvas.width + 50;
    });

    if (gameState.enemyBullets.length > MAX_ENEMY_BULLETS) {
        gameState.enemyBullets = gameState.enemyBullets.slice(-MAX_ENEMY_BULLETS);
    }
}

      function updateParticles(deltaTime) {
          if (isMobileDevice() && window.innerWidth > window.innerHeight) {
  // PATCH: limita particelle e proiettili su mobile landscape
  if (gameState.particles.length > 38) gameState.particles = gameState.particles.slice(-38);
  if (gameState.bullets.length > 22) gameState.bullets = gameState.bullets.slice(-22);
  if (gameState.enemyBullets.length > 22) gameState.enemyBullets = gameState.enemyBullets.slice(-22);
}
        
        
        gameState.particles = gameState.particles.filter(particle => {
              particle.x += particle.vx * deltaTime;
              particle.y += particle.vy * deltaTime;
              particle.life -= deltaTime;
              particle.alpha = particle.life / particle.maxLife;
              
              return particle.life > 0;
          });
      }

    function checkCollisions() {
    // Player bullets hitting enemy
    gameState.bullets.forEach((bullet, bulletIndex) => {
        const enemy = gameState.enemy;
        if (!enemy) return;

        const dist = Math.sqrt(
            Math.pow(bullet.x - enemy.x, 2) + 
            Math.pow(bullet.y - enemy.y, 2)
        );

        if (dist < 60) {
            let damage = bullet.damage;

            if (gameState.player.skills.galaxy_buster && enemy.health < enemy.maxHealth * 0.1) {
                damage = enemy.health;
            }

            if (gameState.player.skills.weapon_overdrive && enemy.currentPhase >= enemy.phases - 1) {
                damage *= 2;
            }

            gameState.player.score += Math.floor(damage);
            enemy.health -= damage;
            gameState.bullets.splice(bulletIndex, 1);

            createHitParticles(bullet.x, bullet.y, bullet.color);

            // SUONO HIT BOSS/NEMICO (puoi anche crearne uno apposito)
                  playSound('playerShoot', 0.5);

            // Se la vita va a zero, suona esplosione
            if (enemy.health <= 0) {
               playSound('explosion', 0.7);
            }

            updateUI();
        }
    });

    // Enemy bullets hitting player
    gameState.enemyBullets.forEach((bullet, bulletIndex) => {
        const player = gameState.player;

        if (player.invulnerabilityFrames > 0) return;

        let hitboxSize = player.precisionMode ? 15 : 25;
        if (player.skills.targeting_system && player.precisionMode) {
            hitboxSize = 10;
        }

        if (player.skills.mobile_optimizer && gameState.isMobile) {
            hitboxSize *= 0.9;
        }

        const dist = Math.sqrt(
            Math.pow(bullet.x - player.x, 2) + 
            Math.pow(bullet.y - player.y, 2)
        );

        if (dist < hitboxSize) {
            let damage = bullet.damage || 15;

            if (gameState.currentLevel <= 5) {
                damage *= 0.8;
            } else if (gameState.currentLevel <= 10) {
                damage *= 0.9;
            }

            if (gameState.player.skills.hull_armor) {
                damage *= (1 - gameState.player.skills.hull_armor * 0.2);
            }

            player.health -= damage;
            gameState.enemyBullets.splice(bulletIndex, 1);
            player.invulnerabilityFrames = 60;

            gameState.screenShake = 4;

            createHitParticles(bullet.x, bullet.y, '#f44336');

            // SUONO HIT PLAYER (navicella prende danno)
                 playSound('playerHit', 0.7);
            updateUI();

            if (navigator.vibrate && gameState.isMobile) {
                navigator.vibrate(100);
            }
        }
    });

    // Player bullets hitting obstacles (asteroids & mines distruttibili)
    gameState.bullets.forEach((bullet, bulletIndex) => {
        gameState.obstacles.forEach((ob, obIndex) => {
            if (ob.hit) return;
            // PATCH: asteroidi E mine sono distruttibili!
            if (ob.type !== "asteroid" && ob.type !== "mine") return;
            const dx = ob.x - bullet.x;
            const dy = ob.y - bullet.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const hitbox = ob.size / 2 + bullet.size;
            if (dist < hitbox) {
                // Se non ha health, fallback a 30
                ob.health = (typeof ob.health === "number") ? ob.health : 30;
                ob.maxHealth = (typeof ob.maxHealth === "number") ? ob.maxHealth : 30;
                ob.health -= bullet.damage || 15;

                // Elimina il proiettile SEMPRE
                gameState.bullets.splice(bulletIndex, 1);

                // Se vita finita, distruggi!
                if (ob.health <= 0) {
                    ob.hit = true;
                    spawnSuperExplosion(ob.x, ob.y, {colors:["#ffe700","#ff9800","#fff"],count:18});
                    startShake(10, 6);

                    // SUONO ESPLOSIONE ASTEROIDE/MINA
                         playSound('explosion', 0.7);
                } else {
                    // Effetto "colpo" (piccole particelle)
                    createHitParticles(bullet.x, bullet.y, "#ffd700");
                }
            }
        });
    });

    if (gameState.enemyBullets.length >= 500) {
        unlockAchievement('bullet_dancer');
    }
    checkObstacleCollisions();
}
      
      function createHitParticles(x, y, color) {
          for (let i = 0; i < 12; i++) {
              gameState.particles.push({
                  x: x,
                  y: y,
                  vx: (Math.random() - 0.5) * 12,
                  vy: (Math.random() - 0.5) * 12,
                  color: color,
                  size: Math.random() * 6 + 3,
                  life: 50,
                  maxLife: 50,
                  alpha: 1
              });
          }
      }

   function levelComplete() {
    // PATCH: Previeni avanzamenti multipli
    if (window.levelAdvancing) return;
    window.levelAdvancing = true;

    showAd(); // Mostra pubblicit√† alla vittoria

    // Se hai completato la campagna (livello 20)
    if (gameState.gameMode === 'campaign' && gameState.currentLevel >= 20) {
        unlockAchievement('ultimate_guardian');
        document.getElementById('victoryScore').textContent = gameState.player.score.toLocaleString();
        document.getElementById('victoryTime').textContent = Math.floor(gameState.totalSurvivalTime);
        showScreen('victory');
        updateUI();
        window.levelAdvancing = false; // Sblocca flag
        return;
    }

    gameState.gameRunning = false;

    // Calcola tempo di sopravvivenza
    const survivalTime = (Date.now() - gameState.levelStartTime) / 1000;
    gameState.totalSurvivalTime += survivalTime;

    // Calcola upgrade points
    let upgradePointsEarned = Math.floor(gameState.currentLevel * 1.2) + 5;
    if (gameState.gameMode === 'endless') {
        upgradePointsEarned = Math.floor(gameState.endlessWave * 0.5);
    } else if (gameState.gameMode === 'speedrun') {
        upgradePointsEarned = Math.floor(survivalTime < 30 ? 50 : 25);
    }
    gameState.skillPoints += upgradePointsEarned;

    // Calcola coins
    let coinsEarned = Math.floor(Math.random() * 8) + 3;
    gameState.coins += coinsEarned;

    // Aggiorna salvataggio
    const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
    savedData.totalEnemiesDefeated = (savedData.totalEnemiesDefeated || 0) + 1;

    // Aggiorna dati specifici modalit√†
    if (gameState.gameMode === 'campaign') {
        savedData.highestLevel = Math.max(savedData.highestLevel || 1, gameState.currentLevel + 1);
    } else if (gameState.gameMode === 'endless') {
        savedData.endlessBestWave = Math.max(savedData.endlessBestWave || 0, gameState.endlessWave);
        savedData.endlessBestScore = Math.max(savedData.endlessBestScore || 0, gameState.player.score);
    } else if (gameState.gameMode === 'speedrun') {
        const currentTime = gameState.totalSurvivalTime;
        if (!savedData.speedrunBestTime || currentTime < savedData.speedrunBestTime) {
            savedData.speedrunBestTime = currentTime;
        }
    }

    // Aggiorna bestScore sempre!
    savedData.bestScore = Math.max(savedData.bestScore || 0, gameState.player.score);

    // Aggiorna altri dati
    savedData.skillPoints = (savedData.skillPoints || 0) + upgradePointsEarned;
    savedData.longestSurvival = Math.max(savedData.longestSurvival || 0, survivalTime);
    savedData.coins = gameState.coins;

    // Segna livello completato
    if (!savedData.completedLevels) {
        savedData.completedLevels = [];
    }
    if (gameState.gameMode === 'campaign' && !savedData.completedLevels.includes(gameState.currentLevel)) {
        savedData.completedLevels.push(gameState.currentLevel);
    }

    localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));

    // Notifica, leaderboard LOCAL + GLOBALE
    showNotification(`+${coinsEarned} Coins!`, 'info');
    let username = getPlayerName();
    submitLocalScore(username, gameState.player.score, gameState.currentLevel);
    submitGlobalScore(username, gameState.player.score);

    // Gestione avanzamento livello/modalit√†
    if (gameState.gameMode === 'campaign') {
        if (window.levelTimeout) clearTimeout(window.levelTimeout);
        window.levelTimeout = setTimeout(() => {
            pendingLevelToStart = gameState.currentLevel + 1;
            gameState.gameRunning = false;
            startGame(true); // skipAd:true per evitare loop pubblicit√†
            window.levelAdvancing = false; // Sblocca flag dopo avanzamento!
        }, 2000);
    } else if (gameState.gameMode === 'endless') {
        if (window.levelTimeout) clearTimeout(window.levelTimeout);
        window.levelTimeout = setTimeout(() => {
            startGame();
            window.levelAdvancing = false;
        }, 1500);
    } else {
        showScreen('mainMenu');
        window.levelAdvancing = false;
    }

    updateUI();
}

     function submitGlobalScore(username, score) {
  const url = `https://dreamlo.com/lb/5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw/add/${encodeURIComponent(username)}/${score}`;
  fetch(url)
    .then(() => console.log("Score inviato a Dreamlo!"))
    .catch(err => console.error("Dreamlo errore:", err));
}
      
  function gameOver() {
     showAd();
    
    gameState.gameRunning = false;
    const survivalTime = (Date.now() - gameState.levelStartTime) / 1000;
    let upgradePointsEarned = Math.floor(gameState.currentLevel * 0.6) + Math.floor(survivalTime / 20);

    if (gameState.gameMode === 'endless') {
        upgradePointsEarned = Math.floor(gameState.endlessWave * 0.4);
    }

    gameState.skillPoints += upgradePointsEarned;

    const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
    savedData.totalDeaths = (savedData.totalDeaths || 0) + 1;
    savedData.skillPoints = (savedData.skillPoints || 0) + upgradePointsEarned;
    savedData.longestSurvival = Math.max(savedData.longestSurvival || 0, survivalTime);

    // PATCH: aggiorna bestScore sempre!
    savedData.bestScore = Math.max(savedData.bestScore || 0, gameState.player.score);

    if (gameState.gameMode === 'endless') {
        savedData.endlessBestWave = Math.max(savedData.endlessBestWave || 0, gameState.endlessWave);
        savedData.endlessBestScore = Math.max(savedData.endlessBestScore || 0, gameState.player.score);
    }

    localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));

    document.getElementById('finalScore').textContent = gameState.player.score.toLocaleString();
    document.getElementById('finalLevel').textContent = gameState.gameMode === 'endless' ? 
        `Wave ${gameState.endlessWave}` : gameState.currentLevel;
    document.getElementById('finalTime').textContent = Math.floor(survivalTime);
    document.getElementById('earnedSkillPoints').textContent = upgradePointsEarned;

    let username = getPlayerName();
    submitLocalScore(username, gameState.player.score, gameState.currentLevel);
    submitGlobalScore(username, gameState.player.score);

    // --- PUBBLICIT√Ä GameMonetize ---
    if (typeof sdk !== 'undefined' && typeof sdk.showBanner === 'function') {
        sdk.showBanner();
    }

    showScreen('gameOver');
    updateUI();
}

  function fetchGlobalLeaderboard(callback) {
  const url = "https://dreamlo.com/lb/5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw/pipe";
  fetch(url)
    .then(res => res.text())
    .then(txt => {
      const rows = txt.trim().split('\n');
      const leaderboard = rows
        .map(row => {
          const [name, score] = row.split('|');
          if (!name || isNaN(parseInt(score))) return null;
          return { name, score: parseInt(score) };
        })
        .filter(entry => entry !== null)
        .sort((a, b) => b.score - a.score);
      callback(leaderboard);
    });
}
     
   // --- Quando forfeit, ferma tutto ---
function forfeitMission() {
  gameState.gameRunning = false;
  if (animationId) {
    stopCoopGameLoop();
    cancelAnimationFrame(animationId);
  }
  showScreen('mainMenu');
}

     function restartGame() {
        resetBossVisualState(); // <--- AGGIUNGI QUI!!!

        gameState.gameRunning = false;
    if (animationId) {
        cancelAnimationFrame(animationId);
    }
    showScreen('gameScreen');
}

      function restartCurrentLevel() {
          restartGame();
      }

      function pauseGame() {
          gameState.gamePaused = true;
      }

      function resumeGame() {
          gameState.gamePaused = false;
          gameLoop();
      }

    function render() {
  // Aggiorna lo sfondo animato
  backgroundY += 1;
  if (backgroundY >= canvas.height) backgroundY = 0;

  // Sfondo base
  ctx.fillStyle = '#0a0a2e';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // PATCH: Effetti visivi globali (SHAKE, FLASH, ESPLOSIONI, RIPPLE)
  applyShake(ctx);
  drawFlash(ctx, canvas);
  updateAndDrawExplosions(ctx);
  updateAndDrawRipples(ctx);

  // Sfondo spazio (immagine e/o stelle animate)
  renderSpaceBackground();

  // --- MODALIT√Ä DUEL BOT (1v1 AI) ---
  if (gameState.gameMode === "duelAI") {
    renderPlayer();
    renderDuelBot(ctx);
    renderBullets();
    renderEnemyBullets();
    renderParticles();
    if (gameState.slowTimeActive) renderSlowTimeOverlay();
    endShake(ctx);
    return;
  }

  // --- MODALIT√Ä DUEL 1v1 PLAYER ---
  renderPlayer();
  if (gameState.gameMode === "duel1v1") {
    renderOpponent(ctx);
    if (window.gameState.powerups) renderDuelPowerups(ctx, window.gameState.powerups);
  }
  
  // PATCH: solo player e alleati/avversari in 2v2
  if (gameState.gameMode === "duel2v2") {
    renderPlayer();
    render2v2Players(ctx);
    renderBullets();
    renderParticles();
    return; // NON disegnare boss/ostacoli!
  }
  
  
  // --- MODALIT√Ä CO-OP ---
  else if (gameState.gameMode === "coop") {
    renderOtherPlayers(ctx);
    renderEnemy();
    // Voice indicator su altri giocatori co-op
    for (let id in otherPlayers) {
      renderVoiceIndicator(ctx, otherPlayers[id]);
    }
    // Minimap co-op
    renderCoopMinimap();
  }
  // --- MODALIT√Ä SINGLEPLAYER ---
  else {
    renderEnemy();
  }

  // Ostacoli, proiettili, particelle (sempre)
  renderObstacles();
  renderBullets();
  renderEnemyBullets();
  renderParticles();

  // Overlay slow-time
  if (gameState.slowTimeActive) renderSlowTimeOverlay();

  endShake(ctx);
}
      function renderSpaceBackground() {
          if (backgroundImage.complete) {
              ctx.drawImage(backgroundImage, 0, backgroundY, canvas.width, canvas.height);
              ctx.drawImage(backgroundImage, 0, backgroundY - canvas.height, canvas.width, canvas.height);

              backgroundY += 1;
              if (backgroundY >= canvas.height) backgroundY = 0;
          } else {
              // Fallback: animated stars if image not loaded
              ctx.fillStyle = '#FFF';
              for (let i = 0; i < 100; i++) {
                  const x = (i * 10 + backgroundY * 0.5) % canvas.width;
                  const y = (i * 15 + backgroundY * 0.8) % canvas.height;
                  ctx.fillRect(x, y, 2, 2);
              }
          }
      }

      function renderPlayer() {
  const player = gameState.player;
  let x = player.x, y = player.y;
  if (duelEntryAnimation.active) {
    x = lerp(-100, player.x, duelEntryAnimation.progress);
  }
  renderPlayerTrail(ctx);
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(player.angle);
  if (playerImage.complete) {
    ctx.drawImage(playerImage, -32, -32, 64, 64); 
  } else {
    ctx.fillStyle = '#00bcd4';
    ctx.beginPath();
    ctx.moveTo(0, -20);
    ctx.lineTo(-15, 15);
    ctx.lineTo(15, 15);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

     
 // --- RENDER ALTRI PLAYER ---
function renderOtherPlayers(ctx) {
  console.log("Rendering otherPlayers:", otherPlayers);
    
  for (let id in otherPlayers) {
    if (id === mySocketId) continue;
    const p = otherPlayers[id];
    // Interpolazione verso la posizione target
    if (typeof p.targetX === "number" && typeof p.targetY === "number") {
      p.x += (p.targetX - p.x) * 0.33;
      p.y += (p.targetY - p.y) * 0.33;
    }
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.drawImage(playerImage, p.x - 32, p.y - 32, 64, 64);
    ctx.font = "bold 18px Orbitron";
    ctx.fillStyle = "#ffd700";
    ctx.textAlign = "center";
    ctx.fillText(p.nickname, p.x, p.y - 40);
    ctx.restore();
  }
}

     
     function renderBullets() {
  gameState.bullets.forEach(bullet => {
    ctx.save();
    ctx.translate(bullet.x, bullet.y);
    ctx.rotate(Math.atan2(bullet.vy, bullet.vx));

    // --- DISTINGUI PROIETTILE IN BASE AL TEAM ---
    let isMyTeam = bullet.team === duel2v2Team;
    // Glow: blu per il tuo team, rosso per avversari
    ctx.shadowColor = isMyTeam ? "#00bcd4" : "#f44336";
    ctx.shadowBlur = 18;

    // Cambia sprite se vuoi (opzionale)
    // let sx = isMyTeam ? 0 : 192; // esempio, cambia sprite per team
    let sx = 0, sy = 0, sw = 192, sh = 384;

    // Opzionale: dimensione pi√π grande per il tuo team
    let drawW = isMyTeam ? 34 : 28;
    let drawH = isMyTeam ? 68 : 52;

    // Disegna missile
    ctx.drawImage(missileSprite, sx, sy, sw, sh, -drawW/2, -drawH/2, drawW, drawH);

    // Bordo colorato opzionale
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.arc(0, 0, drawW * 0.55, 0, Math.PI * 2);
    ctx.strokeStyle = isMyTeam ? "#00bcd4" : "#f44336";
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.restore();
  });
}
  
    
      function renderEnemyBullets() {
          gameState.enemyBullets.forEach(bullet => {
              ctx.save();
              
              ctx.fillStyle = bullet.color;
              ctx.beginPath();
              ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
              ctx.fill();
              
              if (bullet.size > 10) {
                  ctx.strokeStyle = '#ffffff';
                  ctx.lineWidth = 2;
                  ctx.beginPath();
                  ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                  ctx.stroke();
                  
                  ctx.globalAlpha = 0.4;
                  ctx.fillStyle = bullet.color;
                  ctx.beginPath();
                  ctx.arc(bullet.x, bullet.y, bullet.size + Math.sin(Date.now() * 0.03) * 4, 0, Math.PI * 2);
                  ctx.fill();
              }
              
              if (bullet.tracking) {
                  ctx.strokeStyle = '#f44336';
                  ctx.lineWidth = 2;
                  ctx.beginPath();
                  ctx.arc(bullet.x, bullet.y, bullet.size + 6, 0, Math.PI * 2);
                  ctx.stroke();
              }
              
              if (bullet.ultimate) {
                  ctx.shadowColor = bullet.color;
                  ctx.shadowBlur = 20;
                  
                  ctx.strokeStyle = '#ffffff';
                  ctx.lineWidth = 4;
                  ctx.beginPath();
                  ctx.arc(bullet.x, bullet.y, bullet.size + 5, 0, Math.PI * 2);
                  ctx.stroke();
              }
              
              ctx.restore();
          });
      }

      function renderParticles() {
          gameState.particles.forEach(particle => {
              ctx.save();
              ctx.globalAlpha = particle.alpha;
              ctx.fillStyle = particle.color;
              ctx.shadowColor = particle.color;
              ctx.shadowBlur = 8;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
          });
      }

      function renderSlowTimeOverlay() {
          ctx.save();
          ctx.globalAlpha = 0.15;
          ctx.fillStyle = '#00bcd4';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          ctx.globalAlpha = 1;
          ctx.fillStyle = '#00bcd4';
          ctx.font = `bold ${Math.min(28, canvas.width * 0.035)}px Orbitron`;
          ctx.textAlign = 'center';
          ctx.fillText('TIME DILATION ACTIVE', canvas.width / 2, 60);
          
          ctx.restore();
      }

         
function updateUI() {
    document.getElementById('currentLevel').textContent = gameState.gameMode === 'endless'
        ? `W${gameState.endlessWave}`
        : gameState.currentLevel;
    document.getElementById('playerLives').textContent = gameState.player.lives;
    document.getElementById('playerEnergy').textContent = Math.floor(gameState.player.energy);
    document.getElementById('playerScore').textContent = gameState.player.score.toLocaleString();
    document.getElementById('coinCount').textContent = gameState.coins;
    
     // PATCH: aggiorna ELO
    document.getElementById('eloPoints').textContent = gameState.elo || 1000;
    
    // Dentro updateUI
const league = getEloLeague(gameState.elo || 1000);
const eloDisplay = document.getElementById('eloDisplay');
eloDisplay.style.borderColor = league.color;
eloDisplay.style.boxShadow = `0 0 12px ${league.color}55`;
eloDisplay.innerHTML =
  `<span style="margin-right:6px;">${league.icon}</span>
   ELO: <span id="eloPoints">${gameState.elo || 1000}</span>
   <span style="font-size:1.05em; font-weight:bold; color:${league.color}; margin-left:10px;">${league.name}</span>`;
    
    
    const playerHealthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
    document.getElementById('playerHealthFill').style.width = Math.max(0, playerHealthPercent) + '%';
    document.getElementById('playerHealthText').textContent =
        `${Math.max(0, Math.floor(gameState.player.health))} / ${gameState.player.maxHealth}`;

    // PATCH: Nascondi SOLO la barra ENEMY in duel1v1, mostra altrove
    const healthBarWrappers = document.querySelectorAll('.health-bar-wrapper');
    healthBarWrappers.forEach(wrapper => {
        // Cerca il div che contiene "ENEMY" come label
        const isEnemyBar = Array.from(wrapper.children).some(child =>
            child.textContent && child.textContent.trim().toUpperCase() === "ENEMY"
        );
        if (isEnemyBar) {
            if (gameState.gameMode === "duel1v1") {
                wrapper.style.display = "none";
            } else {
                wrapper.style.display = "";
            }
        }
    });

    // Gestione barra ENEMY: aggiorna valori solo se visibile
    const enemyHealthFill = document.getElementById('enemyHealthFill');
    const enemyHealthText = document.getElementById('enemyHealthText');
    if (gameState.gameMode === "duel1v1") {
        if (enemyHealthFill) enemyHealthFill.style.width = '0%';
        if (enemyHealthText) enemyHealthText.textContent = '-';
    } else if (
        gameState.enemy &&
        typeof gameState.enemy.health === "number" &&
        typeof gameState.enemy.maxHealth === "number" &&
        !isNaN(gameState.enemy.health) && !isNaN(gameState.enemy.maxHealth)
    ) {
        const enemyHealthPercent = (gameState.enemy.health / gameState.enemy.maxHealth) * 100;
        if (enemyHealthFill) enemyHealthFill.style.width = Math.max(0, enemyHealthPercent) + '%';
        if (enemyHealthText) enemyHealthText.textContent =
            `${Math.max(0, Math.floor(gameState.enemy.health))} / ${gameState.enemy.maxHealth}`;
    } else {
        if (enemyHealthFill) enemyHealthFill.style.width = '0%';
        if (enemyHealthText) enemyHealthText.textContent = '-';
    }

    document.getElementById('energyFill').style.width = gameState.bulletHellIntensity + '%';

    // Mostra bestScore correttamente
    document.getElementById('totalScore').textContent = (gameState.bestScore || 0).toLocaleString();

    // Mostra anche altri dati delle statistiche se vuoi
    const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
    document.getElementById('totalEnemiesDefeated').textContent = savedData.totalEnemiesDefeated || 0;
    document.getElementById('highestLevel').textContent = savedData.highestLevel || 1;
    document.getElementById('skillPoints').textContent = savedData.skillPoints || 0;
    document.getElementById('availableSkillPoints').textContent = savedData.skillPoints || 0;
    document.getElementById('statTotalEnemies').textContent = savedData.totalEnemiesDefeated || 0;
    document.getElementById('statHighestLevel').textContent = savedData.highestLevel || 1;
    document.getElementById('statBestScore').textContent = (savedData.bestScore || 0).toLocaleString();
    document.getElementById('statTotalDeaths').textContent = savedData.totalDeaths || 0;
    document.getElementById('statSurvivalTime').textContent = Math.floor(savedData.longestSurvival || 0);
    document.getElementById('statAchievements').textContent = (savedData.achievements || []).length;

    gameState.skillPoints = savedData.skillPoints || 0;
}

 // Data Management
      function saveGameData() {
  const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
  savedData.controlLayout = gameState.controlLayout; // Save control layout
  savedData.elo = gameState.elo; // <-- AGGIUNGI QUESTA RIGA!
  localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
}

    function loadGameData() {
  const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
  gameState.skillPoints = savedData.skillPoints || 0;
  gameState.player.skills = savedData.skills || {};
  gameState.orientation = savedData.orientation || 'auto';
  gameState.coins = Number(savedData.coins) || 0;
  gameState.bestScore = Number(savedData.bestScore) || 0;
  gameState.elo = savedData.elo || 1000; // <-- AGGIUNGI QUI!
}

  function spawnObstacle() {
  if (!gameState.obstacles) gameState.obstacles = [];
  const types = ["asteroid"];
  const type = types[Math.floor(Math.random() * types.length)];
  const x = Math.random() * canvas.width;
  const size = 32 + Math.random() * 32;

  // PATCH: velocit√† pi√π bassa su mobile
  let vy = 2 + Math.random() * 2;
  if (isMobileDevice()) vy *= 0.55; // circa met√† velocit√† su mobile

  gameState.obstacles.push({
    x: x,
    y: -size,
    vx: (Math.random() - 0.5) * 1.5,
    vy: vy,
    size: size,
    type: type,
    angle: 0,
    spin: (Math.random() - 0.5) * 0.07,
    hit: false,
    // AGGIUNGI QUI:
    health: Math.round(size * 1.2),     // ad esempio vita proporzionale alla dimensione
    maxHealth: Math.round(size * 1.2)
  });
}
    
    function updateObstacles(deltaTime) {
  if (!gameState.obstacles) gameState.obstacles = [];

  // DISABILITA ostacoli in tutte le modalit√† multiplayer
  if (
    gameState.gameMode === "duel1v1" ||
    gameState.gameMode === "duel2v2" ||
    gameState.gameMode === "coop"
  ) return;

  if (isMobileDevice && isMobileDevice()) {
    if (Math.random() < 0.014) spawnObstacle();
  } else {
    if (Math.random() < 0.035) spawnObstacle();
  }

  gameState.obstacles = gameState.obstacles.filter(o => {
    o.x += o.vx * (deltaTime || 1);
    o.y += o.vy * (deltaTime || 1);
    o.angle += o.spin;
    return o.y < canvas.height + 60 && o.x > -80 && o.x < canvas.width + 80 && !o.hit;
  });
}
      
      function resetStats() {
    // RESET DIRETTO senza conferma
    localStorage.removeItem('stellarGuardianSave');
    gameState.currentLevel = 1;
    gameState.skillPoints = 0;
    gameState.player.skills = {};
    gameState.orientation = 'auto';
    gameState.controlLayout = { // Reset control layout to default
        joystick: { left: '20px', bottom: '30px' },
        buttons: { right: '20px', bottom: '30px' }
    };
    applyControlLayout();
    updateUI();
    generateLevelGrid();
    generateSkillTree();
    generateAchievements();
    showNotification('All data reset! Starting fresh.', 'achievement');
}

      // Notification System
      function showNotification(message, type = 'info') {
          const notification = document.createElement('div');
          notification.className = 'notification';
          notification.textContent = message;
          
          if (type === 'achievement') {
              notification.style.background = 'linear-gradient(45deg, #ffd700, #ffeb3b)';
              notification.style.color = '#000';
              notification.style.fontWeight = '700';
          }
          
          document.getElementById('notificationContainer').appendChild(notification);
          
          setTimeout(() => {
              notification.remove();
          }, 5000);
      }

      // Particle System
      function createStellarParticles() {
          const particlesContainer = document.getElementById('particles');
          
          for (let i = 0; i < 30; i++) {
              const particle = document.createElement('div');
              particle.className = 'particle';
              particle.style.left = Math.random() * 100 + '%';
              particle.style.animationDelay = Math.random() * 4 + 's';
              particle.style.animationDuration = (Math.random() * 3 + 4) + 's';
              
              const colors = ['#00bcd4', '#2196f3', '#3f51b5', '#9c27b0', '#ffffff'];
              particle.style.background = colors[Math.floor(Math.random() * colors.length)];
              
              particlesContainer.appendChild(particle);
          }
      }

      // Control Adjustment Feature
      let draggedElement = null;
      let offsetX, offsetY;

      function showControlAdjustment() {
          showScreen('controlAdjustmentOverlay');
          const adjustmentArea = document.getElementById('adjustmentArea');
          adjustmentArea.innerHTML = ''; // Clear previous elements

          const joystick = document.getElementById('mobileJoystick').cloneNode(true);
          joystick.id = 'draggableJoystick';
          joystick.classList.add('draggable-control');
          joystick.style.position = 'absolute'; // Ensure absolute positioning for dragging
          joystick.style.left = gameState.controlLayout.joystick.left;
          joystick.style.bottom = gameState.controlLayout.joystick.bottom;
          joystick.style.top = 'auto'; // Clear top if set
          joystick.style.right = 'auto'; // Clear right if set
          joystick.style.pointerEvents = 'auto'; // Enable pointer events for dragging
          joystick.querySelector('#mobileJoystickKnob').style.transform = 'translate(0,0)'; // Reset knob position

          const actionButtons = document.getElementById('mobileActionButtons').cloneNode(true);
          actionButtons.id = 'draggableActionButtons';
          actionButtons.classList.add('draggable-control');
          actionButtons.style.position = 'absolute'; // Ensure absolute positioning for dragging
          actionButtons.style.right = gameState.controlLayout.buttons.right;
          actionButtons.style.bottom = gameState.controlLayout.buttons.bottom;
          actionButtons.style.top = 'auto'; // Clear top if set
          actionButtons.style.left = 'auto'; // Clear left if set
          actionButtons.style.pointerEvents = 'auto'; // Enable pointer events for dragging

          adjustmentArea.appendChild(joystick);
          adjustmentArea.appendChild(actionButtons);

          setupDrag(joystick);
          setupDrag(actionButtons);
      }

     function setupDrag(element) {
    element.addEventListener('pointerdown', (e) => {
        draggedElement = element;
        draggedElement.classList.add('dragging');
        const rect = draggedElement.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        draggedElement.setPointerCapture(e.pointerId);
        // Attiva pointer events solo durante il drag
        draggedElement.style.pointerEvents = "auto";
    });

    element.addEventListener('pointermove', (e) => {
        if (draggedElement === element) {
            e.preventDefault();
            const adjustmentArea = document.getElementById('adjustmentArea');
            const areaRect = adjustmentArea.getBoundingClientRect();

            let newLeft = e.clientX - offsetX - areaRect.left;
            let newTop = e.clientY - offsetY - areaRect.top;

            newLeft = Math.max(0, Math.min(newLeft, areaRect.width - draggedElement.offsetWidth));
            newTop = Math.max(0, Math.min(newTop, areaRect.height - draggedElement.offsetHeight));

            draggedElement.style.left = `${newLeft}px`;
            draggedElement.style.top = `${newTop}px`;
            draggedElement.style.right = 'auto';
            draggedElement.style.bottom = 'auto';
        }
    });

    element.addEventListener('pointerup', (e) => {
        endDrag(e);
    });
}

// Listener globale: chiudi il drag anche se lasci fuori dal controllo (mobile fix)
window.addEventListener('pointerup', function(e) {
    if (draggedElement) {
        endDrag(e);
    }
});

    function endDrag(e) {
    if (draggedElement) {
        draggedElement.classList.remove('dragging');
        try {
            if (e && e.pointerId !== undefined) draggedElement.releasePointerCapture(e.pointerId);
        } catch (err) {}
        // Dopo il drag, pointer-events none cos√¨ i bottoni sotto sono cliccabili!
        draggedElement.style.pointerEvents = "none";
        draggedElement = null;
    }
}  
      
      function saveControlLayout() {
          const joystick = document.getElementById('draggableJoystick');
          const buttons = document.getElementById('draggableActionButtons');
          const adjustmentArea = document.getElementById('adjustmentArea');
          const areaRect = adjustmentArea.getBoundingClientRect();

          // Calculate positions relative to the bottom/left/right of the adjustment area
          const joystickRect = joystick.getBoundingClientRect();
          const buttonsRect = buttons.getBoundingClientRect();

          gameState.controlLayout.joystick.left = `${(joystickRect.left - areaRect.left)}px`;
          gameState.controlLayout.joystick.bottom = `${(areaRect.height - (joystickRect.top - areaRect.top) - joystickRect.height)}px`;

          gameState.controlLayout.buttons.right = `${(areaRect.width - (buttonsRect.left - areaRect.left) - buttonsRect.width)}px`;
          gameState.controlLayout.buttons.bottom = `${(areaRect.height - (buttonsRect.top - areaRect.top) - buttonsRect.height)}px`;

          saveGameData();
          applyControlLayout(); // Apply the new layout to the actual game controls
          showScreen('controls'); // Go back to controls screen
          showNotification('Control layout saved!', 'info');
      }

      function cancelControlAdjustment() {
          showScreen('controls'); // Just go back to controls screen without saving
      }

      function applyControlLayout() {
          const joystick = document.getElementById('mobileJoystick');
          const buttons = document.getElementById('mobileActionButtons');

          if (joystick && gameState.controlLayout.joystick) {
              joystick.style.left = gameState.controlLayout.joystick.left;
              joystick.style.bottom = gameState.controlLayout.joystick.bottom;
              joystick.style.top = 'auto';
              joystick.style.right = 'auto';
          }
          if (buttons && gameState.controlLayout.buttons) {
              buttons.style.right = gameState.controlLayout.buttons.right;
              buttons.style.bottom = gameState.controlLayout.buttons.bottom;
              buttons.style.top = 'auto';
              buttons.style.left = 'auto';
          }
      }
      function buyShip() {
    const price = 20;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        gameState.player.lives += 1;
        const savedData = JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}');
        savedData.coins = gameState.coins;
        localStorage.setItem('stellarGuardianSave', JSON.stringify(savedData));
        updateUI();
        showNotification('Purchased +1 Ship!', 'info');
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

      
      const musicaGioco = document.getElementById("musicaGioco");
const pulsanteMusica = document.getElementById("pulsanteMusica");

let musicaAttiva = false;

// Funzione per attivare o disattivare la musica
function toggleMusica() {
    if (musicaAttiva) {
        musicaGioco.pause();
        pulsanteMusica.textContent = "üéµ Musica OFF";
    } else {
        musicaGioco.volume = 0.5; // Modifica volume se vuoi
        musicaGioco.play();
        pulsanteMusica.textContent = "üéµ Musica ON";
    }
    musicaAttiva = !musicaAttiva;
}

// Collega la funzione al click del pulsante
pulsanteMusica.addEventListener("click", toggleMusica);
    
      // Initialize Game
      window.addEventListener('load', initGame);
      
 // --- PARTICLE SUPER EXPLOSION + EFFETTI WOW ---

let explosionParticles = [];
let screenShakeTime = 0, screenShakeIntensity = 0;
let flashAlpha = 0;
let ripples = [];

// ESPLOSIONE SUPER COLORATA
function spawnSuperExplosion(x, y, opts = {}) {
  const colors = opts.colors || ["#fff", "#ff0044", "#14fc56", "#00cfff", "#ffd700", "#ff7f00", "#e91e63"];
  const count = Math.min(opts.count || 70, 18); // Max 18 particelle!
  for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 3 + Math.random() * 8;
        const color = colors[Math.floor(Math.random() * colors.length)];
        explosionParticles.push({
            x, y,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            gravity: 0.05 + Math.random() * 0.08,
            size: 7 + Math.random() * 8,
            alpha: 1,
            life: 50 + Math.random() * 25,
            maxLife: 50 + Math.random() * 25,
            color,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.4,
            sparkle: opts.sparkle && Math.random() < 0.3,
            trail: Math.random() < 0.4
        });
    }
}

// ONDA (RIPPLE) effetto shockwave
function spawnRipple(x, y, color = "#fff") {
    ripples.push({ x, y, radius: 0, alpha: 0.45, color });
}

// SHAKE DELLO SCHERMO
function startShake(intensity = 20, duration = 18) {
    screenShakeTime = duration;
    screenShakeIntensity = intensity;
}

// FLASH DELLO SCHERMO
function startFlash(strength = 1) {
    flashAlpha = strength;
}

// UPDATE + DRAW PARTICELLE
function updateAndDrawExplosions(ctx) {
    for (let i = explosionParticles.length - 1; i >= 0; i--) {
        let p = explosionParticles[i];
        if (p.trail) {
            ctx.save();
            ctx.globalAlpha = p.alpha * 0.2;
            ctx.strokeStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        p.x += p.dx;
        p.y += p.dy;
        p.dy += p.gravity;
        p.dx *= 0.96;
        p.dy *= 0.96;
        p.life--;
        p.alpha = Math.max(p.life / p.maxLife, 0);

        ctx.save();
        ctx.globalAlpha = p.alpha;

        let grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
        grad.addColorStop(0, "#fff");
        grad.addColorStop(0.25, p.color);
        grad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = grad;

        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        ctx.beginPath();
        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
        ctx.fill();

        if (p.sparkle) {
            ctx.globalAlpha = p.alpha * 0.7;
            ctx.strokeStyle = "#fff";
            for (let k = 0; k < 6; k++) {
                ctx.save();
                ctx.rotate((Math.PI / 3) * k + (p.life / 10));
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, p.size * 1.8);
                ctx.stroke();
                ctx.restore();
            }
        }

        ctx.restore();
        p.rotation += p.rotationSpeed;

        if (p.life <= 0) explosionParticles.splice(i, 1);
    }
}

// UPDATE + DRAW RIPPLE
function updateAndDrawRipples(ctx) {
    for (let i = ripples.length - 1; i >= 0; i--) {
        let r = ripples[i];
        ctx.save();
        ctx.globalAlpha = r.alpha;
        ctx.strokeStyle = r.color;
        ctx.lineWidth = 4 + r.radius * 0.07;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        r.radius += 12;
        r.alpha -= 0.018;
        if (r.alpha <= 0) ripples.splice(i, 1);
    }
}

// SHAKE LOGIC
function applyShake(ctx) {
    if (screenShakeTime > 0) {
        ctx.save();
        ctx.translate(
            (Math.random() - 0.5) * screenShakeIntensity,
            (Math.random() - 0.5) * screenShakeIntensity
        );
        screenShakeTime--;
        if (screenShakeTime <= 0) screenShakeIntensity = 0;
    }
}
function endShake(ctx) {
    if (screenShakeTime > 0) ctx.restore();
}

// FLASH LOGIC
function drawFlash(ctx, canvas) {
    if (flashAlpha > 0.01) {
        ctx.save();
        ctx.globalAlpha = flashAlpha;
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        flashAlpha *= 0.84;
    }
}

// FUNZIONI PRONTE DA USARE
function esplodiGiocatore(player) {
     playSound('explosion', 0.7);
  
  spawnSuperExplosion(player.x, player.y, {
        colors: ["#00bcd4", "#fff", "#2196f3", "#14fc56"],
        count: 80,
        sparkle: true
    });
    spawnRipple(player.x, player.y, "#00e6ff");
    startShake(18, 22);
    startFlash(0.30);
}

function esplodiBoss(boss) {
playSound('explosion', 0.7);
  
  // Super esplosione centrale
    spawnSuperExplosion(boss.x, boss.y, {
        colors: ["#f00", "#fff", "#ffd700", "#9c27b0", "#ff7f00"],
        count: 140,
        sparkle: true
    });

    // Ripple shockwave
    spawnRipple(boss.x, boss.y, "#ffd700");

    // Mini esplosioni di fuoco attorno al boss (anello di fuochi)
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        const fx = boss.x + Math.cos(angle) * 60;
        const fy = boss.y + Math.sin(angle) * 60;
        spawnSuperExplosion(fx, fy, {
            colors: ["#ff9800", "#ffd700", "#fff"],
            count: 18,
            sparkle: false
        });
    }

    // Fiamme che salgono dal boss
    for (let i = 0; i < 24; i++) {
        gameState.particles.push({
            x: boss.x + (Math.random() - 0.5) * 48,
            y: boss.y + 20 + Math.random() * 12,
            vx: (Math.random() - 0.5) * 2,
            vy: -4 - Math.random() * 3,
            color: ["#ff9800", "#ffd700", "#fff", "#f44336"][Math.floor(Math.random() * 4)],
            size: 8 + Math.random() * 8,
            life: 44 + Math.random() * 28,
            maxLife: 60,
            alpha: 1
        });
    }

    // Shake & flash finale
    startShake(28, 32);
    startFlash(0.5);
}
  
  let playerTrail = [];


const rainbowColors = [
  "#ff0000", // rosso
  "#ff8000", // arancione
  "#ffff00", // giallo
  "#00ff00", // verde
  "#00ffff", // azzurro
  "#0000ff", // blu
  "#8000ff", // viola
  "#ff00ff"  // fucsia
];


  function updatePlayerTrail() {
    playerTrail.push({
        x: gameState.player.x,
        y: gameState.player.y,
        alpha: 0.45
    });
    if (playerTrail.length > 35) playerTrail.shift(); // <-- da 7 a 35!
    for (let t of playerTrail) t.alpha *= 0.95; // meno fading cos√¨ rimane visibile
}



function renderPlayerTrail(ctx) {
    const colors = rainbowColors;
    for (let i = 0; i < playerTrail.length; i++) {
        let t = playerTrail[i];
        ctx.save();
        ctx.globalAlpha = 0.7 * (1 - i / playerTrail.length); // fading lungo la scia
        ctx.fillStyle = colors[i % colors.length];
        ctx.shadowColor = colors[i % colors.length];
        ctx.shadowBlur = 24;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 12 - i/4, 0, Math.PI * 2); // pi√π piccola verso la fine
        ctx.fill();
        ctx.restore();
    }
}
   
  function checkObstacleCollisions() {
    const player = gameState.player;
    gameState.obstacles.forEach(ob => {
        if (ob.hit) return;
        const dx = ob.x - player.x;
        const dy = ob.y - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const hitbox = 24 + ob.size / 2;
        if (dist < hitbox) {
            // PATCH: in co-op segnala al server quale ostacolo hai colpito!
            if (gameState.gameMode === "coop" && socket && ob.id) {
                socket.emit('obstacleHit', ob.id);
            }
            ob.hit = true;
            player.health -= (ob.type === "mine" ? 35 : 20);
            spawnSuperExplosion(ob.x, ob.y, {colors:["#ffe700","#ff9800","#fff"],count:18});
            startShake(14, 10);
        
        
        }
    });
}
 
  
  
function renderObstacles() {
    // PATCH: sempre array!
    const obstacles = Array.isArray(gameState.obstacles) ? gameState.obstacles : [];
    obstacles.forEach(ob => {
        ctx.save();
        ctx.translate(ob.x, ob.y);
        ctx.rotate(ob.angle);
        if (ob.type === "asteroid") {
            ctx.fillStyle = "#bdbdbd";
            ctx.beginPath();
            ctx.arc(0, 0, ob.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#888";
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(
                    Math.cos(i * 2 + ob.angle) * ob.size * 0.23,
                    Math.sin(i * 2 + ob.angle) * ob.size * 0.23,
                    ob.size / 8, 0, Math.PI * 2
                );
                ctx.fill();
            }
        } else if (ob.type === "mine") {
            ctx.fillStyle = "#e91e63";
            ctx.beginPath();
            ctx.arc(0, 0, ob.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "#fff";
            for (let i = 0; i < 8; i++) {
                ctx.save();
                ctx.rotate(Math.PI / 4 * i);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(ob.size / 2, 0);
                ctx.stroke();
                ctx.restore();
            }
        }
        ctx.restore();
    });
}  
  
  
function selectShip(shipId) {
    localStorage.setItem('selectedShip', shipId);
    highlightSelectedShip();
}

  function getSelectedShip() {
    return localStorage.getItem('selectedShip') || 'ship1';
  }

  function highlightSelectedShip() {
    const selectedShip = getSelectedShip();
    document.querySelectorAll('#shipInventory .level-card').forEach(card => {
      card.classList.remove('selected-ship');
      if (card.dataset.shipId === selectedShip) {
        card.classList.add('selected-ship');
      }
    });
  }

  const style = document.createElement('style');
  style.textContent = `.selected-ship {
    border: 4px solid #ffd700;
    box-shadow: 0 0 20px #ffd700;
    transform: scale(1.03);
  }`;
  document.head.appendChild(style);

  document.addEventListener('DOMContentLoaded', highlightSelectedShip);
  
  // Loading phrases & navicelle random
const loadingScreen = document.getElementById('loadingScreen');
const loadingBarFill = document.getElementById('loadingBarFill');
const loadingText = document.getElementById('loadingText');
const loadingPhrases = [
  "Calibrating Hyperdrive...",
  "Loading Cosmic Donuts...",
  "Brushing star dust...",
  "Preparing spaceship for launch...",
  "Loading mischievous enemies...",
  "Compiling galactic memes...",
  "Verifying ship's AI sarcasm level...",
  "Tuning space radio..."
];
const ships = ["navicella1.png", "navicella2.png", "navicella3.png"];
setInterval(() => {
  document.getElementById('loaderShip').src = ships[Math.floor(Math.random() * ships.length)];
}, 900);

function showLoadingScreen(duration = 2200) {
  loadingScreen.style.display = 'flex';
  loadingScreen.classList.remove('hide');
  document.body.classList.add('loading');
  loadingBarFill.style.width = '0%';
  let progress = 0;
  let interval = setInterval(() => {
    progress += Math.random() * 13 + 7;
    if (progress > 100) progress = 100;
    loadingBarFill.style.width = progress + '%';
    if (Math.random() < 0.24)
      loadingText.textContent = loadingPhrases[Math.floor(Math.random() * loadingPhrases.length)];
    if (progress >= 100) {
      clearInterval(interval);
      setTimeout(hideLoadingScreen, 700);
    }
  }, 350);
}

function hideLoadingScreen() {
  loadingScreen.classList.add('hide');
  document.body.classList.remove('loading');
  setTimeout(() => {
    loadingScreen.style.display = 'none';
  }, 700); // deve essere >= della transition
}

// All'avvio mostra loading
window.addEventListener('load', () => {
  showLoadingScreen();
  setTimeout(hideLoadingScreen, 2400);
});
  
  function buyEnergyRefill() {
    const price = 10;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        gameState.player.energy = gameState.player.maxEnergy;
        showNotification('Energy fully restored!', 'info');
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

function buyTemporaryShield() {
    const price = 15;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        gameState.player.emergencyShields += 1;
        showNotification('Temporary shield acquired!', 'info');
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

function buyBulletUpgrade() {
    const price = 30;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        gameState.player.bulletUpgradeTimer = 1200; // 20 sec @ 60fps
        showNotification('Bullets powered up for 20 seconds!', 'info');
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

function buyAutoFire() {
    const price = 25;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        gameState.player.autoFireTimer = 1200; // 20 sec @ 60fps
        showNotification('Auto-fire enabled for 20 seconds!', 'info');
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

function buySpecialAttack() {
    const price = 20;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        gameState.player.specialReady = true;
        showNotification('Special attack ready!', 'info');
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

function buyRandomPowerUp() {
    const price = 12;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        const powerUps = [
            () => { gameState.player.energy = gameState.player.maxEnergy; showNotification('Energy fully restored!', 'info'); },
            () => { gameState.player.health = gameState.player.maxHealth; showNotification('HP fully restored!', 'info'); },
            () => { gameState.player.emergencyShields += 1; showNotification('Temporary shield acquired!', 'info'); },
            () => { gameState.player.lives += 1; showNotification('Extra ship acquired!', 'info'); }
        ];
        powerUps[Math.floor(Math.random() * powerUps.length)]();
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}

function buyShipSkin() {
    const price = 50;
    if (gameState.coins >= price) {
        gameState.coins -= price;
        // Sblocca una skin (implementa la logica di skin come preferisci)
        showNotification('New ship skin unlocked!', 'achievement');
        updateUI();
        localStorage.setItem('stellarGuardianSave', JSON.stringify({...JSON.parse(localStorage.getItem('stellarGuardianSave') || '{}'), coins: gameState.coins }));
    } else {
        showNotification('Not enough coins!', 'info');
    }
}
  
  // --- MODALIT√Ä CAOS TOTALE ---
let chaosTimer = 0;
let currentChaos = null;
const CHAOS_EFFECTS = [
  {
    name: "Controlli Invertiti",
    apply: () => { gameState.chaosInverted = true; showNotification("üåÄ Controlli Invertiti!"); },
    clear: () => { gameState.chaosInverted = false; }
  },
  {
    name: "Proiettili Giganti",
    apply: () => { gameState.chaosBullets = "big"; showNotification("üí£ Proiettili Giganti!"); },
    clear: () => { gameState.chaosBullets = null; }
  },
  {
    name: "Gravit√† Pazza",
    apply: () => { gameState.chaosGravity = true; showNotification("üåå Gravit√† Pazza!"); },
    clear: () => { gameState.chaosGravity = false; }
  },
  {
    name: "Colori Psichedelici",
    apply: () => { document.body.style.filter = "hue-rotate(90deg)"; showNotification("üé® Colori Psichedelici!"); },
    clear: () => { document.body.style.filter = ""; }
  },
  {
    name: "Boss Meme",
    apply: () => { gameState.chaosBossMeme = true; showNotification("üòÇ Boss Meme!"); },
    clear: () => { gameState.chaosBossMeme = false; }
  },
  {
    name: "Energia Infinita",
    apply: () => { gameState.player.energy = 999; showNotification("‚ö° Energia Infinita!"); },
    clear: () => { /* torna normale */ }
  }
];

function startChaosMode() {
  gameState.gameMode = 'chaos';
  showScreen('gameScreen');
  chaosTimer = 0;
  currentChaos = null;
  nextChaosEffect();
}

// Cambia effetto ogni 10 secondi
function updateChaosMode(deltaTime) {
  chaosTimer += deltaTime * 60; // deltaTime √® ~1, quindi 60 frame = 1 secondo
  if (chaosTimer >= 600) { // ogni 10 secondi
    nextChaosEffect();
    chaosTimer = 0;
  }
}

function nextChaosEffect() {
  if (currentChaos !== null) CHAOS_EFFECTS[currentChaos].clear();
  currentChaos = Math.floor(Math.random() * CHAOS_EFFECTS.length);
  CHAOS_EFFECTS[currentChaos].apply();
}
  
 function getPlayerName() {
  let username = localStorage.getItem('playerName');
  if (!username || username.length < 2) username = "NoName";
  return username;
}

function submitLocalScore(username, score, level) {
  const leaderboard = JSON.parse(localStorage.getItem('localLeaderboard') || "[]");
  leaderboard.push({ username, score, level, timestamp: Date.now() });
  leaderboard.sort((a, b) => b.score - a.score); // Ordina per punteggio
  localStorage.setItem('localLeaderboard', JSON.stringify(leaderboard.slice(0, 10))); // Solo top 10
}


function showLocalLeaderboard() {
  showScreen('localLeaderboardScreen');
  const leaderboard = JSON.parse(localStorage.getItem('localLeaderboard') || "[]");
  let html = `<ol style="font-size:1.2rem;">`;
  leaderboard.forEach(item => {
    html += `<li><b>${item.username}</b> ‚Äî <span style="color:#ffd700;">${item.score}</span> (Lvl ${item.level})</li>`;
  });
  if (leaderboard.length === 0) html += "<li>Nessun punteggio ancora!</li>";
  html += `</ol>`;
  document.getElementById('localLeaderboardList').innerHTML = html;
}
  
  function showGlobalLeaderboard() {
  showScreen('globalLeaderboardScreen');
  document.getElementById('globalLeaderboardList').innerHTML = 'Loading...';
  fetchGlobalLeaderboard(leaderboard => {
    let html = '<ol style="font-size:1.2rem;">';
    leaderboard.forEach(entry => {
      html += `<li><b>${entry.name}</b> ‚Äî <span style="color:#ffd700;">${entry.score}</span></li>`;
    });
    if (leaderboard.length === 0) html += "<li>Nessun punteggio ancora!</li>";
    html += '</ol>';
    document.getElementById('globalLeaderboardList').innerHTML = html;
  });
}
  
  // ==== DAILY CHALLENGE: CONFIGURAZIONE ====

const DAILY_CHALLENGES = [
  { name: "1 Life!", desc: "Survive as long as possible with only 1 life", config: { lives: 1, endless: true } },
  { name: "Fastest Ship Only", desc: "Use only the fastest spaceship", config: { ship: "ship3" } },
  { name: "Boss Rush", desc: "Face only bosses from level 5 and up", config: { bossOnly: true } },
  { name: "Blitz", desc: "Score as many points as possible in 60 seconds", config: { timeLimit: 60 } },
  // ...add more challenges!
];

// Calcola challenge del giorno
function getDailyChallengeIndex() {
  const now = new Date();
  const daySeed = now.getFullYear() * 10000 + (now.getMonth() + 1) * 100 + now.getDate();
  return daySeed % DAILY_CHALLENGES.length;
}
function getDailyChallenge() {
  return DAILY_CHALLENGES[getDailyChallengeIndex()];
}

function showDailyChallengeMenu() {
  // Nascondi tutte le schermate
  document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
  document.getElementById('dailyChallengeScreen').classList.add('active');
  gameState.currentScreen = 'dailyChallengeScreen';

  // Mostra challenge del giorno
  const challenge = getDailyChallenge();
  document.getElementById('dailyChallengeDesc').innerHTML = `<b>${challenge.name}</b><br><span>${challenge.desc}</span>`;
  fetchDailyChallengeLeaderboard();
}

function startDailyChallenge() {
  const challenge = getDailyChallenge();

  // Applica regole della challenge
  if (challenge.config.lives) gameState.player.lives = challenge.config.lives;
  if (challenge.config.ship) localStorage.setItem('selectedShip', challenge.config.ship);
  if (challenge.config.endless) gameState.gameMode = 'endless';
  if (challenge.config.bossOnly) gameState.currentLevel = 5;
  if (challenge.config.timeLimit) gameState.dailyTimeLimit = challenge.config.timeLimit;

  gameState.isDailyChallenge = true; // Flag

  showScreen('gameScreen'); // Usa la funzione "vera"!
}

// ==== FINE PARTITA: Salva punteggio ====
function endDailyChallenge(score) {
  const username = getPlayerName();
  saveDailyChallengeScoreLocal(username, score);
  submitDailyChallengeScoreGlobal(username, score);
  // Mostra leaderboard aggiornata!
  fetchDailyChallengeLeaderboard();
}

// ==== LEADERBOARD LOCALE ====
function saveDailyChallengeScoreLocal(username, score) {
  const today = (new Date()).toISOString().slice(0, 10);
  let scores = JSON.parse(localStorage.getItem('dailyChallengeScores') || '{}');
  if (!scores[today]) scores[today] = [];
  scores[today].push({ username, score });
  scores[today].sort((a, b) => b.score - a.score);
  scores[today] = scores[today].slice(0, 10); // top 10
  localStorage.setItem('dailyChallengeScores', JSON.stringify(scores));
}

// ==== LEADERBOARD GLOBALE DREAMLO ====
function getDailyLeaderboardTag() {
  const today = (new Date()).toISOString().slice(0, 10);
  return "daily" + today.replace(/-/g, "");
}

// INVIO PUNTEGGIO GLOBALE
function submitDailyChallengeScoreGlobal(username, score) {
  const tag = getDailyLeaderboardTag();
  const dreamloKey = "5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw"; // <-- la tua KEY Dreamlo
  const url = `https://dreamlo.com/lb/${dreamloKey}/add/${encodeURIComponent(username)}/${score}/${tag}`;
  fetch(url)
    .then(() => console.log("Score inviato a Dreamlo (daily)!"))
    .catch(err => console.error("Dreamlo errore:", err));
}

// SCARICA LEADERBOARD GLOBALE
function fetchDailyChallengeLeaderboard() {
  const tag = getDailyLeaderboardTag();
  const dreamloKey = "5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw";
  const url = `https://dreamlo.com/lb/${dreamloKey}/pipe-get/${tag}`;
  fetch(url)
    .then(res => res.text())
    .then(txt => {
      const rows = txt.trim().split('\n');
      const leaderboard = rows
        .map(row => {
          const [name, score] = row.split('|');
          if (!name || isNaN(parseInt(score))) return null;
          return { name, score: parseInt(score) };
        })
        .filter(entry => entry !== null)
        .sort((a, b) => b.score - a.score)
        .slice(0, 10);
      let html = "<ol style='font-size:1.1rem;'>";
      leaderboard.forEach(entry => {
        html += `<li><b>${entry.name}</b> ‚Äî <span style="color:#ffd700;">${entry.score}</span></li>`;
      });
      if (leaderboard.length === 0) html += "<li>Nessun punteggio ancora!</li>";
      html += "</ol>";
      let el = document.getElementById('dailyLeaderboardList');
      if (el) el.innerHTML = html;
    });
}

// ==== UTILITY ====
// getPlayerName gi√† esistente nel tuo gioco!

// ==== INTEGRAZIONE MENU ====
// Aggiungi nel menu principale:
// <button class="menu-btn" onclick="showDailyChallengeMenu()">üåü Challenge Giornaliera</button>

// ==== NEL GAME LOOP, ALLA FINE DELLA PARTITA ====
// if (gameState.isDailyChallenge) endDailyChallenge(gameState.player.score);
// Ricordati di resettare gameState.isDailyChallenge = false; quando esci dalla modalit√†!

  
function changePlayerName() {
  if (document.getElementById('nicknameInput')) {
    document.getElementById('nicknameInput').focus();
  }
  showNotification('Change your nickname above and press Save.', 'info');
}
  
  function shareScore() {
  let score =
    document.getElementById('finalScore')?.textContent ||
    document.getElementById('victoryScore')?.textContent ||
    0;
  let level =
    document.getElementById('finalLevel')?.textContent ||
    "1";
let shareText = `I scored ${score} points in Stellar Guardian! Can you beat me?`;                                                                                                                                                                                                                                           
let shareUrl = window.location.href;

  if (navigator.share) {
    navigator.share({
      title: "Stellar Guardian",
      text: shareText,
      url: shareUrl
    }).catch(() => {});
  } else {
    // Desktop: popup social
    let tweet = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(shareUrl)}&hashtags=StellarGuardian,arcadegame`;
    let fb = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareUrl)}&quote=${encodeURIComponent(shareText)}`;
    let wa = `https://wa.me/?text=${encodeURIComponent(shareText + ' ' + shareUrl)}`;
    let html = `
      <div id="sharePopup" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#111;padding:2rem;border-radius:18px;z-index:9999;text-align:center;">
        <b style="color:#ffd700;font-size:1.3rem;">Condividi il tuo record!</b><br><br>
        <a href="${tweet}" target="_blank" style="margin:8px;">üê¶ Twitter</a>
        <a href="${fb}" target="_blank" style="margin:8px;">üìò Facebook</a>
        <a href="${wa}" target="_blank" style="margin:8px;">üü¢ WhatsApp</a><br><br>
        <button onclick="document.getElementById('sharePopup').remove();" class="menu-btn">Chiudi</button>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', html);
  }
}

function copyScoreLink() {
  let score =
    document.getElementById('finalScore')?.textContent ||
    document.getElementById('victoryScore')?.textContent ||
    0;
  let shareText = `Ho fatto ${score} punti a Stellar Guardian! Gioca anche tu: ${window.location.href}`;
  navigator.clipboard.writeText(shareText).then(() => {
    showNotification('Link copiato negli appunti!', 'info');
  });
}
  
// --- CO-OP MULTIPLAYER REALTIME ---

// Variabili globali
let socket = null;
let mySocketId = null;
let otherPlayers = {}; // id: { x, y, nickname, angle, targetX, targetY, lastUpdate }
let coopPlayers = [];
let coopPositionInterval = null;
let voiceChatActive = false;
let playerVoiceStatus = {}; // socketId: true/false

function showCoopLobby() {
  showScreen('coopLobby');
if (!socket) {
  socket = io(SERVER_URL);
}
  setupBossListener();

  // --- PATCH: Chat multiplayer, sempre aggiungi il listener qui! ---
  if (socket) {
    if (typeof socket.off === "function") socket.off('chatMessage');
    socket.on('chatMessage', addChatMessage);
  }

  // Eventi multiplayer co-op
  if (socket) {
    if (typeof socket.off === "function") socket.off('spawnBullet');
    socket.on('spawnBullet', data => {
      gameState.bullets.push(data);
    });
  }

  if (socket) {
    socket.on('obstaclesUpdate', obstacles => {
      if (gameState.gameMode === "coop") {
        gameState.obstacles = obstacles;
      }
    });
  }

  if (socket) {
    if (typeof socket.off === "function") socket.off('bossAttack');
    socket.on('bossAttack', data => {
      if (gameState.gameMode === "coop") {
        executeBossAttackFromServer(data);
      }
    });
  }

  // Pulizia listener precedenti
  if (typeof socket.off === "function") {
    socket.off('connect');
    socket.off('lobbyUpdate');
    socket.off('gameStart');
    socket.off('bossDefeated');
    socket.off('otherPlayers');
    socket.off('webrtc-offer');
  }

  // Connessione
  socket.on('connect', () => {
    mySocketId = socket.id;
    console.log("Connected, socket id:", mySocketId);
  });

  // Aggiornamento lobby
  socket.on('lobbyUpdate', data => {
    console.log("Lobby update:", data);
    renderCoopPlayers(data);
  });

  // Avvio partita co-op
  socket.on('gameStart', data => startCoopRaidGame(data));

  // Boss sconfitto
  socket.on('bossDefeated', coopVictory);

  // PATCH universale: aggiorna e pulisci la lista otherPlayers in modo atomico e sempre corretto
  socket.on('otherPlayers', data => {
    // Rimuovi giocatori non pi√π presenti
    Object.keys(otherPlayers).forEach(id => {
      if (!data.players.find(p => p.id === id)) delete otherPlayers[id];
    });
    // Aggiorna o aggiungi ogni player ricevuto
    data.players.forEach(p => {
      if (p.id === mySocketId) return;
      if (!otherPlayers[p.id]) {
        otherPlayers[p.id] = { x: p.x, y: p.y, nickname: p.nickname, angle: p.angle || 0 };
      }
      otherPlayers[p.id].targetX = p.x;
      otherPlayers[p.id].targetY = p.y;
      otherPlayers[p.id].nickname = p.nickname;
      otherPlayers[p.id].angle = p.angle || 0;
      otherPlayers[p.id].lastUpdate = Date.now();
    });
  });

  if (socket) {
    socket.on('voiceActive', data => {
      playerVoiceStatus[data.id] = data.active;
      renderCoopPlayers({players: coopPlayers}); // aggiorna la lista
    });
  }

  // --- WebRTC OFFER LISTENER QUI ---
  socket.on('webrtc-offer', data => {
    let pc = peerConnections[data.fromId] || new RTCPeerConnection({
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        {
          urls: "turn:openrelay.metered.ca:80",
          username: "openrelayproject",
          credential: "openrelayproject"
        }
      ]
    });
    peerConnections[data.fromId] = pc;

    // --- LOG STATO ICE E CONNECTION ---
    pc.oniceconnectionstatechange = () => {
      console.log(`[WebRTC ${data.fromId}] ICE state:`, pc.iceConnectionState);
    };
    pc.onicecandidateerror = e => {
      console.error(`[WebRTC ${data.fromId}] ICE candidate error:`, e);
    };
    pc.onconnectionstatechange = () => {
      console.log(`[WebRTC ${data.fromId}] Connection state:`, pc.connectionState);
    };

    pc.onicecandidate = e => {
      if (e.candidate) socket.emit('webrtc-ice', { targetId: data.fromId, candidate: e.candidate });
    };
    pc.ontrack = e => {
      let audio = document.createElement('audio');
      audio.srcObject = e.streams[0];
      audio.autoplay = true;
      audio.controls = false;
      audio.muted = false;
      audio.volume = 1.0;
      audio.style.display = 'none';
      document.body.appendChild(audio);
      // Log
      console.log(`[WebRTC ${data.fromId}] Audio track received`);
      audio.play().catch(err => console.log("Audio play error", err));
    };

    pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
    if (localStream) localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
    pc.createAnswer().then(answer => {
      pc.setLocalDescription(answer);
      socket.emit('webrtc-answer', { targetId: data.fromId, sdp: answer });
    });
  });

  // Entro nella lobby (join)
  socket.emit('joinLobby', { nickname: getPlayerName() });
}

// Sostituisci renderCoopPlayers con questa versione:
function renderCoopPlayers(data) {
  coopPlayers = data.players;
  let html = '<b>Giocatori connessi:</b><ul>';
  
  data.players.forEach(p => {
    const voiceIcon = playerVoiceStatus[p.id] ? " üé§" : "";
    const readyIcon = p.ready ? " ‚úÖ" : " ‚è≥";
    const roleIcon = getRoleIcon(p.role);
    
    html += `<li>
      ${roleIcon} ${p.nickname}${voiceIcon}${readyIcon}
      <span style="color:#ffd700;">[${p.wins || 0} wins]</span>
    </li>`;
  });
  
  html += '</ul>';
  
  // Aggiungi selezione ruolo
  if (data.players.length >= 2) {
    html += `
      <div style="margin-top:1rem;">
        <b>Scegli il tuo ruolo:</b><br>
        <button class="menu-btn" onclick="selectCoopRole('tank')">üõ°Ô∏è Tank</button>
        <button class="menu-btn" onclick="selectCoopRole('healer')">üíö Healer</button>
        <button class="menu-btn" onclick="selectCoopRole('dps')">‚öîÔ∏è DPS</button>
        <button class="menu-btn" onclick="selectCoopRole('support')">‚ú® Support</button>
      </div>
    `;
  }
  
  // Pulsante ready
  html += `
    <button class="menu-btn primary" onclick="toggleReady()" style="margin-top:1rem;">
      ${myReady ? '‚ùå Not Ready' : '‚úÖ Ready'}
    </button>
  `;
  
  document.getElementById('coopPlayersList').innerHTML = html;
}

function getRoleIcon(role) {
  const icons = {
    tank: 'üõ°Ô∏è',
    healer: 'üíö',
    dps: '‚öîÔ∏è',
    support: '‚ú®'
  };
  return icons[role] || 'üë§';
}

let myReady = false;
function toggleReady() {
  myReady = !myReady;
  socket.emit('playerReady', { ready: myReady });
}

function startCoopRaid() {
  if (socket) socket.emit('startCoopRaid');
}

function startCoopRaidGame(data) {
   gameState.player.reviveCount = 0; // Resetta le resurrezioni
  gameState.player.maxRevives = 1;  // (opzionale, se vuoi forzare il limite ogni partita)
  resetBossVisualState(); // <--- AGGIUNGI QUESTA RIGA!!!
  gameState.currentLevel = 20;
  initializeCampaignEnemy();
  gameState.enemy.health = data.boss.health;
  gameState.enemy.maxHealth = data.boss.maxHealth;
  gameState.enemy.x = data.boss.x || gameState.enemy.x;
  gameState.enemy.y = data.boss.y || gameState.enemy.y;
  gameState.enemy.angle = data.boss.angle || 0;
  coopPlayers = data.players;
  gameState.gameMode = 'coop';
  gameState.currentScreen = 'gameScreen';
  showScreen('gameScreen');
  startCoopGameLoop();
}

function coopVictory() {
  showNotification("BOSS SCONFITTO! RAID CO-OP COMPLETATO!", "achievement");
  showScreen('victory');
}

function coopShootBoss(damage) {
  if (socket) socket.emit('bossDamage', { damage });
}

// --- GAMELOOP CO-OP ---
function startCoopGameLoop() {
  if (coopPositionInterval) clearInterval(coopPositionInterval);
  coopPositionInterval = setInterval(sendMyPosition, 40); // invia posizione ogni 40ms

  function coopLoop() {
    updatePlayer(1);
    updatePlayerTrail();
    updateObstacles();
    // Non aggiornare la posizione del boss localmente! (solo render e attacchi, la posizione arriva da server)
    updateBullets(1);
    updateEnemyBullets(1);
    updateParticles(1);
    updateSlowTime();
    updateAdaptiveDifficulty();
    updateScreenShake();
    checkCollisionsCoop();
    render();
    renderBossBar(); // <---- AGGIUNGI QUI!
      renderCoopMinimap(); // <-- NUOVO

      // Aggiungi questi check
  checkTeamCombo();
  tryReviveTeammate();
  playerDown();
    
    
      // Render indicatori voice
  for (let id in otherPlayers) {
    renderVoiceIndicator(ctx, otherPlayers[id]);
  }
    
    
      if (gameState.currentScreen === 'gameScreen' && gameState.gameMode === 'coop')
      requestAnimationFrame(coopLoop);
  }
  coopLoop();
}

function stopCoopGameLoop() {
  if (coopPositionInterval) clearInterval(coopPositionInterval);
  coopPositionInterval = null;
}

function sendMyPosition() {
  if (socket && gameState.gameMode === "coop") {
    socket.emit('playerMove', {
      x: gameState.player.x,
      y: gameState.player.y,
      angle: gameState.player.angle,
      nickname: getPlayerName(),
      // PATCH: sincronizza stato vitale
      health: gameState.player.health,
      maxHealth: gameState.player.maxHealth,
      energy: gameState.player.energy,
      maxEnergy: gameState.player.maxEnergy,
      lives: gameState.player.lives
    });
  }
}

function checkCollisionsCoop() {
  for (let i = gameState.bullets.length - 1; i >= 0; i--) {
    const bullet = gameState.bullets[i];
    const boss = gameState.enemy;
    if (!boss) continue;
    const dist = Math.sqrt(Math.pow(bullet.x - boss.x, 2) + Math.pow(bullet.y - boss.y, 2));
    if (dist < 60) {
      // Solo il proprietario manda il danno!
      if (bullet.owner === mySocketId) {
        coopShootBoss(bullet.damage);
      }
      createHitParticles(bullet.x, bullet.y, bullet.color);
      gameState.bullets.splice(i, 1);
      updateUI();
    }
  }
}
 
// === PATCH: Boss co-op, barra vita fluida e funzionante ===

// 1. Variabili globali
let bossTarget = { x: null, y: null, angle: null };
let bossServerHealth = null;     // <-- LA VERA health ricevuta dal server!
let bossMaxHealth = null;        // <-- La maxHealth del boss dal server!
let bossVisualHealth = null;     // <-- Per l'interpolazione fluida della barra
let lastFrameTime = performance.now();

function resetBossVisualState() {
  bossVisualHealth = null;
  bossServerHealth = null;
  bossMaxHealth = null;
  bossTarget = { x: null, y: null, angle: null };
}


function setupBossListener() {
  if (!socket) return;
  socket.off?.('bossUpdate');
  socket.on('bossUpdate', data => {
    bossServerHealth = data.health;
    bossMaxHealth = data.maxHealth;
    if (bossVisualHealth === null) bossVisualHealth = bossServerHealth;
    // PATCH: salva bersaglio di posizione boss
    bossTarget.x = data.x;
    bossTarget.y = data.y;
    bossTarget.angle = data.angle;
  });
}

function interpolateBoss() {
  if (
    gameState.gameMode === "coop" &&
    gameState.enemy &&
    bossTarget.x !== null &&
    bossTarget.y !== null
  ) {
    // Interpolazione fluida
    gameState.enemy.x += (bossTarget.x - gameState.enemy.x) * 0.13;
    gameState.enemy.y += (bossTarget.y - gameState.enemy.y) * 0.13;
    if (bossTarget.angle !== null) {
      gameState.enemy.angle += (bossTarget.angle - gameState.enemy.angle) * 0.18;
    }
  }
}

function interpolateBossHealth() {
  if (
    gameState.gameMode === "coop" &&
    gameState.enemy &&
    typeof gameState.enemy.targetHealth === "number"
  ) {
    if (bossVisualHealth === null) bossVisualHealth = gameState.enemy.targetHealth;
    bossVisualHealth += (gameState.enemy.targetHealth - bossVisualHealth) * 0.18;
    if (Math.abs(bossVisualHealth - gameState.enemy.targetHealth) < 1) {
      bossVisualHealth = gameState.enemy.targetHealth;
    }
    console.log("interpolateBossHealth:", bossVisualHealth, "/", gameState.enemy.maxHealth); // <--- LOG
    const percent = Math.max(0, bossVisualHealth) / gameState.enemy.maxHealth * 100;
    document.getElementById('enemyHealthFill').style.width = percent + '%';
    document.getElementById('enemyHealthText').textContent = `${Math.max(0, Math.floor(bossVisualHealth))} / ${gameState.enemy.maxHealth}`;
  }
}

// 5. CoopLoop con deltaTime e patch smooth
function startCoopGameLoop() {
  if (coopPositionInterval) clearInterval(coopPositionInterval);
  coopPositionInterval = setInterval(sendMyPosition, 40);
  lastFrameTime = performance.now();

  function coopLoop() {
    let now = performance.now();
    let rawDelta = (now - lastFrameTime) / 16.67;
    lastFrameTime = now;

    // Ignora deltaTime enorme (tab inattiva o lag browser)
    let deltaTime = (rawDelta > 2.5 || rawDelta < 0.2) ? 1 : rawDelta;
    // Limita deltaTime tra 0.7 e 1.5 (evita scatti e rallentamenti)
    deltaTime = Math.max(0.7, Math.min(deltaTime, 1.5));

    updatePlayer(deltaTime);
    updatePlayerTrail();
    updateObstacles(deltaTime);
    updateBullets(deltaTime);
    updateEnemyBullets(deltaTime);
    updateParticles(deltaTime);
    updateSlowTime();
    updateAdaptiveDifficulty();
    updateScreenShake();
    checkCollisionsCoop();
    interpolateBoss();
    interpolateBossHealth();
    render();
    
        tryReviveTeammate(); // <--- aggiungi qui!

    
    
    if (gameState.currentScreen === 'gameScreen' && gameState.gameMode === 'coop')
      requestAnimationFrame(coopLoop);
  }
  coopLoop();
}

// 6. Assicurati che checkCollisionsCoop chiami coopShootBoss(damage) e socket sia inizializzato

// --- FINE PATCH ---
  
 let localStream = null;
let peerConnections = {};

function startVoiceChat() {
  navigator.mediaDevices.getUserMedia({ audio: true })
    .then(stream => {
      localStream = stream;
      coopPlayers.forEach(p => {
        if (p.id === mySocketId) return;
        setupPeerVoice(p.id);
      });
      showNotification('Chat vocale attivata! Microfono collegato.', 'info');
    })
    .catch(() => showNotification('Impossibile accedere al microfono.', 'info'));
}

function setupPeerVoice(peerId) {
  const pc = new RTCPeerConnection({ 
    iceServers: [
      { urls: "stun:stun.l.google.com:19302" },
      {
        urls: "turn:openrelay.metered.ca:80",
        username: "openrelayproject",
        credential: "openrelayproject"
      }
    ]
  });  
  peerConnections[peerId] = pc;
  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

  // --- LOG STATO ICE E CONNECTION ---
  pc.oniceconnectionstatechange = () => {
    console.log(`[WebRTC ${peerId}] ICE state:`, pc.iceConnectionState);
  };
  pc.onicecandidateerror = e => {
    console.error(`[WebRTC ${peerId}] ICE candidate error:`, e);
  };
  pc.onconnectionstatechange = () => {
    console.log(`[WebRTC ${peerId}] Connection state:`, pc.connectionState);
  };

  pc.onicecandidate = e => {
    if (e.candidate) socket.emit('webrtc-ice', { targetId: peerId, candidate: e.candidate });
  };
  pc.ontrack = e => {
    let audio = document.createElement('audio');
    audio.srcObject = e.streams[0];
    audio.autoplay = true;
    audio.controls = false;
    audio.style.display = 'none';
    audio.muted = false;
    audio.volume = 1.0;
    document.body.appendChild(audio);
    // Log
    console.log(`[WebRTC ${peerId}] Audio track received`);
    // Forza play (debug autoplay block)
    audio.play().catch(err => console.log("Audio play error", err));
  };
  pc.createOffer().then(offer => {
    pc.setLocalDescription(offer);
    socket.emit('webrtc-offer', { targetId: peerId, sdp: offer });
  });
}
  
  
// SOSTITUISCI CON:
function filterBadWords(text) {
  const badWords = ['fuck', 'shit', 'ass', 'dick', 'cock', 'pussy', 'nigger', 'faggot'];
  let filtered = text;
  badWords.forEach(word => {
    const regex = new RegExp(word, 'gi');
    filtered = filtered.replace(regex, '***');
  });
  return filtered.substring(0, 15);
}

function savePlayerName() {
  let val = document.getElementById('nicknameInput').value.trim();
  val = filterBadWords(val); // FILTRA PAROLACCE
  if (val.length >= 2) {
    localStorage.setItem('playerName', val);
    showNotification('Nickname updated!', 'info');
  } else {
    showNotification('Nickname too short!', 'info');
  }
}
  
  window.addEventListener('DOMContentLoaded', () => {
  if (document.getElementById('nicknameInput'))
    document.getElementById('nicknameInput').value = localStorage.getItem('playerName') || '';
});
  
  
function isDevEnv() {
  return false;
}

function showAdAndStartGame() {
  // Salta tutto se sei in sviluppo/locale!
  if (isDevEnv()) {
    console.log("DEV: saltata pubblicit√†, avvio diretto.");
    startGame(true);
    return;
  }

  // GameMonetize fallback
  if (typeof sdk !== 'undefined' && typeof sdk.showAd === 'function') {
    sdk.showAd();
    window.levelTimeout = setTimeout(() => startGame(true), 2000);
    return;
  }
  // Nessuna ad, avvia subito
  startGame(true);
}
  
  
function showScreen(screenId) {
    console.log("showScreen chiamata con:", screenId);
    
    if (screenId === 'mobileCustomizationMenu') {
  loadMobileSettings();
}
    
    
     if (screenId === 'gameScreen') {
    document.body.classList.add('in-game');
  } else {
    document.body.classList.remove('in-game');
  }
    
    // Cancella eventuali timeout attivi per evitare salti di livello
    if (window.levelTimeout) {
        clearTimeout(window.levelTimeout);
        window.levelTimeout = null;
    }

    // Disattiva tutte le schermate
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('active');
    });

    // Attiva la schermata scelta, se esiste
    const screenElem = document.getElementById(screenId);
    if (screenElem) {
        screenElem.classList.add('active');
        gameState.currentScreen = screenId;
    } else {
        console.warn("Schermata non trovata:", screenId);
        return;
    }

    // Mobile controls
    const mobileControls = document.getElementById('mobileControls');
    if (mobileControls) {
        if (screenId === 'gameScreen' && gameState.isMobile) {
            mobileControls.classList.add('active');
        } else {
            mobileControls.classList.remove('active');
        }
    }

    // Gestione logica specifica per schermate
    if (screenId === 'gameScreen') {
        // PATCH: se pendingStart √® true, NON fare showAdAndStartGame()
        if (!gameState.gameRunning && !gameState.pendingStart) {
            showAdAndStartGame(); // Mostra adv, poi avvia partita
        } else if (gameState.gameRunning) {
            resumeGame();
        }
    } else {
        if (gameState.gameRunning) {
            pauseGame();
        }
    }

     // PATCH: Bottone special solo in 1v1
  setTimeout(() => {
    const btn = document.getElementById('specialAbilityBtn');
    if (screenId === 'gameScreen' && gameState.gameMode === 'duel1v1') {
      if (!btn) {
        const newBtn = document.createElement('button');
        newBtn.id = 'specialAbilityBtn';
        newBtn.className = 'menu-btn special';
        newBtn.style.position = 'fixed';
        newBtn.style.right = '38px';
        newBtn.style.bottom = '130px';
        newBtn.style.zIndex = 9010;
        newBtn.innerHTML = 'üåü Activate Special';
        newBtn.onclick = function(){
          activateSpecialAbility();
        };
        document.body.appendChild(newBtn);
      } else {
        btn.style.display = 'block';
      }
    } else if (btn) {
      btn.style.display = 'none';
    }
  }, 50);
    
    
    if (screenId === 'gameScreen') {
    setTimeout(() => {
        if (typeof resizeCanvas === "function") resizeCanvas();
    }, 80);
}
    
    
    // RICHIAMA INVENTARIO NAVICELLE OGNI VOLTA CHE ENTRI NELLA SCHERMATA
    if (screenId === 'inventoryScreen') {
        if (typeof generaInventarioNavicelle === 'function') {
            generaInventarioNavicelle();
        }
    }
}


function renderBossBar() {
  if (bossServerHealth === null || bossMaxHealth === null) return;
  if (bossVisualHealth === null) bossVisualHealth = bossServerHealth;
  // Interpolazione fluida (pi√π reattiva = 0.4)
  bossVisualHealth += (bossServerHealth - bossVisualHealth) * 0.4;
  if (Math.abs(bossVisualHealth - bossServerHealth) < 0.7) bossVisualHealth = bossServerHealth;
  // Aggiorna barra
  const percent = Math.max(0, bossVisualHealth) / bossMaxHealth * 100;
  document.getElementById('enemyHealthFill').style.width = percent + '%';
  document.getElementById('enemyHealthText').textContent =
    `${Math.max(0, Math.floor(bossVisualHealth))} / ${bossMaxHealth}`;
}
 
  // Esegui il pattern proiettili boss in co-op, chiamata dal server
function executeBossAttackFromServer({ pattern, x, y }) {
  // Usa i dati del livello 20 come riferimento per il raid co-op
  const levelData = LEVEL_DATA[19] || LEVEL_DATA[0];
  const bulletSpeed = levelData.bulletSpeed || 4;
  const bulletCount = 3.5; // Puoi regolare per pi√π difficolt√†

  switch (pattern) {
    case 'basic':
      for (let i = 0; i < Math.floor(3 * bulletCount); i++) {
        gameState.enemyBullets.push({
          x: x + (i - 1) * 30,
          y: y + 50,
         vx: (i - 1) * 0.5 * 0.65, // rallentato
vy: bulletSpeed * 0.65,    // rallentato
          color: '#f44336',
          size: 5,
          damage: 15
        });
      }
      break;
    case 'spread':
      const spreadCount = Math.floor(5 * bulletCount);
      for (let i = 0; i < spreadCount; i++) {
        const angle = (i / spreadCount) * Math.PI - Math.PI / 2;
        gameState.enemyBullets.push({
          x: x,
          y: y + 50,
          vx: Math.cos(angle) * bulletSpeed,
          vy: Math.sin(angle) * bulletSpeed + 2,
          color: '#e91e63',
          size: 6,
          damage: 12
        });
      }
      break;
    case 'tracking':
      const dx = gameState.player.x - x;
      const dy = gameState.player.y - y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      for (let i = 0; i < Math.floor(2 * bulletCount); i++) {
        gameState.enemyBullets.push({
          x: x,
          y: y + 50,
          vx: (dx / dist) * bulletSpeed + (Math.random() - 0.5) * 1,
          vy: (dy / dist) * bulletSpeed + (Math.random() - 0.5) * 1,
          color: '#9c27b0',
          size: 10,
          damage: 18,
          tracking: true,
          trackingStrength: 0.03
        });
      }
      break;
    case 'laser':
      for (let i = 0; i < 15; i++) {
        gameState.enemyBullets.push({
          x: x,
          y: y + 50 + i * 12,
          vx: 0,
          vy: bulletSpeed * 1.5,
          color: '#ff9800',
          size: 12,
          damage: 20
        });
      }
      break;
    case 'wave':
      for (let i = 0; i < Math.floor(8 * bulletCount); i++) {
        const angle = (i / 8) * Math.PI * 2;
        gameState.enemyBullets.push({
          x: x,
          y: y + 50,
          vx: Math.cos(angle) * 2,
          vy: Math.sin(angle) * 2 + bulletSpeed,
          color: '#673ab7',
          size: 8,
          damage: 15,
          wave: true,
          waveOffset: i * 0.5
        });
      }
      break;
    case 'swarm':
      for (let i = 0; i < Math.floor(12 * bulletCount); i++) {
        gameState.enemyBullets.push({
          x: x + (Math.random() - 0.5) * 100,
          y: y + 30,
          vx: (Math.random() - 0.5) * 4,
          vy: bulletSpeed * 0.8,
          color: '#3f51b5',
          size: 6,
          damage: 10
        });
      }
      break;
    case 'spiral':
      const spiralCount = Math.floor(10 * bulletCount);
      for (let i = 0; i < spiralCount; i++) {
        const angle = (i / spiralCount) * Math.PI * 4 + (Date.now() * 0.01);
        gameState.enemyBullets.push({
          x: x,
          y: y + 50,
          vx: Math.cos(angle) * 3,
          vy: Math.sin(angle) * 3 + bulletSpeed,
          color: '#2196f3',
          size: 7,
          damage: 14
        });
      }
      break;
    case 'chaos':
      for (let i = 0; i < Math.floor(15 * bulletCount); i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 2;
        gameState.enemyBullets.push({
          x: x,
          y: y + 50,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed + 1,
          color: '#00bcd4',
          size: Math.random() * 8 + 4,
          damage: 16
        });
      }
      break;
    case 'ultimate':
      for (let i = 0; i < Math.floor(20 * bulletCount); i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 6 + 3;
        gameState.enemyBullets.push({
          x: x,
          y: y + 50,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          color: '#ffd700',
          size: 15,
          damage: 25,
          ultimate: true
        });
      }
      break;
  }
  gameState.bulletHellIntensity = Math.min(100, gameState.bulletHellIntensity + 2);
}
  
  
  function fetchCoopLeaderboard(callback) {
  const dreamloKey = "5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw"; // tua public key Dreamlo
  const tag = "coopraid"; // scegli un tag chiaro!
  const url = `https://dreamlo.com/lb/${dreamloKey}/pipe-get/${tag}`;
  fetch(url)
    .then(res => res.text())
    .then(txt => {
      const rows = txt.trim().split('\n');
      const leaderboard = rows
        .map(row => {
          const [team, score] = row.split('|');
          if (!team || isNaN(parseInt(score))) return null;
          return { team, score: parseInt(score) };
        })
        .filter(entry => entry !== null)
        .sort((a, b) => b.score - a.score);
      callback(leaderboard);
    });
}
  
  function showCoopLeaderboard() {
  showScreen('coopLeaderboardScreen');
  document.getElementById('coopLeaderboardList').innerHTML = 'Loading...';
  fetchCoopLeaderboard(leaderboard => {
    let html = '<ol style="font-size:1.2rem;">';
    leaderboard.forEach(entry => {
      html += `<li><b>${entry.team.replace(/_/g, " / ")}</b> ‚Äî <span style="color:#ffd700;">${entry.score}</span></li>`;
    });
    if (leaderboard.length === 0) html += "<li>No team scores yet!</li>";
    html += '</ol>';
    document.getElementById('coopLeaderboardList').innerHTML = html;
  });
}
  
 
 // 1. Funzione per controllare se √® estate
function isSummerEventActive() {
  const now = new Date();
  const month = now.getMonth() + 1;
  return month >= 6 && month <= 8; // giugno, luglio, agosto
}
 
 
 function generaInventarioNavicelle() {
  const ships = [
    { id: "ship1", src: "navicella1.png", boss: "Falcon X", difficulty: "Agile & Fast" },
    { id: "ship2", src: "navicella2.png", boss: "Titan Omega", difficulty: "Heavy Armor" },
    { id: "ship3", src: "navicella3.png", boss: "Blue Star", difficulty: "Ultra Fast" },
    { id: "ship4", src: "navicella4.png", boss: "Pixel Blue", difficulty: "Retro Pixel" }
  ];
  // Skin estiva evento
  if (isSummerEventActive()) {
    ships.push({ id: "summer", src: "navicella-summer.png", boss: "Sunrider", difficulty: "üåû Summer 2025 (Evento!)" });
  }
  const inventoryDiv = document.getElementById('shipInventory');
  inventoryDiv.innerHTML = '';
  ships.forEach(ship => {
    const card = document.createElement('div');
    card.className = 'level-card';
    card.dataset.shipId = ship.id;
    card.onclick = () => selectShip(ship.id);
    card.innerHTML = `
      <img src="${ship.src}" class="ship-image" />
      <div class="level-boss">${ship.boss}</div>
      <div class="level-difficulty">${ship.difficulty}</div>
    `;
    inventoryDiv.appendChild(card);
  });
  highlightSelectedShip();
}
 
 
// === PATCH MOBILE: AIM ASSIST SOLO, SENZA AUTO-FIRE ===

// 1. Forza landscape su mobile all'avvio
window.addEventListener('DOMContentLoaded', function() {
  if (/Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    if (typeof setOrientation === "function") setOrientation('landscape');
    const selector = document.getElementById('orientationSelector');
    if (selector) selector.style.display = 'none';
  }
});


function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Opera Mobi|Mobile|Silk|Kindle|Windows Phone|PlayBook|BB10|webOS|Mobile Safari|Fennec/i
    .test(navigator.userAgent)
    || ("ontouchstart" in window && screen.width < 900);
}
 
 // === PATCH: Popup suggerimento landscape su mobile ===

// 1. Crea l'elemento popup in HTML (lo inserisce via JS all'avvio)
function createOrientationAdvicePopup() {
  if (document.getElementById('orientationAdvicePopup')) return; // gi√† presente

  const popup = document.createElement('div');
  popup.id = 'orientationAdvicePopup';
  popup.style.position = 'fixed';
  popup.style.top = '50%';
  popup.style.left = '50%';
  popup.style.transform = 'translate(-50%, -50%)';
  popup.style.background = 'linear-gradient(45deg, #00bcd4, #2196f3)';
  popup.style.color = '#fff';
  popup.style.padding = '2rem 2.5rem';
  popup.style.borderRadius = '22px';
  popup.style.boxShadow = '0 0 40px #00bcd488';
  popup.style.zIndex = 99999;
  popup.style.fontSize = '1.3rem';
  popup.style.textAlign = 'center';
  popup.style.display = 'none';
  popup.innerHTML = `
    <div style="font-size:2.3rem;margin-bottom:0.5em;">üîÑ</div>
    <b>Rotate your phone horizontally<br>for the best experience!</b>
    <div style="margin-top:1em;"><button onclick="document.getElementById('orientationAdvicePopup').style.display='none'" style="margin-top:0.5em;padding:0.6em 1.3em;border-radius:15px;background:#ffd700;color:#222;font-weight:bold;border:none;cursor:pointer;">OK</button></div>
  `;
  document.body.appendChild(popup);
}

// 2. Mostra il popup se in portrait su mobile
function checkAndShowOrientationAdvice() {
  if (!isMobileDevice()) return;
  // Controlla se siamo in portrait (pi√π alti che larghi)
  const portrait = window.innerHeight > window.innerWidth;
  if (portrait && typeof setOrientation === "function" && gameState.orientation === "auto") {
    createOrientationAdvicePopup();
    const popup = document.getElementById('orientationAdvicePopup');
    if (popup) {
      popup.style.display = 'block';
    }
  } else {
    // Nascondi se in landscape
    const popup = document.getElementById('orientationAdvicePopup');
    if (popup) popup.style.display = 'none';
  }
}

// 3. Rileva il cambio orientamento e mostra/nasconde il popup
window.addEventListener('orientationchange', checkAndShowOrientationAdvice);
window.addEventListener('resize', checkAndShowOrientationAdvice);

// 4. All'avvio della partita, mostra il popup se serve
window.addEventListener('DOMContentLoaded', function() {
  setTimeout(checkAndShowOrientationAdvice, 300); // Delay per layout
});



 
 // PATCH: Boss co-op visibile su mobile

function getSafeBossPosition(x, y) {
  // Calcola margine minimo per boss su mobile (landscape/portrait)
  let marginX = 80, marginY = 80;
  if (isMobileDevice()) {
    // Aumenta margini su mobile per evitare taglio
    marginX = Math.max(window.innerWidth * 0.08, 60);
    marginY = Math.max(window.innerHeight * 0.08, 60);
    // Se landscape molto stretto, aumenta ancora
    if (window.innerWidth > window.innerHeight) {
      marginY = Math.max(window.innerHeight * 0.12, 80);
    }
  }
  // Limita la posizione
  const safeX = Math.max(marginX, Math.min(x, window.innerWidth - marginX));
  const safeY = Math.max(marginY, Math.min(y, window.innerHeight - marginY));
  return { x: safeX, y: safeY };
}

// PATCH: Interpolazione boss co-op (aggiungi limitazione posizione)
function interpolateBoss() {
  if (
    gameState.gameMode === "coop" &&
    gameState.enemy &&
    bossTarget.x !== null &&
    bossTarget.y !== null
  ) {
    // Interpolazione fluida
    let newX = gameState.enemy.x + (bossTarget.x - gameState.enemy.x) * 0.13;
    let newY = gameState.enemy.y + (bossTarget.y - gameState.enemy.y) * 0.13;
    // Limita posizione
    const safe = getSafeBossPosition(newX, newY);
    gameState.enemy.x = safe.x;
    gameState.enemy.y = safe.y;
    if (bossTarget.angle !== null) {
      gameState.enemy.angle += (bossTarget.angle - gameState.enemy.angle) * 0.18;
    }
  }
}

// PATCH: Riduci dimensione boss su mobile landscape
function renderEnemy() {
    if (gameState.gameMode === "duel1v1") return; // Non disegnare boss in 1v1!

  const enemy = gameState.enemy;
  if (!enemy || enemy.health <= 0) return;
  ctx.save();
  ctx.translate(enemy.x, enemy.y);
  ctx.rotate(enemy.angle || 0);

  // Modifica grandezza su mobile
  let bossSize = 80;
  if (isMobileDevice()) {
    bossSize = Math.min(window.innerWidth, window.innerHeight) < 500 ? 54 : 64;
    // Landscape molto stretto (altezza bassa): riduci ancora
    if (window.innerWidth > window.innerHeight && window.innerHeight < 360) bossSize = 44;
  }

  if (gameState.chaosBossMeme) {
    ctx.font = bossSize + "px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("üòÇ", 0, 0);
  } else if (bossImage.complete && bossImage.naturalWidth !== 0) {
    ctx.drawImage(bossImage, -bossSize/2, -bossSize/2, bossSize, bossSize);
  } else {
    ctx.fillStyle = '#f44336';
    ctx.beginPath();
    ctx.arc(0, 0, bossSize/2, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}
 
 window.addEventListener('DOMContentLoaded', () => {
  const nickInput = document.getElementById('nicknameInput');
  if (nickInput) {
    nickInput.value = localStorage.getItem('playerName') || '';
  }
});
 
 
 function updatePlayButtonVisibility() {
  const playBtn = document.getElementById('playBtn');
  const nicknameInput = document.getElementById('nicknameInput');
  if (!playBtn || !nicknameInput) return;
  const nickname = nicknameInput.value.trim();
  playBtn.style.display = nickname.length >= 2 ? 'inline-block' : 'none';
}

window.addEventListener('DOMContentLoaded', () => {
  const nicknameInput = document.getElementById('nicknameInput');
  if (nicknameInput) {
    nicknameInput.addEventListener('input', updatePlayButtonVisibility);
    updatePlayButtonVisibility();
  }
});
 
 function onPlayClicked() {
  // Vai in fullscreen PRIMA di avviare la partita
  launchGameFullscreen();

  // Poi avvia la partita come prima
  if (isDevEnv()) {
    startGame(true);
    return;
  }
  if (typeof sdk !== 'undefined' && typeof sdk.showAd === 'function') {
    sdk.showAd();
    window._pendingStartGame = true;
    return;
  }
  startGame(true);
}
 
 
 // Funzione per inviare messaggi
function sendChatMessage() {
  const input = document.getElementById('chatInput');
  let msg = input.value.trim();
  if (!msg) return;
  if (socket) {
    socket.emit('chatMessage', {nickname: getPlayerName(), text: msg});
    input.value = '';
  }
}

// Funzione per mostrare messaggi in chat
function addChatMessage(data) {
  const chatDiv = document.getElementById('chatMessages');
  if (!chatDiv) return;
  let safeText = (''+data.text).replace(/</g,"&lt;").replace(/>/g,"&gt;");
  chatDiv.innerHTML += `<div><b style="color:#ffd700;">${data.nickname}</b>: ${safeText}</div>`;
  chatDiv.scrollTop = chatDiv.scrollHeight;
}

// Listener ricezione messaggi
if (typeof socket !== 'undefined' && socket) {
  socket.on('chatMessage', addChatMessage);
}

// (opzionale) Invio con Enter
document.getElementById('chatInput')?.addEventListener('keydown', function(e){
  if (e.key === "Enter") sendChatMessage();
});
 
 function launchGameFullscreen() {
  const elem = document.getElementById('gameContainer');
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.webkitRequestFullscreen) { // Safari
    elem.webkitRequestFullscreen();
  } else if (elem.msRequestFullscreen) { // IE11
    elem.msRequestFullscreen();
  }
}
 
 
 function toggleDaily() {
  showNotification("Voice chat not available in this version", "info");
  return;
  
  /*const cont = document.getElementById('dailyContainer');
  const frame = document.getElementById('dailyFrame');
  const roomName = "StellarGuardianCoopRoom"; // oppure dinamico se vuoi
  const dailyURL = "https://stellarguardian.daily.co/" + roomName;
  
  if (cont.style.display === 'none') {
    frame.src = dailyURL;
    cont.style.display = 'block';
  } else {
    frame.src = "";
    cont.style.display = 'none';
  }
}
 
 */
}

 // ========== SOCKET.IO CONNECTION ==========

// ========== UI ELEMENTS ==========
const duelLobby = document.getElementById('duelLobby');
const duelShip1 = document.getElementById('duelShip1');
const duelShip2 = document.getElementById('duelShip2');
const duelNick1 = document.getElementById('duelNick1');
const duelNick2 = document.getElementById('duelNick2');
const duelStatus = document.getElementById('duelStatus');
const duelCancelBtn = document.getElementById('duelCancelBtn');
const duelCountdown = document.getElementById('duelCountdown');
const duelEndScreen = document.getElementById('duelEndScreen');
const duelEndTitle = document.getElementById('duelEndTitle');
const duelEndStats = document.getElementById('duelEndStats');
const duelRematchBtn = document.getElementById('duelRematchBtn');
const duelLobbyBtn = document.getElementById('duelLobbyBtn');

duelCancelBtn.onclick = () => {
  if (window.socket) {
    window.socket.emit("duel_cancel", {});
  }
  duelLobby.classList.add('hidden');
};



// ========== STATE ==========
let duelRoomId = null;
let duelOpponent = null;
let duelGameActive = false;

// ========== LOBBY FLOW ==========
function openDuelLobby() {
  duelLobby.classList.remove('hidden');
  duelStatus.textContent = "Looking for opponent...";
  duelNick1.textContent = getPlayerName();
  duelShip1.src = getSelectedShipImage();
  duelNick2.textContent = "Searching...";
  duelShip2.src = "navicella2.png";
  
}


const ABILITY_DESCS = {
  stun: "Stun: Immobilizza l'avversario per 2 secondi.",
  heal: "Heal: Recupera 40 HP istantaneamente.",
  teleport: "Teleport: Ti sposti in un punto casuale.",
  double: "Double Shot: Il prossimo colpo fa doppio danno.",
  shield: "Shield: Immunit√† ai danni per 1.5 secondi."
};

function selectSpecialAbilityFromMenu() {
  const select = document.getElementById('duelSpecialAbilitySelect');
  if (!select) return;
  window.gameState.player.specialAbility = select.value;
  window.gameState.player.specialCooldown = 0;
  localStorage.setItem('duelSpecialAbility', select.value); // salva scelta
  document.getElementById('duelAbilityDesc').textContent = ABILITY_DESCS[select.value] || "";
  showNotification("Special Ability Selected: " + select.value);
}

document.getElementById('duelSpecialAbilitySelect').addEventListener('change', selectSpecialAbilityFromMenu);

// All'apertura della lobby, imposta la select alla scelta precedente o default
function openDuelLobby() {
  duelLobby.classList.remove('hidden');
  duelStatus.textContent = "Looking for opponent...";
  duelNick1.textContent = getPlayerName();
  duelShip1.src = getSelectedShipImage();
  duelNick2.textContent = "Searching...";
  duelShip2.src = "navicella2.png";
  // Setta la select
  const select = document.getElementById('duelSpecialAbilitySelect');
  select.value = localStorage.getItem('duelSpecialAbility') || "stun";
  selectSpecialAbilityFromMenu();
}


function startDuelQueue() {
if (!window.socket) {
  window.socket = io(SERVER_URL);
  setupDuelListeners();
}
  // Assicurati di avere SEMPRE la reference giusta:
  window.openDuelLobby();
  window.socket.emit("duel_queue", {
    nickname: getPlayerName(),
    skin: getSelectedShipImage()
  });
}



function startDuelCountdown() {
  duelLobby.classList.add('hidden'); // Nascondi la lobby

  // Mostra la schermata animata!
  showDuelLoadingScreen(
    getPlayerName(),                        // tuo nickname
    getSelectedShipImage(),                 // tua skin nave
    getEloLeague(gameState.elo).icon + " " + getEloLeague(gameState.elo).name, // tuo ELO/lega
    duelOpponent?.nickname || "Opponent",   // nickname avversario
    duelOpponent?.skin || "navicella2.png", // skin avversario
    getEloLeague(duelOpponent?.elo || 1000).icon + " " + getEloLeague(duelOpponent?.elo || 1000).name, // ELO avversario
    "Ready for the cosmic duel?"            // frase motivazionale (puoi mettere random)
  );
}

function startDuelGame() {
  console.log('[DEBUG] startDuelGame chiamata');
  duelGameActive = true;
  window.gameState.gameRunning = true;
  window.gameState.gamePaused = false;
  showScreen('gameScreen');
  setTimeout(function() {
    if (typeof resizeCanvas === "function") resizeCanvas();
  }, 80);

  window.gameState.gameMode = 'duel1v1';
  window.gameState.duelRoomId = duelRoomId;
  window.gameState.opponent = duelOpponent;
  gameState.enemy = null;
  initDuelArena();
  console.log('[DEBUG] dopo initDuelArena', gameState.player, gameState.opponentState);
  duelSyncLoop();
  startDuelLoop();
}

function startDuelLoop() {
  console.log('[DEBUG] startDuelLoop CHIAMATA');
  function duelLoop() {
    console.log('[DEBUG] duelLoop tick', duelGameActive, window.gameState.currentScreen, window.gameState.gameMode);
    if (!duelGameActive || window.gameState.currentScreen !== 'gameScreen' || window.gameState.gameMode !== 'duel1v1') return;
    // ... il resto ...
    requestAnimationFrame(duelLoop);
  }
  duelLoop();
}

function duelSyncLoop() {
  if (!duelGameActive) return;
  if (!window.socket) {
    console.warn("socket non inizializzato in duelSyncLoop");
    return;
  }
  const payload = {
    room: duelRoomId,
    player: {
      x: window.gameState.player.x,
      y: window.gameState.player.y,
      health: window.gameState.player.health,
      energy: window.gameState.player.energy,
      angle: window.gameState.player.angle
    },
    action: window.gameState.lastAction
  };
  window.socket.emit("duel_update", payload);
  setTimeout(duelSyncLoop, 50);
}

function showDuelEnd(winner, stats) {
  duelEndScreen.classList.remove('hidden');
    document.getElementById('duelOpponentHealthBar').style.display = 'none'; // nascondi la barra round

  if (winner === (window.socket && window.socket.id)) {
    duelEndTitle.textContent = "üèÜ VICTORY!";
  } else if (winner === "draw") {
    duelEndTitle.textContent = "ü§ù DRAW";
  } else {
    duelEndTitle.textContent = "üòµ DEFEAT";
  }

  // Safe extract id
  const myId = (window.socket && window.socket.id) ? window.socket.id : "me";
  const oppId = (duelOpponent && duelOpponent.id) ? duelOpponent.id : "opponent";

  // PATCH ELO: calcolo e visualizzazione
  let myElo = gameState.elo || 1000;
  let oppElo = duelOpponent?.elo || 1000;
  let result = 0.5;
  if (winner === (window.socket && window.socket.id)) result = 1;
  else if (winner === (duelOpponent?.id || "opponent")) result = 0;

  function calculateElo(myElo, oppElo, result, k = 32) {
    const expected = 1 / (1 + Math.pow(10, (oppElo - myElo) / 400));
    const newElo = myElo + k * (result - expected);
    return Math.round(newElo);
  }

  const newElo = calculateElo(myElo, oppElo, result);
const delta = newElo - myElo;
gameState.elo = newElo;
saveGameData(); // <--- assicurati che sia qui!
updateUI();

  // <<< AGGIUNGI QUI >>>
  submitDuelScore(getPlayerName(), gameState.elo);

duelEndStats.innerHTML = `
    <b>You:</b> ${stats?.[myId]?.kills ?? 0} kills, ${stats?.[myId]?.damage ?? 0} damage<br>
    <b>${duelOpponent?.nickname || "Opponent"}:</b> ${stats?.[oppId]?.kills ?? 0} kills, ${stats?.[oppId]?.damage ?? 0} damage
    <br><span style="color:#ffd700;">ELO change: ${delta > 0 ? "+" : ""}${delta} (ELO: ${newElo})</span>
  `;

  setupDuelEndButtons?.(); // se c'√® la funzione per i bottoni
}

// ========== GAMEPLAY: POWERUP & OSTACOLI (Esempio) ==========
function processDuelEvents(events) {
  if (!events) return;
  for (const evt of events) {
    if (evt.type === "powerup_spawn") spawnPowerup(evt.data);
    if (evt.type === "powerup_pick") applyPowerup(evt.data);
    if (evt.type === "obstacle_move") moveObstacle(evt.data);
    // ... (puoi estendere)
  }
}
function spawnPowerup(data) { /* disegna/aggiorna powerup */ }
function applyPowerup(data) { /* applica powerup al player */ }
function moveObstacle(data) { /* muovi ostacolo in arena */ }

// ========== UTILS ==========
function getPlayerName() {
  return localStorage.getItem('playerName') || "NoName";
}
function getSelectedShipImage() {
  return localStorage.getItem('selectedShip') || "navicella1.png";
}

function initDuelArena() {
  // Player 1: alto a sinistra
  gameState.player.x = 100;
  gameState.player.y = 90;
  gameState.player.health = 500;
  gameState.player.energy = 100;

  // Player 2: alto a destra
  gameState.opponentState = {
    x: canvas.width - 100, // <-- cambia qui!
    y: 90,
    health: 500,
    energy: 100,
    maxHealth: 500
  };

  gameState.powerups = [];
  gameState.obstacles = [];
}
 
 
// PATCH 2: Colore barra vita avversario sempre corretto
function renderOpponent(ctx) {
  const opp = gameState.opponentState;
  if (!opp) return;
  let x = opp.x, y = opp.y;
  if (duelEntryAnimation.active) {
    x = lerp(canvas.width + 100, opp.x, duelEntryAnimation.progress);
  }
  ctx.save();
  ctx.globalAlpha = 0.8;
  const img = new Image();
  img.src = getShipImageFromId(duelOpponent?.skin) || "navicella2.png";
  ctx.drawImage(img, x - 32, y - 32, 64, 64);

  // Barra vita
  const barWidth = 56, barHeight = 10;
  const healthPercent = Math.max(0, opp.health) / (opp.maxHealth || 100);
  // LOG: console.log("HP%", healthPercent, opp.health, opp.maxHealth);

  ctx.fillStyle = healthPercent > 0.6 ? "#4caf50" : healthPercent > 0.3 ? "#ffd700" : "#f44336";
  ctx.fillRect(opp.x - barWidth / 2, opp.y - 50, barWidth * healthPercent, barHeight);
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 2;
  ctx.strokeRect(opp.x - barWidth / 2, opp.y - 50, barWidth, barHeight);
  ctx.font = "bold 18px Orbitron";
  ctx.fillStyle = "#ffd700";
  ctx.textAlign = "center";
  ctx.fillText(duelOpponent?.nickname || "Opponent", opp.x, opp.y - 60);
  ctx.restore();
}
 
function setupDuelListeners() {
  if (!window.socket) return; // AGGIUNGI QUESTA RIGA!
  window.socket.off('duel_opponent_found');
  window.socket.off('duel_state');
  window.socket.off('duel_end');
  window.socket.on('duel_opponent_found', ({ room, opponent }) => {
    duelRoomId = room;
    duelOpponent = opponent;
    duelNick2.textContent = opponent.nickname;
    duelShip2.src = opponent.skin;
  duelStatus.textContent = `Opponent found! RoomID: ${room}`; // <-- Mostra l'ID qui!
    setTimeout(() => startDuelCountdown(), 1200);
  });
  window.socket.on('duel_state', ({ opponent, self, powerups, obstacles, events }) => {
  window.gameState.opponentState = opponent;
  window.gameState.powerups = powerups;
  window.gameState.obstacles = obstacles;
  processDuelEvents(events);

  // PATCH: aggiorna la tua health locale!
  if (self && typeof self.health === "number") {
    window.gameState.player.health = self.health;
    window.gameState.player.energy = self.energy;
    // Altri parametri se vuoi!
  }

// (resto del tuo codice)
if (duelRounds === 0 || window.gameState.opponentState.health > 500) {
  window.gameState.opponentState.health = 500;
  window.gameState.opponentState.maxHealth = 500;
}

});
  // Listener powerup spawn
window.socket.on('powerup_spawn', function(powerup) {
  window.gameState.powerups.push(powerup);
});
// Listener powerup raccolto
window.socket.on('powerup_picked', function({ player, powerup }) {
  window.gameState.powerups = window.gameState.powerups.filter(p => p.id !== powerup.id);
  if (player === window.socket.id) applyPowerupEffect(powerup.type);
});
  
  
  window.socket.on('duel_obstacle_spawn', function(obstacle) {
  window.gameState.obstacles.push(obstacle);
});
window.socket.on('duel_obstacle_hit', function({ obstacle }) {
  window.gameState.obstacles = window.gameState.obstacles.filter(o => o.id !== obstacle.id);
});
  
  
  window.socket.on('duel_emote', function({ player, emote }) {
  showDuelEmoteOnScreen(emote, player === window.socket.id);
  showNotification(`Opponent: ${emote}`);
});


// Ricevi e mostra il colpo dell‚Äôavversario:
window.socket.on('duel_opponent_shoot', function(data) {
  if (gameState.gameMode !== "duel1v1") return;
  // Aggiungi il proiettile ai tuoi bullets, con un colore diverso (es: rosso)
  gameState.bullets.push({
    x: data.x,
    y: data.y,
    vx: data.vx,
    vy: data.vy,
    color: "#f44336", // rosso, cos√¨ li distingui
    size: 8,
    isOpponent: true  // campo opzionale per distinguere
  });
});


function sendDuelEmote(emote) {
  window.socket.emit('duel_update', { room: duelRoomId, player: {...window.gameState.player}, action: 'emote', emote });
  showDuelEmoteOnScreen(emote, true);
}
  
  window.socket.on('duel_end', ({ winner, stats }) => {
  duelGameActive = false;
  gameState.gameMode = 'duel1v1'; // forza la modalit√†
  gameState.currentScreen = 'gameScreen';
  updateDuelOpponentHealthBar();
  showScreen('gameScreen'); // forza la schermata, se serve
  duelEndScreen.classList.remove('hidden'); // mostra la schermata finale
  showDuelEnd(winner, stats);
});

}


// Funzione per controllare se sei effettivamente in fullscreen
function isFullscreen() {
  return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
}

// Mostra il popup se NON sei in fullscreen e SEI nel gameScreen (solo su PC!)
function showFullscreenAdvice() {
  // Solo su PC (no mobile/tablet)
  if (/Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) return;
  // Solo se sei nella schermata di gioco
  if (gameState.currentScreen !== "gameScreen") {
    document.getElementById("fullscreenAdvicePopup").style.display = "none";
    return;
  }
  // Se sei gi√† in fullscreen, nascondi il popup
  if (isFullscreen()) {
    document.getElementById("fullscreenAdvicePopup").style.display = "none";
    return;
  }
  // Mostra il popup
  document.getElementById("fullscreenAdvicePopup").style.display = "block";
}

// Azione per entrare in fullscreen dal popup
function enableFullscreenFromPopup() {
  const elem = document.getElementById('gameContainer');
  if (elem.requestFullscreen) elem.requestFullscreen();
  else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
  else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
  setTimeout(showFullscreenAdvice, 600); // Aggiorna popup dopo il tentativo
}



window.addEventListener('DOMContentLoaded', () => {
  duelRematchBtn.onclick = () => {
    duelEndScreen.classList.add('hidden');
    safeCloseSocket(() => {
      duelGameActive = false;
      duelRoomId = null;
      duelOpponent = null;
      window.socket = io();
      setupDuelListeners();
      window.socket.on('connect', () => {
        startDuelQueue();
      });
    });
  };

  duelLobbyBtn.onclick = () => {
    duelEndScreen.classList.add('hidden');
    duelGameActive = false;
    duelRoomId = null;
    duelOpponent = null;
    showScreen('mainMenu');
    safeCloseSocket();
  };
});

// Funzione helper per chiudere socket in sicurezza
function safeCloseSocket(cb) {
  if (window.socket) {
    try {
      window.socket.on('disconnect', () => {
        window.socket = null;
        if (cb) setTimeout(cb, 50);
      });
      window.socket.disconnect();
      setTimeout(() => {
        if (cb) cb();
      }, 500);
    } catch (e) { if (cb) cb(); }
  } else {
    if (cb) cb();
  }
}


function getShipImageFromId(id) {
  switch (id) {
    case "ship1": return "navicella1.png";
    case "ship2": return "navicella2.png";
    case "ship3": return "navicella3.png";
    case "ship4": return "navicella4.png";
    case "summer": return "navicella-summer.png";
    default: return "navicella2.png";
  }
}


function setupDuelEndButtons() {
  // Rimuovi i vecchi listener se gi√† presenti
  duelRematchBtn.onclick = null;
  duelLobbyBtn.onclick = null;

  duelRematchBtn.onclick = function() {
    duelEndScreen.classList.add('hidden');
    safeCloseSocket(() => {
      duelGameActive = false;
      duelRoomId = null;
      duelOpponent = null;
      window.socket = io();
      setupDuelListeners();
      window.socket.on('connect', () => {
        startDuelQueue();
      });
    });
  };

  duelLobbyBtn.onclick = function() {
    duelEndScreen.classList.add('hidden');
    duelGameActive = false;
    duelRoomId = null;
    duelOpponent = null;
    showScreen('mainMenu');
    safeCloseSocket();
  };
}






// PATCH FINALE: showScreen UNICA, con tutte le azioni extra
(function() {
  // Salva la versione originale una volta sola!
  const realShowScreen = window.showScreen;
  window.showScreen = function(screenId) {
    if (typeof realShowScreen === "function") realShowScreen(screenId);

    // Tutte le azioni aggiuntive qui dentro!
    if (screenId === 'gameScreen') {
      setTimeout(checkAndShowOrientationAdvice, 350);
      setTimeout(showFullscreenAdvice, 250);
    }
    // (aggiungi qui altre azioni future se vuoi)
  };

  document.addEventListener('fullscreenchange', showFullscreenAdvice);
  window.addEventListener('focus', showFullscreenAdvice);
})();
function toggleMobileButton(buttonId) {
  // Logica per attivare/disattivare un pulsante nel layout mobile
  console.log("Toggled:", buttonId);
}

function updateShipSpeedValue(value) {
  document.getElementById('shipSpeedValue').textContent = parseFloat(value).toFixed(2) + "x";
  // Qui imposti la variabile di velocit√† della navicella nel gioco
}

function updateButtonSize(value) {
  document.getElementById('buttonSizeValue').textContent = value + "px";
  document.querySelectorAll('.mobile-action-btn').forEach(btn => {
    btn.style.width = value + "px";
    btn.style.height = value + "px";
  });
}

function updateButtonColor(color) {
  document.querySelectorAll('.mobile-action-btn').forEach(btn => {
    btn.style.backgroundColor = color;
  });
}

function updateNicknameColor(color) {
  const nickElement = document.getElementById('nicknameAboveShipDisplay');
  if (nickElement) nickElement.style.color = color;
}

function applyMobileSettings() {
  // Leggi i valori dagli input
  const speed = parseFloat(document.getElementById('shipSpeedSlider').value);
  const size = parseInt(document.getElementById('buttonSizeSlider').value, 10);
  const color = document.getElementById('buttonColorPicker').value;
  const nick = document.getElementById('nicknameAboveShip')?.value || '';
  const nickColor = document.getElementById('nicknameColorPicker')?.value || '#fff';

  // Costruisci oggetto impostazioni
  window.gameSettings = {
    shipSpeed: speed,
    buttonSize: size,
    buttonColor: color,
    nicknameAboveShip: nick,
    nicknameColor: nickColor
  };

  // Salva su localStorage (tutto)
  localStorage.setItem('sg_mobileSettings', JSON.stringify(window.gameSettings));
  // Salva velocit√† anche su chiave singola se usata nel gameplay
  localStorage.setItem('mobileShipSpeed', speed);

  // PATCH: aggiorna dinamicamente la velocit√† anche in partita
  if (window.gameState && window.gameState.isMobile) {
    window.gameState.mobileShipSpeed = speed;
    console.log("Nuova velocit√† impostata in applyMobileSettings:", speed, "window.gameState.mobileShipSpeed:", window.gameState.mobileShipSpeed);

    if (window.gameState.player) {
      // Se vuoi puoi forzare l‚Äôupdate su player
      window.gameState._forceMobileSpeedUpdate = true;
    }
  }

  // Applica dimensione e colore ai pulsanti live
  document.querySelectorAll('.mobile-action-btn').forEach(btn => {
    btn.style.width = size + 'px';
    btn.style.height = size + 'px';
    btn.style.backgroundColor = color;
  });

  // PATCH: aggiorna anche i controlli touch se serve
  if (window.gameState && window.gameState.isMobile && typeof setupMobileControls === "function") {
    setupMobileControls();
  }

  // Aggiorna nickname sopra la navicella (se serve)
  let nickEl = document.getElementById('nicknameAboveShipDisplay');
  if (!nickEl) {
    nickEl = document.createElement('div');
    nickEl.id = 'nicknameAboveShipDisplay';
    nickEl.style.position = 'absolute';
    nickEl.style.pointerEvents = 'none';
    nickEl.style.fontFamily = "'Orbitron', monospace";
    nickEl.style.fontWeight = '900';
    nickEl.style.textShadow = '0 0 8px rgba(0,0,0,0.6)';
    nickEl.style.zIndex = 2000;
    nickEl.style.transform = 'translate(-50%,-120%)';
    document.getElementById('gameContainer').appendChild(nickEl);
  }
  nickEl.textContent = nick;
  nickEl.style.color = nickColor;

  // PATCH: aggiorna la posizione del nickname subito
  if (typeof updateNicknamePosition === "function") updateNicknamePosition();

  // Notifica
  if (typeof showNotification === 'function') {
    showNotification('Mobile settings applicati ‚úÖ');
  } else {
    alert('Mobile settings applicati ‚úÖ');
  }
}

// resettare le impostazioni (facoltativo)
function resetMobileSettings() {
  // ripristina valori di default
  document.getElementById('shipSpeedSlider').value = 0.7;
  document.getElementById('shipSpeedValue').textContent = '0.70x';
  document.getElementById('buttonSizeSlider').value = 80;
  document.getElementById('buttonSizeValue').textContent = '80px';
  document.getElementById('buttonColorPicker').value = '#00bcd4';
  document.getElementById('nicknameAboveShip').value = '';
  document.getElementById('nicknameColorPicker').value = '#ffffff';
  applyMobileSettings();
}


function updateNicknamePosition() {
  const nickEl = document.getElementById('nicknameAboveShipDisplay');
  if (!nickEl || !window.playerShip) return;
  // supponiamo playerShip abbia .x e .y in coordinate del canvas
  const rect = document.getElementById('gameCanvas').getBoundingClientRect();
  const shipScreenX = rect.left + (window.playerShip.x / GAME_WIDTH) * rect.width;
  const shipScreenY = rect.top + (window.playerShip.y / GAME_HEIGHT) * rect.height;
  nickEl.style.left = shipScreenX + 'px';
  nickEl.style.top = shipScreenY + 'px';
}


function loadMobileSettings() {
  const saved = JSON.parse(localStorage.getItem('sg_mobileSettings') || "{}");
  // Ship speed
  if (saved.shipSpeed !== undefined) {
    document.getElementById('shipSpeedSlider').value = saved.shipSpeed;
    document.getElementById('shipSpeedValue').textContent = parseFloat(saved.shipSpeed).toFixed(2) + "x";
  }
  // Button size
  if (saved.buttonSize) {
    document.getElementById('buttonSizeSlider').value = parseInt(saved.buttonSize, 10);
    document.getElementById('buttonSizeValue').textContent = saved.buttonSize + "px";
  }
  // Button color
  if (saved.buttonColor) {
    document.getElementById('buttonColorPicker').value = saved.buttonColor;
  }
  // Nickname sopra la nave
  if (saved.nicknameAboveShip) {
    document.getElementById('nicknameAboveShip').value = saved.nicknameAboveShip;
  }
  // Nickname color
  if (saved.nicknameColor) {
    document.getElementById('nicknameColorPicker').value = saved.nicknameColor;
  }
}


function applyPowerupEffect(type) {
  switch(type) {
    case 'heal': window.gameState.player.health = Math.min(window.gameState.player.maxHealth, window.gameState.player.health + 40); showNotification("üíö Healed!"); break;
    case 'shield': window.gameState.player.invulnerabilityFrames = 120; showNotification("üõ° Shield!"); break;
    case 'damage': window.gameState.player.damageBuff = 100; showNotification("üî´ Damage Up!"); break;
    case 'speed': window.gameState.player.speedBuff = 1.7; showNotification("‚ö° Speed Up!"); break;
  }
}


function checkPowerupPickup() {
  window.gameState.powerups.forEach(p => {
    const dx = window.gameState.player.x - p.x;
    const dy = window.gameState.player.y - p.y;
    if (Math.sqrt(dx*dx + dy*dy) < 32 && p.active) {
      window.socket.emit('duel_update', { room: duelRoomId, player: {...window.gameState.player}, action: 'powerup_pick', powerupId: p.id });
      p.active = false;
      applyPowerupEffect(p.type); // <--- AGGIUNGI QUESTA RIGA QUI!
    }
  });
}


function renderDuelPowerups(ctx, powerups) {
  powerups.forEach(p => {
    if (!p.active) return;
    ctx.save();

    // Glow sottostante
    ctx.globalAlpha = 0.23;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 32, 0, Math.PI * 2);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.globalAlpha = 1;

    // Disegna sprite
   const img = POWERUP_SPRITES[p.type] || POWERUP_SPRITES['heal'];
if (img && img.complete && img.naturalWidth !== 0) {
  ctx.drawImage(img, p.x - 24, p.y - 24, 48, 48);
} else {
  // fallback visual (cerchio dorato)
  ctx.fillStyle = "#ffd700";
  ctx.beginPath();
  ctx.arc(p.x, p.y, 24, 0, Math.PI * 2);
  ctx.fill();
}

    // Bordo dorato (facoltativo)
    ctx.strokeStyle = "#ffd700";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 24, 0, Math.PI * 2);
    ctx.stroke();

    ctx.restore();
  });
}
if (gameState.gameMode === "duel1v1") renderDuelPowerups(ctx, window.gameState.powerups);


function checkObstacleHit() {
  window.gameState.obstacles.forEach((o, idx) => {
    const dx = window.gameState.player.x - o.x;
    const dy = window.gameState.player.y - o.y;
    if (Math.sqrt(dx*dx + dy*dy) < o.size/2 + 20 && !o.hit) {
      window.socket.emit('duel_update', { room: duelRoomId, player: {...window.gameState.player}, action: 'obstacle_hit', obstacleId: o.id });
      o.hit = true;
      window.gameState.player.health -= 20;
      showNotification("üí• Mine hit!");
    }
  });
}
if (gameState.gameMode === "duel1v1") checkObstacleHit();


function updateDuelEmojiBar() {
  const bar = document.getElementById('duelEmojiBar');
  if (!bar) return;
  // FORZA la barra emoji sempre visibile in gameScreen (debug)
  bar.style.display = (gameState.currentScreen === "gameScreen") ? "flex" : "none";
}
window.showScreen = (function(orig){
  return function(screenId) {
    orig(screenId);
    updateDuelEmojiBar();
  };
})(window.showScreen);


function sendDuelEmote(emote) {
  if (window.socket && duelRoomId) {
    window.socket.emit('duel_update', {
      room: duelRoomId,
      player: {...window.gameState.player},
      action: 'emote',
      emote: emote
    });
    showDuelEmoteOnScreen(emote, true); // Mostra anche lato tuo!
  }
}


function showDuelEmoteOnScreen(emote, isSelf = false) {
  const div = document.createElement('div');
  div.style.position = 'fixed';
  div.style.left = isSelf ? 'calc(25% - 38px)' : 'calc(75% - 38px)';
  div.style.bottom = '120px';
  div.style.background = isSelf ? '#00bcd4' : '#ffd700';
  div.style.color = '#222';
  div.style.fontSize = '2.5rem';
  div.style.padding = '1.1em';
  div.style.borderRadius = '50%';
  div.style.boxShadow = '0 0 28px ' + (isSelf ? '#00bcd4' : '#ffd700');
  div.style.zIndex = 99999;
  div.style.textAlign = 'center';
  div.style.opacity = '0.92';
  div.style.transition = 'all 0.7s cubic-bezier(.5,2,.3,1)';
  div.textContent = emote;
  document.body.appendChild(div);
  setTimeout(() => { div.style.opacity = '0'; div.style.transform = 'scale(1.6)'; }, 900);
  setTimeout(() => { div.remove(); }, 1400);
}


// === PATCH: DUEL 1v1 Best of 3 + Barra vita in alto ===

// 1. Variabili di stato per i round
let duelRounds = 0;
let myRoundWins = 0;
let oppRoundWins = 0;
let duelMaxRounds = 3;

// 2. UI per i round (aggiungi in HTML subito dopo il canvas, oppure via JS)
(function() {
  // Crea la barra vita avversario in alto a destra
  let bar = document.getElementById('duelOpponentHealthBar');
  if (!bar) {
    bar = document.createElement('div');
    bar.id = 'duelOpponentHealthBar';
    bar.style.top = '24px';
bar.style.left = '24px';
bar.style.right = 'auto';
    bar.style.background = 'rgba(30,30,30,0.93)';
    bar.style.borderRadius = '12px';
    bar.style.padding = '0.7em 1.4em';
    bar.style.zIndex = '9001';
    bar.style.minWidth = '160px';
    bar.style.boxShadow = '0 0 30px #ffd70088';
    bar.style.display = 'none';
    bar.innerHTML = `
      <div id="duelOpponentNick" style="font-weight:900;color:#ffd700;font-size:1.2em;margin-bottom:2px;">OPPONENT</div>
      <div style="width:100%;height:18px;background:#333;border-radius:8px;overflow:hidden;box-shadow:0 0 8px #ffd700;">
        <div id="duelOpponentHealthBarFill" style="height:100%;width:100%;background:linear-gradient(90deg,#4caf50,#ffd700,#f44336);transition:width .3s;"></div>
      </div>
      <div id="duelOpponentHealthText" style="font-size:0.96em;color:#fff;margin-top:2px;">500 / 500</div>
      <div id="duelRoundInfo" style="margin-top:8px;font-size:1.12em;color:#ffd700;">Round: 1 / 3</div>
      <div id="duelRoundsScore" style="font-size:0.99em;color:#00bcd4;">You: 0 | Opponent: 0</div>
    `;
    document.getElementById('gameContainer').appendChild(bar);
  }
})();

// 3 Barra vita avversario + round info (gi√† presente nel tuo codice, ma puoi personalizzare)
function updateDuelOpponentHealthBar() {
  const bar = document.getElementById('duelOpponentHealthBar');
  if (!bar) return;
  if (gameState.currentScreen === "gameScreen" && gameState.gameMode === "duel1v1") {
    bar.style.display = 'block';
    // Aggiorna dati
    if (gameState.opponentState) {
      const health = Math.max(0, Math.floor(gameState.opponentState.health || 0));
      const maxHealth = Math.max(1, Math.floor(gameState.opponentState.maxHealth || 100));
      const percent = Math.min(100, 100 * health / maxHealth);
      document.getElementById('duelOpponentHealthBarFill').style.width = percent + "%";
      document.getElementById('duelOpponentHealthText').textContent = `${health} / ${maxHealth}`;
      document.getElementById('duelOpponentNick').textContent = duelOpponent?.nickname || "Opponent";
    }
    document.getElementById('duelRoundInfo').textContent = `Round: ${duelRounds+1} / ${duelMaxRounds}`;
    document.getElementById('duelRoundsScore').textContent = `You: ${myRoundWins} | Opponent: ${oppRoundWins}`;
  } else {
    bar.style.display = 'none';
  }
}


window.showScreen = (function(orig){
  return function(screenId) {
    orig(screenId);
    updateDuelEmojiBar();
  };
})(window.showScreen);

// 5. Logica per gestire i round (best of 3)
function handleDuelRoundEnd(winnerId) {
  duelRounds++;
  if (winnerId === (window.socket && window.socket.id)) myRoundWins++;
  else oppRoundWins++;

  // Aggiorna la barra subito
  updateDuelOpponentHealthBar();

  // MOSTRA OVERLAY SUBITO!
  if (winnerId === (window.socket && window.socket.id)) {
    showDuelRoundOverlay("win", duelRounds);
  } else if (winnerId === "draw") {
    showDuelRoundOverlay("draw", duelRounds);
  } else {
    showDuelRoundOverlay("lose", duelRounds);
  }

  // Controlla se qualcuno ha vinto 2 round
  if (myRoundWins >= 2 || oppRoundWins >= 2 || duelRounds >= duelMaxRounds) {
    // Fine match: mostra schermata finale
    setTimeout(() => {
      hideDuelRoundOverlay(); // Nascondi overlay prima della schermata finale
      showDuelEnd(
        myRoundWins > oppRoundWins
          ? (window.socket && window.socket.id)
          : (myRoundWins === oppRoundWins ? "draw" : (duelOpponent?.id || "opponent")),
        { /* puoi passare stats qui */ }
      );
    }, 1200);
    return;
  }

  // Se non √® finito, prepara nuovo round!
  setTimeout(() => {
    hideDuelRoundOverlay(); // Nascondi overlay quando riparte il prossimo round
    startNextDuelRound();
  }, 1800);
}
  
  
  // RIMUOVI QUESTA SEZIONE BUGGY:
  // ‚ùå CANCELLA QUESTE RIGHE (erano il problema):
  /*
  if (winnerId !== window.socket.id) {
    duelRounds++;  // <-- DOPPIO INCREMENTO!
    updateDuelOpponentHealthBar();
    showDuelEnd("lose", { });  // <-- SCHERMATA PERDENTE NEI ROUND INTERMEDI!
  }
  */

function startNextDuelRound() {
  // Reset stato giocatori
  gameState.player.x = 300;
  gameState.player.y = 600;
  gameState.player.health = 500;
  gameState.player.energy = 100;
  gameState.opponentState.x = 900;
  gameState.opponentState.y = 600;
  gameState.opponentState.health = 500;
  gameState.opponentState.energy = 100;
  gameState.bullets = [];
  gameState.enemyBullets = [];
  // Countdown visivo?
  showNotification(`Round ${duelRounds+1} ‚Äî Get Ready!`);
  updateDuelOpponentHealthBar();
  // Puoi riavviare il loop se serve (startDuelLoop();)
}

function checkCollisionsDuel() {
  if (!duelGameActive || !gameState.opponentState) return;

  for (let i = gameState.bullets.length - 1; i >= 0; i--) {
    const bullet = gameState.bullets[i];
    const hitbox = 32;

    if (bullet.isOpponent) {
      // Questo proiettile √® stato sparato dall'avversario: colpisce TE!
      const dist = Math.sqrt((bullet.x - gameState.player.x) ** 2 + (bullet.y - gameState.player.y) ** 2);
      if (dist < hitbox && gameState.player.health > 0) {
        // Togli vita a te stesso, NON mandare duel_hit!
        gameState.player.health -= bullet.damage || 20;
        gameState.bullets.splice(i, 1);
        createHitParticles(bullet.x, bullet.y, bullet.color || "#ffd700");
      }
    } else {
      // Questo proiettile l'hai sparato TU: colpisce solo l'avversario!
      const opp = gameState.opponentState;
      const dist = Math.sqrt((bullet.x - opp.x) ** 2 + (bullet.y - opp.y) ** 2);
      if (dist < hitbox && opp.health > 0) {
        gameState.bullets.splice(i, 1);
        createHitParticles(bullet.x, bullet.y, bullet.color || "#ffd700");
        if (window.socket && duelRoomId) {
          window.socket.emit("duel_hit", {
            room: duelRoomId,
            damage: bullet.damage || 20
          });
        }
      }
    }
  }

  updateDuelOpponentHealthBar();
  // La fine round va gestita SOLO quando ricevi la health aggiornata dal server nella socket 'duel_state'
}

// 7. Quando inizi un nuovo duello, resetta i round
window.startDuelGame = (function(orig){
  return function() {
    duelGameActive = true;
    duelRounds = 0;
    myRoundWins = 0;
    oppRoundWins = 0;
    showScreen('gameScreen');
    window.gameState.gameMode = 'duel1v1';
    window.gameState.duelRoomId = duelRoomId;
    window.gameState.opponent = duelOpponent;
    gameState.enemy = null;
    initDuelArena();
    duelSyncLoop();
    startDuelEntryAnimation();
    startDuelLoop();
    updateDuelOpponentHealthBar();
  };
})(window.startDuelGame);

// 8. Aggiorna la barra vita avversario ogni frame nel loop
function startDuelLoop() {
  console.log('[startDuelLoop] Avviato con:', duelGameActive, window.gameState.currentScreen, window.gameState.gameMode);

  function duelLoop() {
    // Log per ogni frame!
    console.log('[duelLoop tick]', duelGameActive, window.gameState.currentScreen, window.gameState.gameMode, window.gameState.bullets.length);

    
      if (duelEntryAnimation.active) {
    duelEntryAnimation.progress += 1 / duelEntryAnimation.duration;
    if (duelEntryAnimation.progress >= 1) {
      duelEntryAnimation.active = false;
      duelEntryAnimation.progress = 1;
    }
  }
    
    
    if (!duelGameActive || window.gameState.currentScreen !== 'gameScreen' || window.gameState.gameMode !== 'duel1v1') return;
    updatePlayer(1); updatePlayerTrail(); updateObstacles(1); updateBullets(1); updateEnemyBullets(1); updateParticles(1);
    checkCollisionsDuel();
    render();
    updateDuelOpponentHealthBar();
    requestAnimationFrame(duelLoop);
  }
  duelLoop();
}

// FINE PATCH


function getEloLeague(elo) {
  if (elo < 1100) return { name: "Bronze", color: "#b97a57", icon: "ü•â" };
  if (elo < 1300) return { name: "Silver", color: "#bdbdbd", icon: "ü•à" };
  if (elo < 1500) return { name: "Gold", color: "#ffd700", icon: "ü•á" };
  if (elo < 1700) return { name: "Platinum", color: "#aeefff", icon: "üí†" };
  if (elo < 1900) return { name: "Diamond", color: "#00e0ff", icon: "üî∑" };
  if (elo < 2200) return { name: "Master", color: "#9c27b0", icon: "üéñÔ∏è" };
  return { name: "Legend", color: "#ff9800", icon: "üèÜ" };
}


const DUEL_LEADERBOARD_TAG = "duel1v1";

function fetchDuelLeaderboard(callback) {
  const dreamloKey = "5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw";
  const tag = DUEL_LEADERBOARD_TAG;
  const url = `https://dreamlo.com/lb/${dreamloKey}/pipe-get/${tag}`;
  fetch(url)
    .then(res => res.text())
    .then(txt => {
      const rows = txt.trim().split('\n');
      const leaderboard = rows
        .map(row => {
          const [name, score] = row.split('|');
          if (!name || isNaN(parseInt(score))) return null;
          return { name, score: parseInt(score) };
        })
        .filter(entry => entry !== null)
        .sort((a, b) => b.score - a.score)
        .slice(0, 20); // top 20
      callback(leaderboard);
    });
}

// PATCH: Leaderboard 1v1 Duel mostra ELO invece di "score"

function showDuelLeaderboard() {
  showScreen('duelLeaderboardScreen');
  document.getElementById('duelLeaderboardList').innerHTML = 'Loading...';
  fetchDuelLeaderboard(leaderboard => {
    let html = '<ol style="font-size:1.2rem;">';
    leaderboard.forEach(entry => {
      html += `<li><b>${entry.name}</b> ‚Äî <span style="color:#ffd700;">ELO: ${entry.score}</span></li>`;
    });
    if (leaderboard.length === 0) html += "<li>Nessun ELO ancora!</li>";
    html += '</ol>';
    document.getElementById('duelLeaderboardList').innerHTML = html;
  });
}

/* startFirstMission: prova a chiamare le funzioni esistenti (startMission / startGame),
   con fallback non distruttivi se non trovate. */
function startFirstMission(){
  console.log('startFirstMission called');
  // 1) preferiamo una funzione che accetta il livello: startMission(1)
  if (typeof startMission === 'function'){
    try { startMission(1); return; } catch(e){ console.warn('startMission error', e); }
  }

  // 2) fallback a startGame(true) (se il tuo startGame supporta skipAd o flag)
  if (typeof startGame === 'function'){
    try { startGame(true); return; } catch(e) {
      try { startGame(); return; } catch(e2) { console.warn('startGame error', e2); }
    }
  }

  // 3) fallback: apri la schermata di selezione livelli se esiste
  if (typeof showScreen === 'function'){
    try { showScreen('levelSelect'); return; } catch(e){ console.warn('showScreen error', e); }
  }

  // 4) ultima risorsa: avvisa l'utente
  alert('Impossibile avviare automaticamente la partita: controlla la console per errori.');
}


// === Spettatore 1v1 ===

document.getElementById('spectatorBtn').onclick = function() {
  const roomId = document.getElementById('spectatorRoomInput').value || 'room123';
  joinAsSpectator(roomId);
};

function joinAsSpectator(roomId) {
  if (!window.spectatorSocket) {
    window.spectatorSocket = io();
  }
  window.spectatorSocket.emit('duel_join', { roomId, role: 'spectator', nickname: "Spectator" });

  window.spectatorSocket.on('duel_state', (data) => {
    updateSpectatorView(data.players, data.spectators);
  });

  // Mostra overlay
  document.getElementById('spectatorPanel').style.display = 'block';
  document.getElementById('spectatorPanel').style.background = 'rgba(20,30,40,0.94)';
}

function updateSpectatorView(players, spectators) {
  let html = '';
  players.forEach((p, i) => {
    html += `
      <div style="margin-bottom:6px;${i===0?'':'border-top:1px solid #333; padding-top:5px;'}">
        <span style="color:#00bcd4;font-weight:bold;">Player ${i+1}:</span>
        <b style="color:#ffd700">${p.nickname || 'Player'}</b><br>
        Pos: <span style="color:#fff;">${Math.round(p.x)},${Math.round(p.y)}</span><br>
        HP: <span style="color:#4caf50">${p.hp}</span> | Score: <span style="color:#ffd700">${p.score}</span>
      </div>
    `;
  });
  document.getElementById('spectatorPlayers').innerHTML = html || "<i>No players in game</i>";
  document.getElementById('spectatorCount').textContent = spectators + " spettatori attuali";
}



function resetDuelRound(data) {
  console.log('[resetDuelRound] Chiamato', data);

  // Reset stato player
  gameState.player.x = data.playerStates[window.socket.id].x;
  gameState.player.y = data.playerStates[window.socket.id].y;
  gameState.player.health = 500;
  gameState.player.energy = 100;
  gameState.player.invulnerabilityFrames = 0;

  // Reset opponent
  const oppId = Object.keys(data.playerStates).find(id => id !== window.socket.id);
  gameState.opponentState.x = data.playerStates[oppId].x;
  gameState.opponentState.y = data.playerStates[oppId].y;
  gameState.opponentState.health = 500;
  gameState.opponentState.energy = 100;
  gameState.opponentState.invulnerabilityFrames = 0;
  gameState.opponentState.maxHealth = 500;

  // Azzera bullets, powerups, ostacoli
  gameState.bullets = [];
  gameState.enemyBullets = [];
  gameState.powerups = [];
  gameState.obstacles = [];

  duelGameActive = true; // <-- AGGIUNGI QUI!
  gameState.player.specialCooldown = 0; // Reset cooldown

  // LOG stato dopo il reset
  console.log('[resetDuelRound] Stato:', {
    bullets: gameState.bullets.length,
    enemyBullets: gameState.enemyBullets.length,
    powerups: gameState.powerups.length,
    obstacles: gameState.obstacles.length,
    duelGameActive
  });

  updateDuelOpponentHealthBar();
  updateUI();
}
  


window.socket.on('duel_next_round', function(data) {
  hideDuelRoundOverlay();
  resetDuelRound(data);

  
      duelRounds = data.round - 1;      // <-- QUI!

  duelGameActive = false;
  window.gameState.gameMode = 'duel1v1';
  window.gameState.currentScreen = 'gameScreen';

  // Mostra overlay con countdown
  showNextRoundOverlay(data.round, duelMaxRounds || 3, 7, function() {
    duelGameActive = true;
    window.gameState.gameMode = 'duel1v1';
    window.gameState.currentScreen = 'gameScreen';
    startDuelLoop();
    updateDuelOpponentHealthBar();     // <-- QUI!
    console.log('[duel_next_round] startDuelLoop() chiamato');
  });
});



function forceRestartDuelLoop() {
  duelGameActive = false;
  setTimeout(() => {
    duelGameActive = true;
    startDuelLoop();
  }, 50); // piccolo delay, serve a "sbloccare" eventuali stalli
}


function showDuelRoundOverlay(status, round) {
  let msg = "";
  if (status === "win") msg = "‚úÖ HAI VINTO IL ROUND " + round + "!";
  else if (status === "lose") msg = "‚ùå HAI PERSO IL ROUND " + round + "!";
  else if (status === "draw") msg = "ü§ù PAREGGIO nel round " + round;
  else msg = status;
  document.getElementById("duelRoundOverlayMsg").textContent = msg;
  document.getElementById("duelRoundOverlay").style.display = "block";
}

function hideDuelRoundOverlay() {
  document.getElementById("duelRoundOverlay").style.display = "none";
}


function showNextRoundOverlay(roundNum, maxRounds, seconds, cb) {
  const overlay = document.getElementById('duelRoundOverlay');
  const msg = document.getElementById('duelRoundOverlayMsg');
  const countdown = document.getElementById('duelNextRoundCountdown');
  overlay.style.display = 'block';
  msg.textContent = `üåÄ ROUND ${roundNum} / ${maxRounds}`;
  
  let remaining = seconds;
  countdown.textContent = `Prossimo round in ${remaining}...`;

  const interval = setInterval(() => {
    remaining--;
    if (remaining > 0) {
      countdown.textContent = `Prossimo round in ${remaining}...`;
    } else {
      clearInterval(interval);
      overlay.style.display = 'none';
      countdown.textContent = '';
      if (typeof cb === "function") cb(); // <---- QUESTA RIGA!!
    }
  }, 1000);
}



function updateDuelScoreBar(p1Score, round, p2Score) {
  document.getElementById('scorePlayer1').innerHTML = `üë§ You: <b>${p1Score}</b>`;
  document.getElementById('scorePlayer2').innerHTML = `Opponent: <b>${p2Score}</b>`;
  document.getElementById('scoreRound').innerHTML = `Round: <b>${round}</b>/3`;
}


function startDuelEntryAnimation() {
  duelEntryAnimation.active = true;
  duelEntryAnimation.progress = 0;
}


function showDuelLoadingScreen(player1, ship1, elo1, player2, ship2, elo2, phrase) {
  document.getElementById('duelLoadNick1').textContent = player1;
  document.getElementById('duelLoadShip1').src = ship1;
  document.getElementById('duelLoadElo1').textContent = elo1;
  document.getElementById('duelLoadNick2').textContent = player2;
  document.getElementById('duelLoadShip2').src = ship2;
  document.getElementById('duelLoadElo2').textContent = elo2;
  document.getElementById('duelLoadingPhrase').textContent = phrase || "Prepare for cosmic battle!";
  document.getElementById('duelLoadingScreen').style.display = 'flex';

  let count = 3;
  document.getElementById('duelLoadingCountdown').textContent = count;
  const interval = setInterval(() => {
    count--;
    if (count > 0) {
      document.getElementById('duelLoadingCountdown').textContent = count;
    } else if (count === 0) {
      document.getElementById('duelLoadingCountdown').textContent = "GO!";
    } else {
      clearInterval(interval);
      hideDuelLoadingScreen();
      startDuelGame(); // Avvia la partita 1v1!
    }
  }, 1000);
}

function hideDuelLoadingScreen() {
  document.getElementById('duelLoadingScreen').style.display = 'none';
}


function showGoOverlay(text = "GO!", duration = 900) {
  const el = document.getElementById('duelGoOverlay');
  el.textContent = text;
  el.style.display = 'block';
  el.style.opacity = '1';
  el.style.transform = 'translate(-50%,-50%) scale(1.3)';
  setTimeout(() => {
    el.style.opacity = '0';
    el.style.transform = 'translate(-50%,-50%) scale(1.0)';
    setTimeout(() => { el.style.display = 'none'; }, 500);
  }, duration);
}


// ---- PATCH: DUEL BOT CON DIFFICOLT√Ä E MOVIMENTO INTELLIGENTE ----



const params = getDuelBotParams();
const speed = params.speed * (duelBotDifficulty === "insane" ? 4 : 3);
  duelBot.y = 90; // sempre alto
  duelBot.x += speed * botDirection;
  if (duelBot.x < 100 || duelBot.x > canvas.width - 100) botDirection *= -1;

  duelBot.cooldownShoot = Math.max(0, duelBot.cooldownShoot-1);

  if (duelBot.cooldownShoot <= 0) {
    shootAsBot();
duelBot.cooldownShoot = getDuelBotParams().fireRate * 60 + Math.random() * 16;  
}


function shootAsBot() {
  const params = getDuelBotParams();
  const dx = gameState.player.x - duelBot.x;
  const dy = gameState.player.y - duelBot.y;
  const dist = Math.sqrt(dx*dx + dy*dy) || 1;
  const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * params.aimError * (Math.PI/180);

  gameState.enemyBullets.push({
    x: duelBot.x,
    y: duelBot.y + 40,
    vx: Math.cos(angle) * params.bulletSpeed,
    vy: Math.sin(angle) * params.bulletSpeed,
    color: "#ffd700",
    size: params.size,
    damage: params.damage
  });

  // Limita proiettili
  if (gameState.enemyBullets.length > 12) {
    gameState.enemyBullets = gameState.enemyBullets.slice(-12);
  }
}

function renderDuelBot(ctx) {
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.drawImage(playerImage, duelBot.x - 32, duelBot.y - 32, 64, 64);
  ctx.restore();
}



function startDuelAIBoss() {
  gameState.gameMode = "duelAI";
  // Player come sempre
  gameState.player.x = 100;
  gameState.player.y = 600;
  gameState.player.health = 500;
  gameState.player.energy = 100;
  gameState.player.maxHealth = 500;
  gameState.player.maxEnergy = 100;

  
  const params = getDuelBotParams();
duelBot.health = params.health;
duelBot.maxHealth = params.health;
  
  
  // Prendi un boss difficile dal LEVEL_DATA
  const levelIndex = 10; // Scegli il boss che vuoi, qui √® livello 11 (indice 10)
  const bossData = LEVEL_DATA[levelIndex];
  gameState.enemy = {
    ...bossData,
    x: canvas.width / 2,
    y: 120,
    health: bossData.health,
    maxHealth: bossData.health,
    speed: bossData.speed,
    attackPatterns: bossData.attackPatterns,
    phases: bossData.phases,
    attackCooldown: 0,
    moveDirection: 1,
    angle: 0
  };

  gameState.bullets = [];
  gameState.enemyBullets = [];
  gameState.particles = [];

  showScreen('gameScreen');
  gameState.gameRunning = true;
  gameLoop();
}

// (poi puoi chiamare startDuelAIBoss() dal menu)

// Applica la difficolt√† scelta dal menu
document.getElementById('duelBotDifficultySelect').value = duelBotDifficulty;
document.getElementById('duelBotDifficultySelect').addEventListener('change', function() {
  duelBotDifficulty = this.value;
  localStorage.setItem('duelBotDifficulty', duelBotDifficulty);
});



// --- FUNZIONE COLLISIONI DUEL BOT (1v1 BOT) ---
function checkDuelAICollisions() {
  // Player colpisce bot
  for (let i = gameState.bullets.length - 1; i >= 0; i--) {
    const b = gameState.bullets[i];
    const dx = b.x - duelBot.x;
    const dy = b.y - duelBot.y;
    if (Math.sqrt(dx*dx + dy*dy) < 32) {
      duelBot.health -= b.damage || 20;
      gameState.bullets.splice(i, 1);
    }
  }
  // Bot colpisce player
  for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
    const b = gameState.enemyBullets[i];
    const dx = b.x - gameState.player.x;
    const dy = b.y - gameState.player.y;
    if (Math.sqrt(dx*dx + dy*dy) < 32) {
      gameState.player.health -= b.damage || 20;
      gameState.enemyBullets.splice(i, 1);
    }
  }
}

function updateDuelBot() {
  const params = getDuelBotParams();
  // Movimento orizzontale intelligente
  const speed = params.speed * (duelBotDifficulty === "insane" ? 4 : 3);
  duelBot.y = 90; // sempre in alto
  duelBot.x += speed * botDirection;
  if (duelBot.x < 100 || duelBot.x > canvas.width - 100) botDirection *= -1;

  // Sparo
  duelBot.cooldownShoot = Math.max(0, duelBot.cooldownShoot - 1);
  if (duelBot.cooldownShoot <= 0) {
    shootAsBot();
    duelBot.cooldownShoot = params.fireRate * 60 + Math.random() * 16;
  }
}

// --- PATCH PERFORMANCE: riduci proiettili nemici su mobile ---
function getMobileBulletParams(count, speed) {
  // Se sei su mobile, riduci il numero di proiettili e la loro velocit√† per evitare lag
  if (isMobileDevice()) {
    return {
      count: Math.max(1, Math.round(count * 0.6)),    // -40% proiettili
      speed: speed * 1.1                              // +10% velocit√† per bilanciare
    };
  }
  // Desktop: tutto normale
  return { count, speed };
}

// Applica ovunque chiami pattern bullet nemici:
// Sostituisci
// for (let i = 0; i < enemy.bulletCount; i++) { ... }
// con:
const mobileParams = getMobileBulletParams(enemy.bulletCount, enemy.bulletSpeed || 4);
for (let i = 0; i < mobileParams.count; i++) { /* ... usa mobileParams.speed ... */ }

// --- PATCH PARTICELLE: riduci quantit√† su mobile ---
function spawnSuperExplosion(x, y, opts = {}) {
  const isMobile = isMobileDevice && isMobileDevice();
  const colors = opts.colors || ["#fff", "#ff0044", "#14fc56", "#00cfff", "#ffd700"];
  // Se mobile, max 12 particelle, desktop 70
  const count = isMobile ? Math.min(opts.count || 18, 12) : Math.min(opts.count || 70, 18);
  for (let i = 0; i < count; i++) {
    // ... come tuo codice ...
  }
}
// Stessa logica per altre funzioni di spawn particelle (hit, trail, ecc)


// --- PATCH CANVAS RESPONSIVE RETINA ---
function resizeCanvas() {
  const canvas = document.getElementById('gameCanvas');
  // Landscape mobile: limita canvas!
  if (isMobileDevice() && window.innerWidth > window.innerHeight) {
    canvas.width = 640;   // max larghezza
    canvas.height = 360;  // max altezza
    canvas.style.width = '100vw';
    canvas.style.height = '100vh';
  } else if (isMobileDevice()) {
    // Portrait mobile
    canvas.width = 420;
    canvas.height = 720;
    canvas.style.width = '100vw';
    canvas.style.height = '80vh';
  } else {
    // Desktop
    canvas.width = 1280;
    canvas.height = 720;
    canvas.style.width = '1280px';
    canvas.style.height = '720px';
  }
  canvas.style.display = "block";
  canvas.style.margin = "auto";
}

function showDuelRoundOverlay(status, round) {
  let msg = "";
  let color = "#fff";
  
  // EFFETTI SPECIALI
  if (status === "win") {
    msg = "‚úÖ HAI VINTO IL ROUND " + round + "!";
    color = "#ffd700";
    playDuelSound("win");        // SUONO VITTORIA
    flashScreen("#ffe700", 0.35); // FLASH GIALLO
    esplodiGiocatore(gameState.player); // PARTICELLE SULLA TUA NAVICELLA
  }
  else if (status === "lose") {
    msg = "‚ùå HAI PERSO IL ROUND " + round + "!";
    color = "#f44336";
    playDuelSound("lose");        // SUONO SCONFITTA
    flashScreen("#f44336", 0.35); // FLASH ROSSO
    esplodiGiocatore(gameState.opponentState); // PARTICELLE SULL'AVVERSARIO
  }
  else if (status === "draw") {
    msg = "ü§ù PAREGGIO nel round " + round;
    color = "#00bcd4";
    playDuelSound("draw");        // SUONO PAREGGIO
    flashScreen("#00bcd4", 0.35); // FLASH BLU
  }
  else {
    msg = status;
    color = "#fff";
  }

  document.getElementById("duelRoundOverlayMsg").textContent = msg;
  document.getElementById("duelRoundOverlayMsg").style.color = color;
  document.getElementById("duelRoundOverlay").style.display = "block";
}

function hideDuelRoundOverlay() {
  document.getElementById("duelRoundOverlay").style.display = "none";
}


function playDuelSound(type) {
  let audio;
  if (type === "win") audio = document.getElementById('duelWinSound');
  if (type === "lose") audio = document.getElementById('duelLoseSound');
  if (type === "draw") audio = document.getElementById('duelDrawSound');
  if (audio) { audio.currentTime = 0; audio.play(); }
}

function flashScreen(color = "#fff", strength = 0.4) {
  const flash = document.createElement('div');
  flash.style.position = 'fixed';
  flash.style.top = '0'; flash.style.left = '0'; flash.style.width = '100vw'; flash.style.height = '100vh';
  flash.style.background = color;
  flash.style.opacity = strength;
  flash.style.zIndex = 99999;
  flash.style.transition = "opacity 0.7s";
  document.body.appendChild(flash);
  setTimeout(() => { flash.style.opacity = "0"; }, 400);
  setTimeout(() => { flash.remove(); }, 900);
}


function submitDuelScore(username, elo) {
  const dreamloKey = "5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw";
  const tag = "duel1v1";
  // üî• Usa /update/ per forzare l'aggiornamento (anche se l'ELO scende)
  const url = `https://dreamlo.com/lb/${dreamloKey}/update/${encodeURIComponent(username)}/${elo}/${tag}`;
  fetch(url)
    .then(() => console.log("Duel 1v1 ELO aggiornato su Dreamlo!"))
    .catch(err => console.error("Dreamlo errore:", err));
}


// Aggiungi questo HTML dopo il duelLobby esistente
function create2v2LobbyHTML() {
  if (document.getElementById('duel2v2Lobby')) return;
  
  const lobby2v2 = document.createElement('div');
  lobby2v2.id = 'duel2v2Lobby';
  lobby2v2.className = 'duel-lobby hidden';
  lobby2v2.innerHTML = `
    <div class="duel-header">‚öîÔ∏è 2v2 TEAM DUELS</div>
    <div style="display:flex;justify-content:space-around;margin:1.5rem 0;">
      <!-- Team 1 -->
      <div style="text-align:center;">
        <div style="color:#00bcd4;font-weight:bold;font-size:1.3rem;margin-bottom:0.8rem;">TEAM 1</div>
        <div style="display:flex;gap:1rem;">
          <div class="duel-player">
            <img id="team1Ship1" class="duel-ship" src="navicella1.png"/>
            <div id="team1Nick1" class="duel-nick">Waiting...</div>
          </div>
          <div class="duel-player">
            <img id="team1Ship2" class="duel-ship" src="navicella1.png"/>
            <div id="team1Nick2" class="duel-nick">Waiting...</div>
          </div>
        </div>
      </div>
      
      <!-- VS -->
      <div class="duel-vs" style="align-self:center;">VS</div>
      
      <!-- Team 2 -->
      <div style="text-align:center;">
        <div style="color:#ffd700;font-weight:bold;font-size:1.3rem;margin-bottom:0.8rem;">TEAM 2</div>
        <div style="display:flex;gap:1rem;">
          <div class="duel-player">
            <img id="team2Ship1" class="duel-ship" src="navicella2.png"/>
            <div id="team2Nick1" class="duel-nick">Waiting...</div>
          </div>
          <div class="duel-player">
            <img id="team2Ship2" class="duel-ship" src="navicella2.png"/>
            <div id="team2Nick2" class="duel-nick">Waiting...</div>
          </div>
        </div>
      </div>
    </div>
    <div id="duel2v2Status" class="duel-status">Looking for players... (1/4)</div>
    <button class="menu-btn" id="duel2v2CancelBtn">Cancel</button>
  `;
  
  document.body.appendChild(lobby2v2);
  
  // IMPORTANTE: Collega l'evento DOPO aver creato l'elemento!
  const cancelBtn = document.getElementById('duel2v2CancelBtn');
  if (cancelBtn) {
    cancelBtn.onclick = function() {
      console.log("Cancel 2v2 clicked!"); // Debug
      const lobby = document.getElementById('duel2v2Lobby');
      if (lobby) {
        lobby.classList.add('hidden');
      }
      if (window.socket) {
        window.socket.emit("duel2v2_cancel");
      }
    };
  }
}

// Chiama questa funzione all'avvio
window.addEventListener('DOMContentLoaded', create2v2LobbyHTML);


function startDuel2v2Queue() {
  // CREA L'ELEMENTO SE NON ESISTE
  if (!document.getElementById('duel2v2Lobby')) {
    create2v2LobbyHTML();
  }
  
  const lobby = document.getElementById('duel2v2Lobby');
  if (!lobby) {
    console.error("Impossibile creare lobby 2v2!");
    return;
  }
  
  // Ora puoi usarlo in sicurezza
  lobby.classList.remove('hidden');
  document.getElementById('duel2v2Status').textContent = "Looking for players... (1/4)";
  
  // Resto del codice...
  if (location.protocol === 'file:') {
    document.getElementById('duel2v2Status').textContent = "Demo Mode - No server";
    // Simula matchmaking per test
    setTimeout(() => {
      update2v2Lobby({
        players: [
          { nickname: getPlayerName(), skin: getSelectedShipImage() },
          { nickname: "Waiting...", skin: "navicella2.png" }
        ],
        count: 2
      });
    }, 1000);
    return;
  }
  
  // PATCH: usa sempre il server 2v2
  if (!window.socket || window.socket.io.uri !== SERVER_2V2_URL) {
    if (window.socket) window.socket.disconnect();
    window.socket = io(SERVER_2V2_URL);
    setup2v2Listeners();
  }
  
  window.socket.emit("duel2v2_queue", {
    nickname: getPlayerName(),
    skin: getSelectedShipImage(),
    elo: gameState.elo || 1000
  });
}

function setup2v2Listeners() {
  if (!window.socket) return;
  
  // Pulizia listener precedenti
  window.socket.off('duel2v2_update');
  window.socket.off('duel2v2_ready');
  window.socket.off('duel2v2_state');
  window.socket.off('duel2v2_end');
  
  // Aggiornamento lobby
  window.socket.on('duel2v2_update', (data) => {
    update2v2Lobby(data);
  });
  
  // Match pronto
window.socket.on('duel2v2_ready', (data) => {
  console.log('[duel2v2_ready]', data);

  duel2v2Team = data.yourTeam;
  duel2v2Players = data.players;

  // PATCH: trasforma array [p1,p2,p3,p4] in {team1: [p1,p2], team2: [p3,p4]} se serve
  if (Array.isArray(duel2v2Players) && duel2v2Players.length === 4) {
    duel2v2Players = {
      team1: [duel2v2Players[0], duel2v2Players[1]],
      team2: [duel2v2Players[2], duel2v2Players[3]],
    };
  }

  duel2v2TeamMate = data.teammate;
  duel2v2Opponents = data.opponents;
  start2v2Countdown();
});
  // Stato di gioco
  window.socket.on('duel2v2_state', (data) => {
    update2v2GameState(data);
  });
  
  // Fine partita
  window.socket.on('duel2v2_end', (data) => {
    show2v2EndScreen(data);
  });
}


function update2v2Lobby(data) {
  const { players, count } = data;
  
  // Reset all slots
  ['team1Nick1', 'team1Nick2', 'team2Nick1', 'team2Nick2'].forEach(id => {
    document.getElementById(id).textContent = 'Waiting...';
  });
  
  // Fill slots with players
  players.forEach((player, index) => {
    const team = index < 2 ? 'team1' : 'team2';
    const slot = index % 2 + 1;
    document.getElementById(`${team}Nick${slot}`).textContent = player.nickname;
    document.getElementById(`${team}Ship${slot}`).src = player.skin;
  });
  
  document.getElementById('duel2v2Status').textContent = `Looking for players... (${count}/4)`;
  
  if (count === 4) {
    document.getElementById('duel2v2Status').textContent = "Match starting!";
  }
}



// PATCH: Nascondi la lobby e mostra la partita quando parte il 2v2
function init2v2Arena() {
  // Forza la modalit√† 2v2!
  gameState.gameMode = 'duel2v2';

  // DEBUG: mostra i dati ricevuti
  console.log("[init2v2Arena] mode:", gameState.gameMode, 
              "duel2v2Team:", duel2v2Team, 
              "duel2v2Players:", duel2v2Players,
              "duel2v2TeamMate:", duel2v2TeamMate,
              "duel2v2Opponents:", duel2v2Opponents);

  // Nascondi la lobby 2v2 se ancora visibile
  const lobby = document.getElementById('duel2v2Lobby');
  if (lobby) lobby.classList.add('hidden');
  
  // Passa allo schermo di gioco
  showScreen('gameScreen');
  
  // --- POSIZIONI INIZIALI ---
  const positions = {
    team1: [
      { x: 100, y: canvas.height - 150 },
      { x: 250, y: canvas.height - 150 }
    ],
    team2: [
      { x: canvas.width - 250, y: 150 },
      { x: canvas.width - 100, y: 150 }
    ]
  };

  // Setup del tuo player
  if (duel2v2Team === 'team1') {
    gameState.player.x = positions.team1[0].x;
    gameState.player.y = positions.team1[0].y;
  } else {
    gameState.player.x = positions.team2[0].x;
    gameState.player.y = positions.team2[0].y;
  }

  gameState.player.health = 400;
  gameState.player.maxHealth = 400;
  gameState.player.energy = 100;

  // Inizializza array teammates/opponents
  gameState.teammates = [];
  gameState.opponents = [];

  let myId = mySocketId || (window.socket && window.socket.id);

  // PATCH: fallback array vuoto se non definito
  let teamArr = [];
  let oppArr = [];

  // Compatibilit√†: se il server invia un array, patcha subito
  if (Array.isArray(duel2v2Players) && duel2v2Players.length === 4) {
    duel2v2Players = {
      team1: [duel2v2Players[0], duel2v2Players[1]],
      team2: [duel2v2Players[2], duel2v2Players[3]],
    };
  }

  if (duel2v2Players && typeof duel2v2Players === "object") {
    teamArr = Array.isArray(duel2v2Players.team1) && duel2v2Team === "team1" ? duel2v2Players.team1 : 
              Array.isArray(duel2v2Players.team2) && duel2v2Team === "team2" ? duel2v2Players.team2 : [];
    oppArr = Array.isArray(duel2v2Players.team1) && duel2v2Team === "team2" ? duel2v2Players.team1 : 
             Array.isArray(duel2v2Players.team2) && duel2v2Team === "team1" ? duel2v2Players.team2 : [];
  }

  // Trova il compagno (non tu)
  let teammate = teamArr.find && teamArr.length ? teamArr.find(p => p.id !== myId) : null;
  if (teammate) {
    teammate.x = duel2v2Team === 'team1' ? positions.team1[1].x : positions.team2[1].x;
    teammate.y = duel2v2Team === 'team1' ? positions.team1[1].y : positions.team2[1].y;
    gameState.teammates = [teammate];
  } else {
    gameState.teammates = [];
    console.warn("init2v2Arena: teammate not found!", { teamArr, myId });
  }

  // Opponenti: entrambi gli avversari
  if (Array.isArray(oppArr) && oppArr.length) {
    oppArr.forEach((opp, idx) => {
      opp.x = positions.team2[idx].x;
      opp.y = positions.team2[idx].y;
    });
    gameState.opponents = oppArr;
  } else {
    gameState.opponents = [];
    console.warn("init2v2Arena: opponents not found!", { oppArr });
  }

  duel2v2Active = true;

  // Log finale dei player per debug
  console.log("[init2v2Arena] teammates:", gameState.teammates, "opponents:", gameState.opponents);

  start2v2Loop();
}


function render2v2Players(ctx) {
  // PATCH: debug - mostra lo stato dei dati
  console.log("render2v2Players:", {
    duel2v2TeamMate,
    duel2v2Opponents
  });

  // Render teammate (se esiste)
  if (duel2v2TeamMate && typeof duel2v2TeamMate === "object") {
    renderTeammate(ctx, duel2v2TeamMate);
  }

  // Render opponents (array, fallback vuoto)
  (Array.isArray(duel2v2Opponents) ? duel2v2Opponents : []).forEach(opp => {
    if (opp && typeof opp === "object") {
      renderOpponent2v2(ctx, opp);
    }
  });
}

function renderTeammate(ctx, teammate) {
  ctx.save();
  ctx.globalAlpha = 0.9;
  
  // Indicatore teammate (contorno verde)
  ctx.strokeStyle = '#4caf50';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(teammate.x, teammate.y, 40, 0, Math.PI * 2);
  ctx.stroke();
  
  // Navicella
  const img = new Image();
img.src = getShipImageFromId(teammate.skin); // ‚¨ÖÔ∏è GIUSTO!

  function getShipImageFromId(id) {
  switch (id) {
    case "ship1": return "navicella1.png";
    case "ship2": return "navicella2.png";
    case "ship3": return "navicella3.png";
    case "ship4": return "navicella4.png";
    case "summer": return "navicella-summer.png";
    default: return "navicella1.png";
  }
}
  ctx.drawImage(img, teammate.x - 32, teammate.y - 32, 64, 64);
  
  // Nome e HP
  ctx.font = "bold 14px Orbitron";
  ctx.fillStyle = '#4caf50';
  ctx.textAlign = 'center';
  ctx.fillText(teammate.nickname, teammate.x, teammate.y - 45);
  
  // Barra vita
  const hpPercent = teammate.health / 400;
  ctx.fillStyle = hpPercent > 0.5 ? '#4caf50' : '#ffd700';
  ctx.fillRect(teammate.x - 30, teammate.y - 55, 60 * hpPercent, 5);
  
  ctx.restore();
}

function renderOpponent2v2(ctx, opponent) {
  ctx.save();
  ctx.globalAlpha = 0.9;
  
  // Indicatore nemico (contorno rosso)
  ctx.strokeStyle = '#f44336';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(opponent.x, opponent.y, 40, 0, Math.PI * 2);
  ctx.stroke();
  
  // Navicella
  const img = new Image();
img.src = getShipImageFromId(opponent.skin);  
ctx.drawImage(img, opponent.x - 32, opponent.y - 32, 64, 64);
  
  // Nome e HP
  ctx.font = "bold 14px Orbitron";
  ctx.fillStyle = '#f44336';
  ctx.textAlign = 'center';
  ctx.fillText(opponent.nickname, opponent.x, opponent.y - 45);
  
  // Barra vita
  const hpPercent = opponent.health / 400;
  ctx.fillStyle = hpPercent > 0.5 ? '#4caf50' : '#f44336';
  ctx.fillRect(opponent.x - 30, opponent.y - 55, 60 * hpPercent, 5);
  
  ctx.restore();
}


// 1. Invio della posizione e stato al server ogni frame
function sync2v2State() {
  if (!duel2v2Active || !window.socket) return;
  window.socket.emit("duel2v2_update", {
    room: duelRoomId,
    player: {
      x: gameState.player.x,
      y: gameState.player.y,
      health: gameState.player.health,
      energy: gameState.player.energy,
      angle: gameState.player.angle,
      team: duel2v2Team
    },
    bullets: gameState.bullets.map(b => ({
      x: b.x,
      y: b.y,
      vx: b.vx,
      vy: b.vy,
      damage: b.damage,
      team: duel2v2Team
    }))
  });
}


function check2v2Collisions() {
    // Tu prendi danno SOLO dai proiettili del team avversario!
  gameState.bullets.forEach((bullet, idx) => {
    if (bullet.team === duel2v2Team) return;
    const dist = Math.sqrt((bullet.x - gameState.player.x) ** 2 + (bullet.y - gameState.player.y) ** 2);
    if (dist < 32) {
      gameState.player.health -= bullet.damage;
      gameState.bullets.splice(idx, 1);
      createHitParticles(bullet.x, bullet.y, '#f44336');
    }
  });

  // 2. Il tuo compagno prende danno SOLO dai proiettili del team avversario
  if (duel2v2TeamMate) {
    gameState.bullets.forEach((bullet, idx) => {
      if (bullet.team === duel2v2Team) return; // ignora i proiettili del tuo team
      const dist = Math.sqrt((bullet.x - duel2v2TeamMate.x) ** 2 + (bullet.y - duel2v2TeamMate.y) ** 2);
      if (dist < 32) {
        duel2v2TeamMate.health -= bullet.damage;
        gameState.bullets.splice(idx, 1);
        createHitParticles(bullet.x, bullet.y, '#f44336');
      }
    });
  }

  // 3. Gli avversari prendono danno SOLO dai tuoi proiettili
  (Array.isArray(duel2v2Opponents) ? duel2v2Opponents : []).forEach(opponent => {
    gameState.bullets.forEach((bullet, idx) => {
      if (bullet.team !== duel2v2Team) return; // solo i proiettili del tuo team
      const dist = Math.sqrt((bullet.x - opponent.x) ** 2 + (bullet.y - opponent.y) ** 2);
      if (dist < 32) {
        opponent.health -= bullet.damage;
        gameState.bullets.splice(idx, 1);
        createHitParticles(bullet.x, bullet.y, '#ffd700');
      }
    });
  });

  // 4. PATCH: Safe fallback se assenti
  const team1Arr = Array.isArray(duel2v2Players.team1) ? duel2v2Players.team1 : [];
  const team2Arr = Array.isArray(duel2v2Players.team2) ? duel2v2Players.team2 : [];

  // 5. Check vittoria condizioni
  const team1Alive = team1Arr.some(p => p.health > 0);
  const team2Alive = team2Arr.some(p => p.health > 0);

  if (!team1Alive || !team2Alive) {
    window.socket.emit("duel2v2_victory", {
      room: duelRoomId,
      winningTeam: team1Alive ? 'team1' : 'team2'
    });
  }
}


function start2v2Loop() {
  showScreen('gameScreen'); // Forza la schermata di gioco ogni volta

  function loop2v2() {
    if (!duel2v2Active) return;
    updatePlayer(1);
    update2v2Players();
        checkPlayerDeaths(); // <-- CHIAMA QUI SUBITO DOPO!

    updateBullets(1);
    check2v2Collisions();
    sync2v2State();
    render(); // <-- render fa gi√† tutto!
    requestAnimationFrame(loop2v2);
  }
  loop2v2();
}

function render2v2UI() {
  ctx.save();
  ctx.font = "bold 20px Orbitron";
  // PATCH robusto!
  const team1Arr = Array.isArray(duel2v2Players?.team1) ? duel2v2Players.team1 : [];
  const team2Arr = Array.isArray(duel2v2Players?.team2) ? duel2v2Players.team2 : [];
  ctx.fillStyle = '#00bcd4';
  ctx.fillText(`TEAM 1: ${team1Arr.filter(p => p.health > 0).length}/2`, 50, 30);
  ctx.fillStyle = '#ffd700';
  ctx.fillText(`TEAM 2: ${team2Arr.filter(p => p.health > 0).length}/2`, canvas.width - 150, 30);
  ctx.restore();
}


function show2v2EndScreen(data) {
  const won = data.winningTeam === duel2v2Team;
  const screen = document.createElement('div');
  screen.className = 'duel-end';
  screen.innerHTML = `
    <div style="font-size:3rem;color:${won ? '#ffd700' : '#f44336'};">
      ${won ? 'üèÜ TEAM VICTORY!' : 'üòµ TEAM DEFEAT'}
    </div>
    <div style="margin:1.5rem 0;">
      <div>Your Team: ${data.stats[duel2v2Team].kills} kills</div>
      <div>Enemy Team: ${data.stats[data.winningTeam === 'team1' ? 'team2' : 'team1'].kills} kills</div>
    </div>
    <button class="menu-btn" onclick="queue2v2Again()">Play Again</button>
    <button class="menu-btn" onclick="backToMenu2v2()">Main Menu</button>
  `;
  document.body.appendChild(screen);
}


// Migliora la visualizzazione voice chat
function renderVoiceIndicator(ctx, player) {
  if (playerVoiceStatus[player.id]) {
    ctx.save();
    ctx.fillStyle = '#4caf50';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('üé§', player.x, player.y - 50);
    
    // Animazione onda sonora
    ctx.strokeStyle = '#4caf50';
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.arc(player.x, player.y, 40 + Math.sin(Date.now() * 0.01) * 5, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
}


function checkTeamCombo() {
  const now = Date.now();
  let playersShootingNow = 0;

  // Conta gli altri
  for (let id in otherPlayers) {
    if (lastTeamShot[id] && now - lastTeamShot[id] < 500) {
      playersShootingNow++;
    }
  }
  // Conta anche te stesso
  if (gameState.keys['shoot'] || gameState.touchControls.shooting) {
    playersShootingNow++;
    lastTeamShot[mySocketId] = now;
  }

  // Se tutti sparano insieme, attiva combo!
  if (playersShootingNow >= coopPlayers.length) {
    teamComboMeter = Math.min(100, teamComboMeter + 10);
    if (teamComboMeter >= 100) {
      activateTeamUltimate();
      teamComboMeter = 0;
    }
  }

  // Decadimento combo
  teamComboMeter = Math.max(0, teamComboMeter - 0.5);
}

function activateTeamUltimate() {
  showNotification("üí• TEAM ULTIMATE ATTIVATO!", "achievement");
  for (let i = 0; i < 50; i++) {
    setTimeout(() => {
      gameState.bullets.push({
        x: gameState.player.x,
        y: gameState.player.y,
        vx: 0,
        vy: -20,
        color: '#ffd700',
        size: 30,
        damage: 100,
        teamUltimate: true
      });
    }, i * 50);
  }
  startFlash(0.5);
  startShake(20, 30);
}


function renderCoopMinimap() {
  const minimapSize = 150;
  const minimapX = canvas.width - minimapSize - 20;
  const minimapY = 20;
  
  // Sfondo minimappa
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(minimapX, minimapY, minimapSize, minimapSize);
  ctx.strokeStyle = '#00bcd4';
  ctx.strokeRect(minimapX, minimapY, minimapSize, minimapSize);
  
  // Boss sulla minimappa
  if (gameState.enemy) {
    const bossX = minimapX + (gameState.enemy.x / canvas.width) * minimapSize;
    const bossY = minimapY + (gameState.enemy.y / canvas.height) * minimapSize;
    ctx.fillStyle = '#f44336';
    ctx.beginPath();
    ctx.arc(bossX, bossY, 5, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Tu sulla minimappa
  const myX = minimapX + (gameState.player.x / canvas.width) * minimapSize;
  const myY = minimapY + (gameState.player.y / canvas.height) * minimapSize;
  ctx.fillStyle = '#00ff00';
  ctx.beginPath();
  ctx.arc(myX, myY, 3, 0, Math.PI * 2);
  ctx.fill();
  
  // Alleati sulla minimappa
  for (let id in otherPlayers) {
    const ally = otherPlayers[id];
    const allyX = minimapX + (ally.x / canvas.width) * minimapSize;
    const allyY = minimapY + (ally.y / canvas.height) * minimapSize;
    ctx.fillStyle = ally.isDown ? '#ff0000' : '#00bcd4';
    ctx.beginPath();
    ctx.arc(allyX, allyY, 3, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.restore();
}

// Aggiungi in render() quando gameMode === 'coop':
if (gameState.gameMode === 'coop') {
  renderCoopMinimap();
}


function tryReviveTeammate() {
  if (
    gameState.gameMode === "coop" &&
    gameState.player.health <= 0 &&
    gameState.player.reviveCount < gameState.player.maxRevives
  ) {
    // Resuscita il giocatore
    gameState.player.health = Math.floor(gameState.player.maxHealth * 0.5); // Torna con met√† vita
    gameState.player.reviveCount++;
    showNotification("üíö Sei stato resuscitato dal team! (max 1 volta)", "achievement");
  }
}


// Quando termina una partita 2v2
function on2v2MatchEnd(winningTeam, team1Elo, team2Elo) {
  // Calcola ELO
  const K = 32;
  const expected1 = 1 / (1 + Math.pow(10, (team2Elo - team1Elo) / 400));
  const expected2 = 1 / (1 + Math.pow(10, (team1Elo - team2Elo) / 400));
  const score1 = winningTeam === 'team1' ? 1 : 0;
  const score2 = 1 - score1;

  const newTeam1Elo = Math.round(team1Elo + K * (score1 - expected1));
  const newTeam2Elo = Math.round(team2Elo + K * (score2 - expected2));

  // Salva i nuovi valori (Dreamlo, DB, localStorage, ecc)
  saveTeamElo('team1', newTeam1Elo, currentSeason);
  saveTeamElo('team2', newTeam2Elo, currentSeason);

  // Mostra in HUD e leaderboards
}


function fetchTeam2v2Leaderboard(season, callback) {
  const dreamloKey = "5z7d7N8IBkSwrhJdyZAXxAYn3Jv1KyTEm6GJZoIALRBw";
  const tag = `${season}_team2v2`;
  fetch(`https://dreamlo.com/lb/${dreamloKey}/pipe-get/${tag}`)
    .then(res => res.text())
    .then(txt => {
      // Esempio parsing e callback
      const rows = txt.trim().split('\n');
      const leaderboard = rows
        .map(row => {
          const [team, elo] = row.split('|');
          if (!team || isNaN(parseInt(elo))) return null;
          return { team, elo: parseInt(elo) };
        })
        .filter(entry => entry !== null)
        .sort((a, b) => b.elo - a.elo);
      if (typeof callback === "function") callback(leaderboard);
    });
}


function checkSeasonReset() {
  const now = Date.now();
  const seasonStart = localStorage.getItem("seasonStart") || now;
  if (now - seasonStart > SEASON_LENGTH_MS) {
    // Nuova stagione!
    currentSeason = getNextSeason(currentSeason);
    localStorage.setItem("seasonStart", now);
    resetAllTeamElo();
    showNotification("Nuova stagione iniziata!", "achievement");
  }
}


function showTeam2v2Leaderboard() {
  showScreen('team2v2LeaderboardScreen');
  document.getElementById('team2v2LeaderboardList').innerHTML = 'Loading...';
  fetchTeam2v2Leaderboard(currentSeason, leaderboard => {
    let html = '<ol style="font-size:1.2rem;">';
    leaderboard.forEach(entry => {
      html += `<li><b>${entry.team.replace(/_/g, " / ")}</b> ‚Äî <span style="color:#ffd700;">ELO: ${entry.elo}</span></li>`;
    });
    if (leaderboard.length === 0) html += "<li>No team scores yet!</li>";
    html += '</ol>';
    document.getElementById('team2v2LeaderboardList').innerHTML = html;
  });
}


function start2v2Countdown() {
  let count = 3;
  const lobby = document.getElementById('duel2v2Lobby');
  const status = document.getElementById('duel2v2Status');
  status.textContent = "Match starting in " + count + "...";
  const interval = setInterval(() => {
    count--;
    if (count > 0) {
      status.textContent = "Match starting in " + count + "...";
    } else {
      status.textContent = "Battle!";
    }
    if (count <= 0) {
      clearInterval(interval);
      lobby.classList.add('hidden');
      // IMPORTANTE: chiama showScreen prima di avviare la partita!
      showScreen('gameScreen');
      init2v2Arena();
      start2v2Loop();
    }
  }, 1000);
}


// 3. Interpolazione della posizione di compagno e avversari (smooth movement)
function update2v2Players() {
  // Interpola teammate
  if (duel2v2TeamMate && duel2v2TeamMate.targetX !== undefined && duel2v2TeamMate.targetY !== undefined) {
    duel2v2TeamMate.x += (duel2v2TeamMate.targetX - duel2v2TeamMate.x) * 0.3;
    duel2v2TeamMate.y += (duel2v2TeamMate.targetY - duel2v2TeamMate.y) * 0.3;
    // Interpola anche health/energy se vuoi effetti smooth sulle barre
    if (duel2v2TeamMate.health !== undefined && duel2v2TeamMate.targetHealth !== undefined) {
      duel2v2TeamMate.health += (duel2v2TeamMate.targetHealth - duel2v2TeamMate.health) * 0.3;
    }
    if (duel2v2TeamMate.energy !== undefined && duel2v2TeamMate.targetEnergy !== undefined) {
      duel2v2TeamMate.energy += (duel2v2TeamMate.targetEnergy - duel2v2TeamMate.energy) * 0.3;
    }
  }
  // Interpola opponents
  duel2v2Opponents.forEach(opponent => {
    if (opponent.targetX !== undefined && opponent.targetY !== undefined) {
      opponent.x += (opponent.targetX - opponent.x) * 0.3;
      opponent.y += (opponent.targetY - opponent.y) * 0.3;
    }
    if (opponent.health !== undefined && opponent.targetHealth !== undefined) {
      opponent.health += (opponent.targetHealth - opponent.health) * 0.3;
    }
    if (opponent.energy !== undefined && opponent.targetEnergy !== undefined) {
      opponent.energy += (opponent.targetEnergy - opponent.energy) * 0.3;
    }
  });
}


// 2. Ricezione e aggiornamento dello stato degli altri player
// PATCH: Update SOLO teammate e avversari, MAI la tua health locale!
function update2v2GameState(data) {
  if (!data) return;
  const myId = mySocketId || (window.socket && window.socket.id);
  const myTeamArr = duel2v2Team === "team1" ? data.team1 : data.team2;
  const oppTeamArr = duel2v2Team === "team1" ? data.team2 : data.team1;

  // Aggiorna solo il compagno (teammate)
  let teammate = myTeamArr.find(p => p.id !== myId);
  if (teammate) {
    duel2v2TeamMate = {
      ...teammate,
      targetX: teammate.x,
      targetY: teammate.y,
      targetHealth: teammate.health,
      targetEnergy: teammate.energy
    };
  }

  // Aggiorna solo gli AVVERSARI
  duel2v2Opponents = oppTeamArr.map(opp => ({
    ...opp,
    targetX: opp.x,
    targetY: opp.y,
    targetHealth: opp.health,
    targetEnergy: opp.energy
  }));

  // NON aggiornare la tua health qui!
  // gameState.player.health = ... // <--- NON mettere questa riga!
}


// Effetto di morte per un player (esplosione, scritta KO)
function showDeathEffect(x, y, nickname) {
  // Esplosione colorata
  spawnSuperExplosion(x, y, {
    colors: ["#f44336", "#ffd700", "#fff", "#00bcd4"],
    count: 22,
    sparkle: true
  });
  startShake(18, 22);
  startFlash(0.4);

  // Scritta KO temporanea
  const div = document.createElement('div');
  div.style.position = 'fixed';
  div.style.left = (x - 60) + 'px';
  div.style.top = (y - 60) + 'px';
  div.style.fontSize = '3.7rem';
  div.style.color = '#f44336';
  div.style.fontWeight = 'bold';
  div.style.zIndex = 99999;
  div.style.textShadow = '0 0 14px #ffd700, 0 0 45px #f44336';
  div.textContent = 'KO!';
  document.body.appendChild(div);
  setTimeout(() => div.remove(), 900);

  // Suono opzionale (se hai un audio KO)
  // document.getElementById('koSound')?.play();
}


// Esempio dentro update2v2Players(), oppure dopo ricezione stato da server
function checkPlayerDeaths() {
  // Teammate
  if (duel2v2TeamMate && duel2v2TeamMate._prevHealth > 0 && duel2v2TeamMate.health <= 0) {
    showDeathEffect(duel2v2TeamMate.x, duel2v2TeamMate.y, duel2v2TeamMate.nickname);
  }
  duel2v2TeamMate._prevHealth = duel2v2TeamMate.health;

  // Opponenti
  duel2v2Opponents.forEach(opp => {
    if (opp._prevHealth > 0 && opp.health <= 0) {
      showDeathEffect(opp.x, opp.y, opp.nickname);
    }
    opp._prevHealth = opp.health;
  });

  // Puoi farlo anche per te stesso:
  if (gameState.player._prevHealth > 0 && gameState.player.health <= 0) {
    showDeathEffect(gameState.player.x, gameState.player.y, getPlayerName());
        gameState.player.isSpectator = true; // <--- AGGIUNGI QUI
  }
  gameState.player._prevHealth = gameState.player.health;
}


(function() {
  if (!document.getElementById('specialAbilityBtn')) {
    const btn = document.createElement('button');
    btn.id = 'specialAbilityBtn';
    btn.className = 'menu-btn special';
    // PATCH SIZE & POSITION
    btn.style.position = 'fixed';
    btn.style.right = '32px';
    btn.style.bottom = '22px'; // pi√π in basso
    btn.style.zIndex = 9010;
    btn.style.fontSize = "0.98em"; // pi√π piccolo
    btn.style.padding = "0.3em 1.1em";
    btn.style.minWidth = "unset";
    btn.style.width = "auto";
    btn.style.height = "38px";
    btn.innerHTML = 'üåü Special';
    btn.onclick = function(){
      if (gameState.currentScreen === 'gameScreen' && gameState.gameMode === 'duel1v1') {
        activateSpecialAbility();
      } else {
        alert('Special pu√≤ essere attivata solo in modalit√† 1v1!');
      }
    };
    document.body.appendChild(btn);
  }
})();

// 2. Listener tasto "E" (e mobile)
document.addEventListener('keydown', function(e){
  if ((e.key || e.code).toLowerCase() === 'e' && gameState.currentScreen === 'gameScreen' && gameState.gameMode === 'duel1v1') {
    activateSpecialAbility();
  }
});

// 3. Funzione centrale con tutti gli effetti
function activateSpecialAbility() {
  if (gameState.player.specialCooldown > 0) {
    showNotification('Special on cooldown!', 'info');
    return;
  }
  // Solo in 1v1
  if (gameState.gameMode !== 'duel1v1') return;

  const ab = gameState.player.specialAbility || "stun";
  // Cooldown universale (6 sec)
  gameState.player.specialCooldown = 360; // 6 sec a 60fps

  // --- EFFETTI ---
  switch(ab) {
    case 'stun':
      if (window.socket && duelRoomId) {
        window.socket.emit('duel_update', { room: duelRoomId, action: 'stun', target: 'opponent' });
      }
      stunOpponent();
      showNotification("Opponent stunned!", "achievement");
      flashScreen("#ffd700", 0.22);
      break;
    case 'heal':
      gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + 40);
      showNotification("Healed +40 HP!", "achievement");
      spawnSuperExplosion(gameState.player.x, gameState.player.y, { colors: ['#4caf50','#fff'], count: 12 });
      break;
    case 'teleport':
      const tx = Math.random() * (canvas.width - 100) + 50;
      const ty = Math.random() * (canvas.height - 120) + 80;
      gameState.player.x = tx;
      gameState.player.y = ty;
      showNotification("Teleported!", "achievement");
      spawnRipple(tx, ty, "#00bcd4");
      break;
    case 'double':
      gameState.player.doubleShotActive = true;
      showNotification("Next shot is DOUBLE!", "achievement");
      flashScreen("#ffd700", 0.14);
      break;
    case 'shield':
      gameState.player.invulnerabilityFrames = 90; // 1.5 sec
      showNotification("Shield: Immunity!", "achievement");
      createShieldEffect();
      break;
    default:
      showNotification("No ability selected!", "info");
      break;
  }
}

// 4. Funzione effetto STUN (applica immobilit√† per 2s all‚Äôavversario)
function stunOpponent() {
  if (window.gameState.opponentState) {
    window.gameState.opponentState.stunned = true;
    setTimeout(() => {
      if (window.gameState.opponentState) window.gameState.opponentState.stunned = false;
    }, 2000);
  }
}

// 5. Patch loop di movimento avversario per effetto stun
window._origRenderOpponent = window._origRenderOpponent || renderOpponent;
window.renderOpponent = function(ctx) {
  const opp = gameState.opponentState;
  if (!opp) return;
  // Se stunnato, mostra effetto
  if (opp.stunned) {
    ctx.save();
    ctx.globalAlpha = 0.8;
    ctx.drawImage(new Image(), opp.x-32, opp.y-32, 64, 64); // puoi mettere sprite diverso
    ctx.font = "bold 22px Orbitron";
    ctx.fillStyle = "#ffd700";
    ctx.textAlign = "center";
    ctx.fillText("üòµ STUNNED!", opp.x, opp.y-70);
    ctx.restore();
    // Blocca movimento: non aggiornare opp.x/opp.y altrove!
  } else {
    window._origRenderOpponent(ctx);
  }
};

// 6. Patch SHOOT per Double Shot
window._origShoot = window._origShoot || shoot;
window.shoot = function() {
  window._origShoot();
  if (gameState.player.doubleShotActive) {
    setTimeout(() => window._origShoot(), 80);
    gameState.player.doubleShotActive = false;
  }
};

// 7. Animazioni e feedback
function flashScreen(color = "#ffd700", strength = 0.22) {
  const flash = document.createElement('div');
  flash.style.position = 'fixed';
  flash.style.top = '0'; flash.style.left = '0'; flash.style.width = '100vw'; flash.style.height = '100vh';
  flash.style.background = color;
  flash.style.opacity = strength;
  flash.style.zIndex = 99999;
  flash.style.transition = "opacity 0.7s";
  document.body.appendChild(flash);
  setTimeout(() => { flash.style.opacity = "0"; }, 400);
  setTimeout(() => { flash.remove(); }, 900);
}

// 8. Cooldown visuale bottone
setInterval(() => {
  if (gameState.currentScreen === 'gameScreen' && gameState.gameMode === 'duel1v1') {
    const btn = document.getElementById('specialAbilityBtn');
    if (!btn) return;
    if (gameState.player.specialCooldown > 0) {
      btn.disabled = true;
      btn.innerHTML = 'üåü Cooldown...';
      btn.style.opacity = '0.5';
    } else {
      btn.disabled = false;
      btn.innerHTML = 'üåü Activate Special';
      btn.style.opacity = '1';
    }
  }
}, 200);



// Mostra menu lobby
function showClickReactionMenu() {
  hideAllScreens();
  document.getElementById('clickReactionLobby').classList.remove('hidden');
  document.getElementById('cr_nick').value = getPlayerName();
  document.getElementById('cr_lobby_status').textContent = '';
  document.getElementById('cr_lobby_players').innerHTML = '';
}

// Chiudi lobby
function hideClickReactionLobby() {
  document.getElementById('clickReactionLobby').classList.add('hidden');
}

// Crea stanza
function createClickReactionRoom() {
  connectClickReactionSocket();
  cr_socket.emit('reaction_create_room', { nickname: document.getElementById('cr_nick').value || "Player" });
  document.getElementById('cr_lobby_status').textContent = 'Creazione stanza...';
}

// Unisciti a stanza
function joinClickReactionRoom() {
  connectClickReactionSocket();
  cr_socket.emit('reaction_join_room', {
    roomCode: document.getElementById('cr_roomcode').value.trim().toUpperCase(),
    nickname: document.getElementById('cr_nick').value || "Player"
  });
  document.getElementById('cr_lobby_status').textContent = 'Richiesta di accesso...';
}

// Connessione socket (solo 1 volta)
function connectClickReactionSocket() {
  if (cr_socket) return;
cr_socket = io(SERVER_CLICK_URL);
  // Eventi socket
  cr_socket.on('reaction_room_created', ({ roomCode, players }) => {
    cr_room = roomCode;
    cr_players = players;
    crUpdateLobby();
    document.getElementById('cr_lobby_status').textContent = `Stanza creata: Codice ${roomCode}`;
  });
  cr_socket.on('reaction_room_joined', ({ roomCode, players }) => {
    cr_room = roomCode;
    cr_players = players;
    crUpdateLobby();
    document.getElementById('cr_lobby_status').textContent = `Entrato nella stanza: ${roomCode}`;
  });
  cr_socket.on('reaction_player_joined', ({ player, players }) => {
    cr_players = players;
    crUpdateLobby();
  });
  cr_socket.on('reaction_ready_update', ({ players }) => {
    cr_players = players;
    crUpdateLobby();
  });
  cr_socket.on('reaction_game_start', ({ message }) => {
    cr_state = "playing";
    document.getElementById('clickReactionLobby').classList.add('hidden');
    document.getElementById('clickReactionGame').classList.remove('hidden');
    document.getElementById('cr_game_status').textContent = message || "Via!";
    document.getElementById('cr_reaction_target').innerHTML = '';
    crUpdateScores();
  });
  cr_socket.on('reaction_round_prepare', ({ round, message }) => {
    document.getElementById('cr_game_status').textContent = message || `Round ${round}`;
    document.getElementById('cr_reaction_target').innerHTML = '';
  });
  cr_socket.on('reaction_show_target', ({ x, y, size, startTime }) => {
    crShowTarget(x, y, size, startTime);
  });
  cr_socket.on('reaction_round_winner', ({ winner, scores, round }) => {
    document.getElementById('cr_game_status').textContent = `${winner.nickname} ha vinto il round in ${winner.time} ms!`;
    crUpdateScores(scores);
    document.getElementById('cr_reaction_target').innerHTML = '';
  });
  cr_socket.on('reaction_game_over', ({ winner, message, stats }) => {
    cr_state = "ended";
    document.getElementById('cr_game_status').textContent = message;
    crUpdateScores(stats);
    document.getElementById('cr_reaction_target').innerHTML = '';
    setTimeout(crReturnToLobby, 3500);
  });
  cr_socket.on('reaction_error', ({ message }) => {
    document.getElementById('cr_lobby_status').textContent = message;
  });
  cr_socket.on('reaction_player_left', ({ players }) => {
    cr_players = players;
    crUpdateLobby();
  });
}

// Aggiorna lista giocatori
function crUpdateLobby() {
  let html = "<b>Giocatori:</b><ul>";
  cr_players.forEach(p => {
    html += `<li>${p.nickname} ${p.ready ? "‚úÖ" : "‚è≥"}</li>`;
  });
  html += "</ul>";
  if (cr_players.length >= 2) {
    html += `<button class="menu-btn" onclick="crReady()">Pronto!</button>`;
  }
  document.getElementById('cr_lobby_players').innerHTML = html;
}

// Click "Pronto!"
function crReady() {
  if (cr_socket && cr_room) cr_socket.emit('reaction_player_ready', { roomCode: cr_room });
}

// Mostra target da cliccare
function crShowTarget(x, y, size, startTime) {
  const targetDiv = document.getElementById('cr_reaction_target');
  targetDiv.innerHTML = '';
  const btn = document.createElement('div');
  btn.style.position = 'absolute';
  btn.style.left = `${x}%`;
  btn.style.top = `${y}%`;
  btn.style.width = `${size.width}px`;
  btn.style.height = `${size.height}px`;
  btn.style.background = "radial-gradient(circle,#ffd700 60%,#00bcd4 100%)";
  btn.style.border = "3px solid #00bcd4";
  btn.style.borderRadius = "50%";
  btn.style.cursor = "pointer";
  btn.style.transform = "translate(-50%,-50%) scale(1.15)";
  btn.style.boxShadow = "0 0 24px #ffd700";
  btn.onclick = function () {
    if (cr_socket && cr_room) {
      cr_socket.emit('reaction_click', {
        roomCode: cr_room,
        timestamp: Date.now()
      });
      btn.style.filter = "brightness(0.7)";
      btn.style.pointerEvents = "none";
    }
  };
  targetDiv.appendChild(btn);
}

// Aggiorna tabellone punteggi
function crUpdateScores(scores) {
  scores = scores || cr_players;
  let html = "<b>Punteggi:</b><ul>";
  scores.forEach(p => {
    html += `<li>${p.nickname}: ${p.score || 0} pts ${p.lastTime ? `(${p.lastTime} ms)` : ""}</li>`;
  });
  html += "</ul>";
  document.getElementById('cr_scores').innerHTML = html;
}

// Torna in lobby dopo partita
function crReturnToLobby() {
  document.getElementById('clickReactionGame').classList.add('hidden');
  document.getElementById('clickReactionLobby').classList.remove('hidden');
  crUpdateLobby();
}

// Lascia stanza
function leaveClickReactionRoom() {
  if (cr_socket && cr_room) cr_socket.emit('reaction_leave_room', { roomCode: cr_room });
  document.getElementById('clickReactionGame').classList.add('hidden');
  document.getElementById('clickReactionLobby').classList.add('hidden');
  cr_room = null;
  cr_players = [];
}

// Utility: nasconde tutte le schermate principali (opzionale)
function hideAllScreens() {
  document.querySelectorAll('.screen, .duel-lobby').forEach(s => s.classList.add('hidden'));
}

function goToHomeFromClickReaction() {
  document.getElementById('clickReactionLobby').classList.add('hidden');
  document.getElementById('clickReactionGame').classList.add('hidden');
  showScreen('mainMenu');
}





</script>
  
</body>
</html>